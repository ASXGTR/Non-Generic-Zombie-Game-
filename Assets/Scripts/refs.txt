./all_refs.txt:./Audio/Audio.asmdef:  "references": [],
./all_refs.txt:./Combat/Combat.asmdef:  "references": [
./all_refs.txt:./Core/Core.asmdef:  "references": [],
./all_refs.txt:./Crafting/Crafting.asmdef:  "references": [
./all_refs.txt:./Debug/Debug.asmdef:  "references": [
./all_refs.txt:./DevTools/DevTools.asmdef:  "references": [
./all_refs.txt:./DialogueSystem/DialogueSystem.asmdef:  "references": [
./all_refs.txt:./Editor/Editor.asmdef:  "references": [
./all_refs.txt:./Environment/Environment.asmdef:  "references": [
./all_refs.txt:./Flags/Flags.asmdef:  "references": [],
./all_refs.txt:./Interaction/Interaction.asmdef:  "references": [
./all_refs.txt:./Inventory/Inventory.asmdef:  "references": [
./all_refs.txt:./Narrative/Narrative.asmdef:  "references": [
./all_refs.txt:./Player/Player.asmdef:  "references": [
./all_refs.txt:./Quests/Quests.asmdef:  "references": [],
./all_refs.txt:./Scene/Scene.asmdef:  "references": [
./all_refs.txt:./Systems/Systems.asmdef:  "references": [
./all_refs.txt:./UI/UI.asmdef:  "references": [
./all_refs.txt:./Validation/Validation.asmdef:  "references": [
./all_refs.txt:./World/World.asmdef:  "references": [
--
./Audio/AmbientAudioTrigger.cs:using UnityEngine;
./Audio/AmbientAudioTrigger.cs:
./Audio/AmbientAudioTrigger.cs:namespace Audio
./Audio/AmbientAudioTrigger.cs:{
./Audio/AmbientAudioTrigger.cs:    public class AmbientAudioTrigger : MonoBehaviour
./Audio/AmbientAudioTrigger.cs:    {
./Audio/AmbientAudioTrigger.cs:        [SerializeField] private AudioClip clip;
./Audio/AmbientAudioTrigger.cs:        [SerializeField] private AudioSource audioSource;
./Audio/AmbientAudioTrigger.cs:
./Audio/AmbientAudioTrigger.cs:        private void OnTriggerEnter(Collider other)
./Audio/AmbientAudioTrigger.cs:        {
./Audio/AmbientAudioTrigger.cs:            if (other.CompareTag("Player"))
./Audio/AmbientAudioTrigger.cs:            {
./Audio/AmbientAudioTrigger.cs:                audioSource.clip = clip;
./Audio/AmbientAudioTrigger.cs:                audioSource.Play();
./Audio/AmbientAudioTrigger.cs:            }
./Audio/AmbientAudioTrigger.cs:        }
./Audio/AmbientAudioTrigger.cs:    }
./Audio/AmbientAudioTrigger.cs:}
--
./Audio/AmbientAudioTrigger.cs.meta:fileFormatVersion: 2
./Audio/AmbientAudioTrigger.cs.meta:guid: 1e1a674c2417f1c47893a10cef965dd0
--
./Audio/Audio.asmdef:{
./Audio/Audio.asmdef:  "name": "Audio",
./Audio/Audio.asmdef:  "references": [],
./Audio/Audio.asmdef:  "includePlatforms": [],
./Audio/Audio.asmdef:  "excludePlatforms": [],
./Audio/Audio.asmdef:  "allowUnsafeCode": false,
./Audio/Audio.asmdef:  "overrideReferences": false,
./Audio/Audio.asmdef:  "precompiledReferences": [],
./Audio/Audio.asmdef:  "autoReferenced": true,
./Audio/Audio.asmdef:  "defineConstraints": [],
./Audio/Audio.asmdef:  "versionDefines": [],
./Audio/Audio.asmdef:  "noEngineReferences": false
./Audio/Audio.asmdef:}
--
./Audio/Audio.asmdef.meta:fileFormatVersion: 2
./Audio/Audio.asmdef.meta:guid: 303eb060dece66445b2b10c3bd410cc4
./Audio/Audio.asmdef.meta:AssemblyDefinitionImporter:
./Audio/Audio.asmdef.meta:  externalObjects: {}
./Audio/Audio.asmdef.meta:  userData: 
./Audio/Audio.asmdef.meta:  assetBundleName: 
./Audio/Audio.asmdef.meta:  assetBundleVariant: 
--
./Audio/AudioTypes.cs:namespace Audio
./Audio/AudioTypes.cs:{
./Audio/AudioTypes.cs:    public enum AudioCue
./Audio/AudioTypes.cs:    {
./Audio/AudioTypes.cs:        ButtonClick,
./Audio/AudioTypes.cs:        Alert,
./Audio/AudioTypes.cs:        AmbientLoop,
./Audio/AudioTypes.cs:        Notification,
./Audio/AudioTypes.cs:        ItemPickup
./Audio/AudioTypes.cs:    }
./Audio/AudioTypes.cs:
./Audio/AudioTypes.cs:    public enum SoundCategory
./Audio/AudioTypes.cs:    {
./Audio/AudioTypes.cs:        UI,
./Audio/AudioTypes.cs:        Environment,
./Audio/AudioTypes.cs:        Dialogue,
./Audio/AudioTypes.cs:        Combat,
./Audio/AudioTypes.cs:        Foley
./Audio/AudioTypes.cs:    }
./Audio/AudioTypes.cs:
./Audio/AudioTypes.cs:    public enum AmbientType
./Audio/AudioTypes.cs:    {
./Audio/AudioTypes.cs:        Rain,
./Audio/AudioTypes.cs:        Wind,
./Audio/AudioTypes.cs:        Thunder,
./Audio/AudioTypes.cs:        Birds,
./Audio/AudioTypes.cs:        Silence
./Audio/AudioTypes.cs:    }
./Audio/AudioTypes.cs:}
--
./Audio/AudioTypes.cs.meta:fileFormatVersion: 2
./Audio/AudioTypes.cs.meta:guid: bef6f4a91ae878b48b7baf80ae016d45
--
./Audio.meta:fileFormatVersion: 2
./Audio.meta:guid: e1a7251581a411a43bc15edeb39db3c7
./Audio.meta:folderAsset: yes
./Audio.meta:DefaultImporter:
./Audio.meta:  externalObjects: {}
./Audio.meta:  userData: 
./Audio.meta:  assetBundleName: 
./Audio.meta:  assetBundleVariant: 
--
./Combat/Combat.asmdef:{
./Combat/Combat.asmdef:  "name": "Combat",
./Combat/Combat.asmdef:  "references": [
./Combat/Combat.asmdef:    "Player",
./Combat/Combat.asmdef:    "Core"
./Combat/Combat.asmdef:  ],
./Combat/Combat.asmdef:  "autoReferenced": true,
./Combat/Combat.asmdef:  "includePlatforms": [],
./Combat/Combat.asmdef:  "excludePlatforms": []
./Combat/Combat.asmdef:}
--
./Combat/Combat.asmdef.meta:fileFormatVersion: 2
./Combat/Combat.asmdef.meta:guid: 6c54f4a5056a48643a63d2b2c2a4b116
./Combat/Combat.asmdef.meta:AssemblyDefinitionImporter:
./Combat/Combat.asmdef.meta:  externalObjects: {}
./Combat/Combat.asmdef.meta:  userData: 
./Combat/Combat.asmdef.meta:  assetBundleName: 
./Combat/Combat.asmdef.meta:  assetBundleVariant: 
--
./Combat/DamageSystem.cs:using UnityEngine;
./Combat/DamageSystem.cs:
./Combat/DamageSystem.cs:namespace Combat
./Combat/DamageSystem.cs:{
./Combat/DamageSystem.cs:    public class DamageSystem : MonoBehaviour
./Combat/DamageSystem.cs:    {
./Combat/DamageSystem.cs:        [SerializeField] private Player.PlayerStats stats;
./Combat/DamageSystem.cs:        [SerializeField] private string statAffected = "Health";
./Combat/DamageSystem.cs:
./Combat/DamageSystem.cs:        public void ApplyDamage(int amount)
./Combat/DamageSystem.cs:        {
./Combat/DamageSystem.cs:            stats.ModifyStat(statAffected, -amount);
./Combat/DamageSystem.cs:            Debug.Log($"[DamageSystem] {amount} damage applied to {statAffected}");
./Combat/DamageSystem.cs:        }
./Combat/DamageSystem.cs:
./Combat/DamageSystem.cs:        public void Heal(int amount)
./Combat/DamageSystem.cs:        {
./Combat/DamageSystem.cs:            stats.ModifyStat(statAffected, +amount);
./Combat/DamageSystem.cs:        }
./Combat/DamageSystem.cs:    }
./Combat/DamageSystem.cs:}
--
./Combat/DamageSystem.cs.meta:fileFormatVersion: 2
./Combat/DamageSystem.cs.meta:guid: 82dfc0eca5c0eee429481178baff11ee
--
./Combat.meta:fileFormatVersion: 2
./Combat.meta:guid: 487ccb1946b282e4899aa73b0ae1e3cc
./Combat.meta:folderAsset: yes
./Combat.meta:DefaultImporter:
./Combat.meta:  externalObjects: {}
./Combat.meta:  userData: 
./Combat.meta:  assetBundleName: 
./Combat.meta:  assetBundleVariant: 
--
./Core/Core.asmdef:{
./Core/Core.asmdef:  "name": "Core",
./Core/Core.asmdef:  "references": [],
./Core/Core.asmdef:  "includePlatforms": [],
./Core/Core.asmdef:  "excludePlatforms": [],
./Core/Core.asmdef:  "allowUnsafeCode": false,
./Core/Core.asmdef:  "overrideReferences": false,
./Core/Core.asmdef:  "precompiledReferences": [],
./Core/Core.asmdef:  "autoReferenced": true,
./Core/Core.asmdef:  "defineConstraints": [],
./Core/Core.asmdef:  "versionDefines": [],
./Core/Core.asmdef:  "noEngineReferences": false
./Core/Core.asmdef:}
--
./Core/Core.asmdef.meta:fileFormatVersion: 2
./Core/Core.asmdef.meta:guid: 0c85537727adf7840b0ff223edf2a987
./Core/Core.asmdef.meta:AssemblyDefinitionImporter:
./Core/Core.asmdef.meta:  externalObjects: {}
./Core/Core.asmdef.meta:  userData: 
./Core/Core.asmdef.meta:  assetBundleName: 
./Core/Core.asmdef.meta:  assetBundleVariant: 
--
./Core/InventoryItem.cs:// File: Assets/Scripts/Inventory/InventoryItem.cs
./Core/InventoryItem.cs:using UnityEngine;
./Core/InventoryItem.cs:
./Core/InventoryItem.cs:namespace Game.Inventory
./Core/InventoryItem.cs:{
./Core/InventoryItem.cs:    [CreateAssetMenu(fileName = "NewInventoryItem", menuName = "Inventory/Item")]
./Core/InventoryItem.cs:    public class InventoryItem : ScriptableObject
./Core/InventoryItem.cs:    {
./Core/InventoryItem.cs:        [Header("Basic Info")]
./Core/InventoryItem.cs:        public string ItemName;
./Core/InventoryItem.cs:        public Sprite Icon;
./Core/InventoryItem.cs:        public ItemTypeEnum Type;
./Core/InventoryItem.cs:        [TextArea] public string Description;
./Core/InventoryItem.cs:
./Core/InventoryItem.cs:        [Header("Stacking")]
./Core/InventoryItem.cs:        public bool IsStackable = false;
./Core/InventoryItem.cs:        public int MaxStackSize = 1;
./Core/InventoryItem.cs:
./Core/InventoryItem.cs:        [Header("Metadata")]
./Core/InventoryItem.cs:        public string Category;
./Core/InventoryItem.cs:        public int BaseValue;
./Core/InventoryItem.cs:        public bool IsQuestItem;
./Core/InventoryItem.cs:        public bool IsConsumable;
./Core/InventoryItem.cs:
./Core/InventoryItem.cs:        [Header("Debug")]
./Core/InventoryItem.cs:        public bool ShowInDebugLog = false;
./Core/InventoryItem.cs:
./Core/InventoryItem.cs:        public override string ToString()
./Core/InventoryItem.cs:        {
./Core/InventoryItem.cs:            return $"{ItemName} ({Type}) - {Category} | Stackable: {IsStackable} x{MaxStackSize}";
./Core/InventoryItem.cs:        }
./Core/InventoryItem.cs:    }
./Core/InventoryItem.cs:}
--
./Core/InventoryItem.cs.meta:fileFormatVersion: 2
./Core/InventoryItem.cs.meta:guid: 3bd5fa58086747948bb41655e5565ff4
--
./Core.meta:fileFormatVersion: 2
./Core.meta:guid: 5aaa567c5908fb6419763f7d79685d73
./Core.meta:folderAsset: yes
./Core.meta:DefaultImporter:
./Core.meta:  externalObjects: {}
./Core.meta:  userData: 
./Core.meta:  assetBundleName: 
./Core.meta:  assetBundleVariant: 
--
./Crafting/Crafting.asmdef:{
./Crafting/Crafting.asmdef:  "name": "Crafting",
./Crafting/Crafting.asmdef:  "references": [
./Crafting/Crafting.asmdef:    "Systems",
./Crafting/Crafting.asmdef:    "Core"
./Crafting/Crafting.asmdef:  ],
./Crafting/Crafting.asmdef:  "includePlatforms": [],
./Crafting/Crafting.asmdef:  "excludePlatforms": [],
./Crafting/Crafting.asmdef:  "allowUnsafeCode": false,
./Crafting/Crafting.asmdef:  "overrideReferences": false,
./Crafting/Crafting.asmdef:  "precompiledReferences": [],
./Crafting/Crafting.asmdef:  "autoReferenced": true,
./Crafting/Crafting.asmdef:  "defineConstraints": [],
./Crafting/Crafting.asmdef:  "versionDefines": [],
./Crafting/Crafting.asmdef:  "noEngineReferences": false
./Crafting/Crafting.asmdef:}
--
./Crafting/Crafting.asmdef.meta:fileFormatVersion: 2
./Crafting/Crafting.asmdef.meta:guid: 5c1e997bba4f97e41aeaab9042226901
./Crafting/Crafting.asmdef.meta:AssemblyDefinitionImporter:
./Crafting/Crafting.asmdef.meta:  externalObjects: {}
./Crafting/Crafting.asmdef.meta:  userData: 
./Crafting/Crafting.asmdef.meta:  assetBundleName: 
./Crafting/Crafting.asmdef.meta:  assetBundleVariant: 
--
./Crafting/CraftingManager.cs:﻿using Game.Inventory;
./Crafting/CraftingManager.cs:using Inventory;
./Crafting/CraftingManager.cs:using System.Collections.Generic;
./Crafting/CraftingManager.cs:using UnityEngine;
./Crafting/CraftingManager.cs:
./Crafting/CraftingManager.cs:namespace Crafting
./Crafting/CraftingManager.cs:{
./Crafting/CraftingManager.cs:    /// <summary>
./Crafting/CraftingManager.cs:    /// Handles crafting logic using predefined recipes and available inventory.
./Crafting/CraftingManager.cs:    /// </summary>
./Crafting/CraftingManager.cs:    public class CraftingManager : MonoBehaviour
./Crafting/CraftingManager.cs:    {
./Crafting/CraftingManager.cs:        [Header("References")]
./Crafting/CraftingManager.cs:        public InventoryManager playerInventory;
./Crafting/CraftingManager.cs:        public List<CraftingRecipe> availableRecipes;
./Crafting/CraftingManager.cs:
./Crafting/CraftingManager.cs:        private const string logTag = "[CraftingManager]";
./Crafting/CraftingManager.cs:
./Crafting/CraftingManager.cs:        /// <summary>
./Crafting/CraftingManager.cs:        /// Attempts to craft an item by recipe name.
./Crafting/CraftingManager.cs:        /// </summary>
./Crafting/CraftingManager.cs:        public bool TryCraft(string recipeName)
./Crafting/CraftingManager.cs:        {
./Crafting/CraftingManager.cs:            CraftingRecipe recipe = availableRecipes.Find(r => r.recipeName == recipeName);
./Crafting/CraftingManager.cs:            if (recipe == null)
./Crafting/CraftingManager.cs:            {
./Crafting/CraftingManager.cs:                Debug.LogWarning($"{logTag} ❌ Recipe '{recipeName}' not found.");
./Crafting/CraftingManager.cs:                return false;
./Crafting/CraftingManager.cs:            }
./Crafting/CraftingManager.cs:
./Crafting/CraftingManager.cs:            if (!HasRequiredIngredients(recipe))
./Crafting/CraftingManager.cs:            {
./Crafting/CraftingManager.cs:                Debug.LogWarning($"{logTag} ⚠️ Missing ingredients for '{recipeName}'.");
./Crafting/CraftingManager.cs:                return false;
./Crafting/CraftingManager.cs:            }
./Crafting/CraftingManager.cs:
./Crafting/CraftingManager.cs:            ConsumeIngredients(recipe);
./Crafting/CraftingManager.cs:            CreateCraftedItem(recipe);
./Crafting/CraftingManager.cs:            Debug.Log($"{logTag} ✅ Crafted: {recipe.resultItem.ItemName}");
./Crafting/CraftingManager.cs:            return true;
./Crafting/CraftingManager.cs:        }
./Crafting/CraftingManager.cs:
./Crafting/CraftingManager.cs:        private bool HasRequiredIngredients(CraftingRecipe recipe)
./Crafting/CraftingManager.cs:        {
./Crafting/CraftingManager.cs:            foreach (var ingredient in recipe.requiredIngredients)
./Crafting/CraftingManager.cs:            {
./Crafting/CraftingManager.cs:                int count = playerInventory.CountItemByName(ingredient.itemName);
./Crafting/CraftingManager.cs:                if (count < ingredient.quantity)
./Crafting/CraftingManager.cs:                    return false;
./Crafting/CraftingManager.cs:            }
./Crafting/CraftingManager.cs:            return true;
./Crafting/CraftingManager.cs:        }
./Crafting/CraftingManager.cs:
./Crafting/CraftingManager.cs:        private void ConsumeIngredients(CraftingRecipe recipe)
./Crafting/CraftingManager.cs:        {
./Crafting/CraftingManager.cs:            foreach (var ingredient in recipe.requiredIngredients)
./Crafting/CraftingManager.cs:            {
./Crafting/CraftingManager.cs:                playerInventory.RemoveItemsByName(ingredient.itemName, ingredient.quantity);
./Crafting/CraftingManager.cs:            }
./Crafting/CraftingManager.cs:        }
./Crafting/CraftingManager.cs:
./Crafting/CraftingManager.cs:        private void CreateCraftedItem(CraftingRecipe recipe)
./Crafting/CraftingManager.cs:        {
./Crafting/CraftingManager.cs:            Debug.LogWarning($"{logTag} ⚠️ Skipped runtime instantiation for ScriptableObject '{recipe.resultItem.ItemName}'.");
./Crafting/CraftingManager.cs:            // To support stackable crafting, prefab-based or asset registry could be integrated here
./Crafting/CraftingManager.cs:        }
./Crafting/CraftingManager.cs:    }
./Crafting/CraftingManager.cs:
./Crafting/CraftingManager.cs:    [System.Serializable]
./Crafting/CraftingManager.cs:    public class CraftingRecipe
./Crafting/CraftingManager.cs:    {
./Crafting/CraftingManager.cs:        public string recipeName;
./Crafting/CraftingManager.cs:        public ItemData resultItem;
./Crafting/CraftingManager.cs:        public List<CraftingIngredient> requiredIngredients;
./Crafting/CraftingManager.cs:    }
./Crafting/CraftingManager.cs:
./Crafting/CraftingManager.cs:    [System.Serializable]
./Crafting/CraftingManager.cs:    public class CraftingIngredient
./Crafting/CraftingManager.cs:    {
./Crafting/CraftingManager.cs:        public string itemName;
./Crafting/CraftingManager.cs:        public int quantity;
./Crafting/CraftingManager.cs:    }
./Crafting/CraftingManager.cs:}
--
./Crafting/CraftingManager.cs.meta:fileFormatVersion: 2
./Crafting/CraftingManager.cs.meta:guid: 1157255ccbe4d364aa080155046d33e7
--
./Crafting.meta:fileFormatVersion: 2
./Crafting.meta:guid: 800754f53031df44bb65b8650790a387
./Crafting.meta:folderAsset: yes
./Crafting.meta:DefaultImporter:
./Crafting.meta:  externalObjects: {}
./Crafting.meta:  userData: 
./Crafting.meta:  assetBundleName: 
./Crafting.meta:  assetBundleVariant: 
--
./Debug/CampSceneAndInventoryHarness.cs:// Filename: CampSceneAndInventoryHarness.cs
./Debug/CampSceneAndInventoryHarness.cs:// Location: Assets/Scripts/Harness
./Debug/CampSceneAndInventoryHarness.cs:// Namespace: Harness
./Debug/CampSceneAndInventoryHarness.cs:
./Debug/CampSceneAndInventoryHarness.cs:using Data;        // For RecipeData
./Debug/CampSceneAndInventoryHarness.cs:using Environment; // For CampData and CampObjectSpawner
./Debug/CampSceneAndInventoryHarness.cs:using Inventory;   // For StoragePanelBinder and InventoryUIUpdater
./Debug/CampSceneAndInventoryHarness.cs:using UnityEngine;
./Debug/CampSceneAndInventoryHarness.cs:using UnityEngine.SceneManagement;
./Debug/CampSceneAndInventoryHarness.cs:
./Debug/CampSceneAndInventoryHarness.cs:namespace Harness
./Debug/CampSceneAndInventoryHarness.cs:{
./Debug/CampSceneAndInventoryHarness.cs:    public class CampSceneAndInventoryHarness : MonoBehaviour
./Debug/CampSceneAndInventoryHarness.cs:    {
./Debug/CampSceneAndInventoryHarness.cs:        [Header("Camp Setup")]
./Debug/CampSceneAndInventoryHarness.cs:        public CampData campData;
./Debug/CampSceneAndInventoryHarness.cs:        public CampObjectSpawner objectSpawner;
./Debug/CampSceneAndInventoryHarness.cs:
./Debug/CampSceneAndInventoryHarness.cs:        [Header("Inventory")]
./Debug/CampSceneAndInventoryHarness.cs:        public StoragePanelBinder storagePanelBinder;
./Debug/CampSceneAndInventoryHarness.cs:        public InventoryUIUpdater uiUpdater;
./Debug/CampSceneAndInventoryHarness.cs:
./Debug/CampSceneAndInventoryHarness.cs:        [Header("Recipes")]
./Debug/CampSceneAndInventoryHarness.cs:        public RecipeData[] recipeBook;
./Debug/CampSceneAndInventoryHarness.cs:
./Debug/CampSceneAndInventoryHarness.cs:        private void Awake()
./Debug/CampSceneAndInventoryHarness.cs:        {
./Debug/CampSceneAndInventoryHarness.cs:            InitializeCamp();
./Debug/CampSceneAndInventoryHarness.cs:            BindInventory();
./Debug/CampSceneAndInventoryHarness.cs:        }
./Debug/CampSceneAndInventoryHarness.cs:
./Debug/CampSceneAndInventoryHarness.cs:        private void InitializeCamp()
./Debug/CampSceneAndInventoryHarness.cs:        {
./Debug/CampSceneAndInventoryHarness.cs:            if (campData != null && objectSpawner != null)
./Debug/CampSceneAndInventoryHarness.cs:            {
./Debug/CampSceneAndInventoryHarness.cs:                objectSpawner.SpawnCampObjects(campData);
./Debug/CampSceneAndInventoryHarness.cs:            }
./Debug/CampSceneAndInventoryHarness.cs:            else
./Debug/CampSceneAndInventoryHarness.cs:            {
./Debug/CampSceneAndInventoryHarness.cs:                Debug.LogWarning("CampData or ObjectSpawner not assigned.");
./Debug/CampSceneAndInventoryHarness.cs:            }
./Debug/CampSceneAndInventoryHarness.cs:        }
./Debug/CampSceneAndInventoryHarness.cs:
./Debug/CampSceneAndInventoryHarness.cs:        private void BindInventory()
./Debug/CampSceneAndInventoryHarness.cs:        {
./Debug/CampSceneAndInventoryHarness.cs:            if (storagePanelBinder != null && uiUpdater != null)
./Debug/CampSceneAndInventoryHarness.cs:            {
./Debug/CampSceneAndInventoryHarness.cs:                storagePanelBinder.BindPanels();
./Debug/CampSceneAndInventoryHarness.cs:                uiUpdater.RefreshInventoryDisplay();
./Debug/CampSceneAndInventoryHarness.cs:            }
./Debug/CampSceneAndInventoryHarness.cs:            else
./Debug/CampSceneAndInventoryHarness.cs:            {
./Debug/CampSceneAndInventoryHarness.cs:                Debug.LogWarning("Inventory binder or UI updater not assigned.");
./Debug/CampSceneAndInventoryHarness.cs:            }
./Debug/CampSceneAndInventoryHarness.cs:        }
./Debug/CampSceneAndInventoryHarness.cs:    }
./Debug/CampSceneAndInventoryHarness.cs:}
--
./Debug/CampSceneAndInventoryHarness.cs.meta:fileFormatVersion: 2
./Debug/CampSceneAndInventoryHarness.cs.meta:guid: a6b30de5a5adfda49bf9871ed3072235
--
./Debug/CookingDebugHarness.cs:using Game.Inventory;
./Debug/CookingDebugHarness.cs:using Inventory;
./Debug/CookingDebugHarness.cs:using Inventory.DataModels;
./Debug/CookingDebugHarness.cs:using Systems.Cooking;
./Debug/CookingDebugHarness.cs:using UnityEngine;
./Debug/CookingDebugHarness.cs:
./Debug/CookingDebugHarness.cs:namespace Debug
./Debug/CookingDebugHarness.cs:{
./Debug/CookingDebugHarness.cs:    public class CookingDebugHarness : MonoBehaviour
./Debug/CookingDebugHarness.cs:    {
./Debug/CookingDebugHarness.cs:        public ItemData[] testIngredients;
./Debug/CookingDebugHarness.cs:        public RecipeData recipe;
./Debug/CookingDebugHarness.cs:
./Debug/CookingDebugHarness.cs:        void Start()
./Debug/CookingDebugHarness.cs:        {
./Debug/CookingDebugHarness.cs:            if (CookingValidator.CanBeCooked(testIngredients[0]))
./Debug/CookingDebugHarness.cs:            {
./Debug/CookingDebugHarness.cs:                float burnChance = CookingOutcomeCalculator.GetBurnChance(recipe, testIngredients);
./Debug/CookingDebugHarness.cs:                UnityEngine.Debug.Log($"Burn chance: {burnChance}%");
./Debug/CookingDebugHarness.cs:            }
./Debug/CookingDebugHarness.cs:        }
./Debug/CookingDebugHarness.cs:    }
./Debug/CookingDebugHarness.cs:}
--
./Debug/CookingDebugHarness.cs.meta:fileFormatVersion: 2
./Debug/CookingDebugHarness.cs.meta:guid: d8ecd1f37a8338542a540776b6ad9b85
--
./Debug/Debug.asmdef:{
./Debug/Debug.asmdef:  "name": "Debug",
./Debug/Debug.asmdef:  "references": [
./Debug/Debug.asmdef:    "Inventory",
./Debug/Debug.asmdef:    "Environment",
./Debug/Debug.asmdef:    "UI",
./Debug/Debug.asmdef:    "Systems"
./Debug/Debug.asmdef:  ],
./Debug/Debug.asmdef:  "includePlatforms": [],
./Debug/Debug.asmdef:  "excludePlatforms": [],
./Debug/Debug.asmdef:  "allowUnsafeCode": false,
./Debug/Debug.asmdef:  "overrideReferences": false,
./Debug/Debug.asmdef:  "precompiledReferences": [],
./Debug/Debug.asmdef:  "autoReferenced": true,
./Debug/Debug.asmdef:  "defineConstraints": [],
./Debug/Debug.asmdef:  "versionDefines": [],
./Debug/Debug.asmdef:  "noEngineReferences": false
./Debug/Debug.asmdef:}
--
./Debug/Debug.asmdef.meta:fileFormatVersion: 2
./Debug/Debug.asmdef.meta:guid: ac2a55ce9bb92434a847c3a322247fb3
./Debug/Debug.asmdef.meta:AssemblyDefinitionImporter:
./Debug/Debug.asmdef.meta:  externalObjects: {}
./Debug/Debug.asmdef.meta:  userData: 
./Debug/Debug.asmdef.meta:  assetBundleName: 
./Debug/Debug.asmdef.meta:  assetBundleVariant: 
--
./Debug/DragAndDropHarness.cs:using Inventory.UI;
./Debug/DragAndDropHarness.cs:using UI.Core;
./Debug/DragAndDropHarness.cs:using UnityEngine;
./Debug/DragAndDropHarness.cs:using UnityEngine.EventSystems;
./Debug/DragAndDropHarness.cs:
./Debug/DragAndDropHarness.cs:namespace Debug
./Debug/DragAndDropHarness.cs:{
./Debug/DragAndDropHarness.cs:    public class DragAndDropHarness : MonoBehaviour
./Debug/DragAndDropHarness.cs:    {
./Debug/DragAndDropHarness.cs:        public GameObject itemPrefab;
./Debug/DragAndDropHarness.cs:        public Transform[] dropSlots;
./Debug/DragAndDropHarness.cs:
./Debug/DragAndDropHarness.cs:        private GameObject draggedItem;
./Debug/DragAndDropHarness.cs:
./Debug/DragAndDropHarness.cs:        void Start()
./Debug/DragAndDropHarness.cs:        {
./Debug/DragAndDropHarness.cs:            draggedItem = Instantiate(itemPrefab, transform);
./Debug/DragAndDropHarness.cs:            var dragHandler = draggedItem.AddComponent<UIDragHandler>();
./Debug/DragAndDropHarness.cs:            dragHandler.Initialize(dropSlots);
./Debug/DragAndDropHarness.cs:            Debug.Log("Drag-and-drop test initialized.");
./Debug/DragAndDropHarness.cs:        }
./Debug/DragAndDropHarness.cs:    }
./Debug/DragAndDropHarness.cs:}
--
./Debug/DragAndDropHarness.cs.meta:fileFormatVersion: 2
./Debug/DragAndDropHarness.cs.meta:guid: 72f0e468b85d07143887bfe61c12c586
--
./Debug/FlagDisplayDebugger.cs:using UnityEngine;
./Debug/FlagDisplayDebugger.cs:using UnityEngine.UI;
./Debug/FlagDisplayDebugger.cs:
./Debug/FlagDisplayDebugger.cs:namespace Debug
./Debug/FlagDisplayDebugger.cs:{
./Debug/FlagDisplayDebugger.cs:    public class FlagDisplayDebugger : MonoBehaviour
./Debug/FlagDisplayDebugger.cs:    {
./Debug/FlagDisplayDebugger.cs:        [SerializeField] private StoryFlags flagSystem;
./Debug/FlagDisplayDebugger.cs:        [SerializeField] private Text debugText;
./Debug/FlagDisplayDebugger.cs:
./Debug/FlagDisplayDebugger.cs:        private void Update()
./Debug/FlagDisplayDebugger.cs:        {
./Debug/FlagDisplayDebugger.cs:            string output = "Story Flags:\n";
./Debug/FlagDisplayDebugger.cs:            foreach (var kvp in flagSystem.flags)
./Debug/FlagDisplayDebugger.cs:                output += $"{kvp.Key}: {kvp.Value}\n";
./Debug/FlagDisplayDebugger.cs:
./Debug/FlagDisplayDebugger.cs:            debugText.text = output;
./Debug/FlagDisplayDebugger.cs:        }
./Debug/FlagDisplayDebugger.cs:    }
./Debug/FlagDisplayDebugger.cs:}
--
./Debug/FlagDisplayDebugger.cs.meta:fileFormatVersion: 2
./Debug/FlagDisplayDebugger.cs.meta:guid: d0703509c90304d459a576e40ec8511e
--
./Debug/ItemGridDebugger.cs:using UnityEngine;
./Debug/ItemGridDebugger.cs:
./Debug/ItemGridDebugger.cs:namespace Debug
./Debug/ItemGridDebugger.cs:{
./Debug/ItemGridDebugger.cs:    /// <summary>
./Debug/ItemGridDebugger.cs:    /// Utility for clearing and inspecting inventory slot grids during runtime or debugging.
./Debug/ItemGridDebugger.cs:    /// </summary>
./Debug/ItemGridDebugger.cs:    public class ItemGridDebugger : MonoBehaviour
./Debug/ItemGridDebugger.cs:    {
./Debug/ItemGridDebugger.cs:        [Header("Item Grid Debug")]
./Debug/ItemGridDebugger.cs:        public Transform slotParent;
./Debug/ItemGridDebugger.cs:        public bool autoClearOnStart = true;
./Debug/ItemGridDebugger.cs:
./Debug/ItemGridDebugger.cs:        private const string logTag = "[ItemGridDebugger]";
./Debug/ItemGridDebugger.cs:
./Debug/ItemGridDebugger.cs:        private void Start()
./Debug/ItemGridDebugger.cs:        {
./Debug/ItemGridDebugger.cs:            if (autoClearOnStart)
./Debug/ItemGridDebugger.cs:            {
./Debug/ItemGridDebugger.cs:                ClearGrid();
./Debug/ItemGridDebugger.cs:                UnityEngine.Debug.Log($"{logTag} Cleared existing slots under '{(slotParent != null ? slotParent.name : "null")}' on Start.");
./Debug/ItemGridDebugger.cs:            }
./Debug/ItemGridDebugger.cs:        }
./Debug/ItemGridDebugger.cs:
./Debug/ItemGridDebugger.cs:        /// <summary>
./Debug/ItemGridDebugger.cs:        /// Clears all child slot GameObjects under the slot parent.
./Debug/ItemGridDebugger.cs:        /// </summary>
./Debug/ItemGridDebugger.cs:        [ContextMenu("Clear Grid")]
./Debug/ItemGridDebugger.cs:        public void ClearGrid()
./Debug/ItemGridDebugger.cs:        {
./Debug/ItemGridDebugger.cs:            if (slotParent == null)
./Debug/ItemGridDebugger.cs:            {
./Debug/ItemGridDebugger.cs:                UnityEngine.Debug.LogWarning($"{logTag} Slot parent not assigned.");
./Debug/ItemGridDebugger.cs:                return;
./Debug/ItemGridDebugger.cs:            }
./Debug/ItemGridDebugger.cs:
./Debug/ItemGridDebugger.cs:            int removed = 0;
./Debug/ItemGridDebugger.cs:            foreach (Transform child in slotParent)
./Debug/ItemGridDebugger.cs:            {
./Debug/ItemGridDebugger.cs:                DestroyImmediate(child.gameObject);
./Debug/ItemGridDebugger.cs:                removed++;
./Debug/ItemGridDebugger.cs:            }
./Debug/ItemGridDebugger.cs:
./Debug/ItemGridDebugger.cs:            UnityEngine.Debug.Log($"{logTag} Removed {removed} slots from '{slotParent.name}'.");
./Debug/ItemGridDebugger.cs:        }
./Debug/ItemGridDebugger.cs:
./Debug/ItemGridDebugger.cs:        /// <summary>
./Debug/ItemGridDebugger.cs:        /// Logs all child GameObjects under the slot parent.
./Debug/ItemGridDebugger.cs:        /// </summary>
./Debug/ItemGridDebugger.cs:        [ContextMenu("Log Slot Children")]
./Debug/ItemGridDebugger.cs:        public void LogSlotChildren()
./Debug/ItemGridDebugger.cs:        {
./Debug/ItemGridDebugger.cs:            if (slotParent == null)
./Debug/ItemGridDebugger.cs:            {
./Debug/ItemGridDebugger.cs:                UnityEngine.Debug.LogWarning($"{logTag} Slot parent not assigned.");
./Debug/ItemGridDebugger.cs:                return;
./Debug/ItemGridDebugger.cs:            }
./Debug/ItemGridDebugger.cs:
./Debug/ItemGridDebugger.cs:            UnityEngine.Debug.Log($"{logTag} SlotParent '{slotParent.name}' has {slotParent.childCount} children:");
./Debug/ItemGridDebugger.cs:            for (int i = 0; i < slotParent.childCount; i++)
./Debug/ItemGridDebugger.cs:            {
./Debug/ItemGridDebugger.cs:                UnityEngine.Debug.Log($"  - [{i}] {slotParent.GetChild(i).name}");
./Debug/ItemGridDebugger.cs:            }
./Debug/ItemGridDebugger.cs:        }
./Debug/ItemGridDebugger.cs:    }
./Debug/ItemGridDebugger.cs:}
--
./Debug/ItemGridDebugger.cs.meta:fileFormatVersion: 2
./Debug/ItemGridDebugger.cs.meta:guid: d5b0d79f1c883914f8cc008d3307cb23
--
./Debug.meta:fileFormatVersion: 2
./Debug.meta:guid: 674c37257a3a3364089dfe37467662c9
./Debug.meta:folderAsset: yes
./Debug.meta:DefaultImporter:
./Debug.meta:  externalObjects: {}
./Debug.meta:  userData: 
./Debug.meta:  assetBundleName: 
./Debug.meta:  assetBundleVariant: 
--
./DevTools/DevTools.asmdef:{
./DevTools/DevTools.asmdef:  "name": "DevTools",
./DevTools/DevTools.asmdef:  "references": [
./DevTools/DevTools.asmdef:    "Flags",
./DevTools/DevTools.asmdef:    "Narrative",
./DevTools/DevTools.asmdef:    "Systems"
./DevTools/DevTools.asmdef:  ],
./DevTools/DevTools.asmdef:  "includePlatforms": [],
./DevTools/DevTools.asmdef:  "excludePlatforms": [],
./DevTools/DevTools.asmdef:  "allowUnsafeCode": false,
./DevTools/DevTools.asmdef:  "overrideReferences": false,
./DevTools/DevTools.asmdef:  "precompiledReferences": [],
./DevTools/DevTools.asmdef:  "autoReferenced": true,
./DevTools/DevTools.asmdef:  "defineConstraints": [],
./DevTools/DevTools.asmdef:  "versionDefines": [],
./DevTools/DevTools.asmdef:  "noEngineReferences": false
./DevTools/DevTools.asmdef:}
--
./DevTools/DevTools.asmdef.meta:fileFormatVersion: 2
./DevTools/DevTools.asmdef.meta:guid: 4fed5bdbfbd70b04ea84d67cfddfa247
./DevTools/DevTools.asmdef.meta:AssemblyDefinitionImporter:
./DevTools/DevTools.asmdef.meta:  externalObjects: {}
./DevTools/DevTools.asmdef.meta:  userData: 
./DevTools/DevTools.asmdef.meta:  assetBundleName: 
./DevTools/DevTools.asmdef.meta:  assetBundleVariant: 
--
./DevTools/FlagAutoGenerator.cs:using UnityEngine;
./DevTools/FlagAutoGenerator.cs:using UnityEditor;
./DevTools/FlagAutoGenerator.cs:using System.IO;
./DevTools/FlagAutoGenerator.cs:
./DevTools/FlagAutoGenerator.cs:namespace DevTools
./DevTools/FlagAutoGenerator.cs:{
./DevTools/FlagAutoGenerator.cs:#if UNITY_EDITOR
./DevTools/FlagAutoGenerator.cs:    public class FlagAutoGenerator : EditorWindow
./DevTools/FlagAutoGenerator.cs:    {
./DevTools/FlagAutoGenerator.cs:        private string flagAssetName = "StoryFlags";
./DevTools/FlagAutoGenerator.cs:        private string[] rawFlags;
./DevTools/FlagAutoGenerator.cs:
./DevTools/FlagAutoGenerator.cs:        [MenuItem("Tools/Flag Auto Generator")]
./DevTools/FlagAutoGenerator.cs:        public static void ShowWindow()
./DevTools/FlagAutoGenerator.cs:        {
./DevTools/FlagAutoGenerator.cs:            GetWindow<FlagAutoGenerator>("Flag Auto Generator");
./DevTools/FlagAutoGenerator.cs:        }
./DevTools/FlagAutoGenerator.cs:
./DevTools/FlagAutoGenerator.cs:        private void OnGUI()
./DevTools/FlagAutoGenerator.cs:        {
./DevTools/FlagAutoGenerator.cs:            GUILayout.Label("Generate StoryFlags from Raw List", EditorStyles.boldLabel);
./DevTools/FlagAutoGenerator.cs:            flagAssetName = EditorGUILayout.TextField("Asset Name", flagAssetName);
./DevTools/FlagAutoGenerator.cs:
./DevTools/FlagAutoGenerator.cs:            if (GUILayout.Button("Scan Dialogue Folder"))
./DevTools/FlagAutoGenerator.cs:            {
./DevTools/FlagAutoGenerator.cs:                string[] guids = AssetDatabase.FindAssets("t:TextAsset", new[] { "Assets/Dialogues" });
./DevTools/FlagAutoGenerator.cs:                var allFlags = new System.Collections.Generic.HashSet<string>();
./DevTools/FlagAutoGenerator.cs:
./DevTools/FlagAutoGenerator.cs:                foreach (string guid in guids)
./DevTools/FlagAutoGenerator.cs:                {
./DevTools/FlagAutoGenerator.cs:                    string path = AssetDatabase.GUIDToAssetPath(guid);
./DevTools/FlagAutoGenerator.cs:                    string content = File.ReadAllText(path);
./DevTools/FlagAutoGenerator.cs:
./DevTools/FlagAutoGenerator.cs:                    foreach (var line in content.Split('\n'))
./DevTools/FlagAutoGenerator.cs:                    {
./DevTools/FlagAutoGenerator.cs:                        if (line.Contains("$")) // crude flag reference check
./DevTools/FlagAutoGenerator.cs:                        {
./DevTools/FlagAutoGenerator.cs:                            string key = line.Trim().Split('$')[1].Split(' ')[0];
./DevTools/FlagAutoGenerator.cs:                            allFlags.Add(key);
./DevTools/FlagAutoGenerator.cs:                        }
./DevTools/FlagAutoGenerator.cs:                    }
./DevTools/FlagAutoGenerator.cs:                }
./DevTools/FlagAutoGenerator.cs:
./DevTools/FlagAutoGenerator.cs:                var flagAsset = CreateInstance<StoryFlags>();
./DevTools/FlagAutoGenerator.cs:                foreach (var flag in allFlags)
./DevTools/FlagAutoGenerator.cs:                    flagAsset.SetFlag(flag, false);
./DevTools/FlagAutoGenerator.cs:
./DevTools/FlagAutoGenerator.cs:                AssetDatabase.CreateAsset(flagAsset, $"Assets/Flags/{flagAssetName}.asset");
./DevTools/FlagAutoGenerator.cs:                AssetDatabase.SaveAssets();
./DevTools/FlagAutoGenerator.cs:                UnityEngine.Debug.Log($"[FlagAutoGenerator] Created StoryFlags asset with {allFlags.Count} flags.");
./DevTools/FlagAutoGenerator.cs:            }
./DevTools/FlagAutoGenerator.cs:        }
./DevTools/FlagAutoGenerator.cs:    }
./DevTools/FlagAutoGenerator.cs:#endif
./DevTools/FlagAutoGenerator.cs:}
--
./DevTools/FlagAutoGenerator.cs.meta:fileFormatVersion: 2
./DevTools/FlagAutoGenerator.cs.meta:guid: 9a2e7eda673cf364288d930a60974862
--
./DevTools/FlagPresetLoader.cs:using UnityEngine;
./DevTools/FlagPresetLoader.cs:
./DevTools/FlagPresetLoader.cs:namespace DevTools
./DevTools/FlagPresetLoader.cs:{
./DevTools/FlagPresetLoader.cs:    [System.Serializable]
./DevTools/FlagPresetLoader.cs:    public struct FlagPreset
./DevTools/FlagPresetLoader.cs:    {
./DevTools/FlagPresetLoader.cs:        public string name;
./DevTools/FlagPresetLoader.cs:        public bool value;
./DevTools/FlagPresetLoader.cs:    }
./DevTools/FlagPresetLoader.cs:
./DevTools/FlagPresetLoader.cs:    public class FlagPresetLoader : MonoBehaviour
./DevTools/FlagPresetLoader.cs:    {
./DevTools/FlagPresetLoader.cs:        [SerializeField] private StoryFlags flagSystem;
./DevTools/FlagPresetLoader.cs:        [SerializeField] private FlagPreset[] presets;
./DevTools/FlagPresetLoader.cs:
./DevTools/FlagPresetLoader.cs:        public void ApplyPresets()
./DevTools/FlagPresetLoader.cs:        {
./DevTools/FlagPresetLoader.cs:            foreach (var p in presets)
./DevTools/FlagPresetLoader.cs:                flagSystem.SetFlag(p.name, p.value);
./DevTools/FlagPresetLoader.cs:        }
./DevTools/FlagPresetLoader.cs:    }
./DevTools/FlagPresetLoader.cs:}
--
./DevTools/FlagPresetLoader.cs.meta:fileFormatVersion: 2
./DevTools/FlagPresetLoader.cs.meta:guid: 889512b01b8bdfc49974e31ead1d1782
--
./DevTools/FlagUsageAudit.cs:using UnityEngine;
./DevTools/FlagUsageAudit.cs:using System.Linq;
./DevTools/FlagUsageAudit.cs:
./DevTools/FlagUsageAudit.cs:namespace DevTools
./DevTools/FlagUsageAudit.cs:{
./DevTools/FlagUsageAudit.cs:    public class FlagUsageAudit : MonoBehaviour
./DevTools/FlagUsageAudit.cs:    {
./DevTools/FlagUsageAudit.cs:        [SerializeField] private StoryFlags flagSystem;
./DevTools/FlagUsageAudit.cs:        [SerializeField] private TextAsset[] dialogueAssets;
./DevTools/FlagUsageAudit.cs:
./DevTools/FlagUsageAudit.cs:        private void Start()
./DevTools/FlagUsageAudit.cs:        {
./DevTools/FlagUsageAudit.cs:            foreach (var asset in dialogueAssets)
./DevTools/FlagUsageAudit.cs:            {
./DevTools/FlagUsageAudit.cs:                var text = asset.text;
./DevTools/FlagUsageAudit.cs:                foreach (var key in flagSystem.flags.Keys)
./DevTools/FlagUsageAudit.cs:                {
./DevTools/FlagUsageAudit.cs:                    if (!text.Contains(key))
./DevTools/FlagUsageAudit.cs:                        UnityEngine.Debug.Log($"[Audit] Flag '{key}' not referenced in {asset.name}");
./DevTools/FlagUsageAudit.cs:                }
./DevTools/FlagUsageAudit.cs:            }
./DevTools/FlagUsageAudit.cs:        }
./DevTools/FlagUsageAudit.cs:    }
./DevTools/FlagUsageAudit.cs:}
--
./DevTools/FlagUsageAudit.cs.meta:fileFormatVersion: 2
./DevTools/FlagUsageAudit.cs.meta:guid: a0981c48bca452a4387a8c2a444330ff
--
./DevTools/MeshAuditTool.cs:﻿using UnityEngine;
./DevTools/MeshAuditTool.cs:
./DevTools/MeshAuditTool.cs:public class MeshAuditTool : MonoBehaviour
./DevTools/MeshAuditTool.cs:{
./DevTools/MeshAuditTool.cs:    [Header("Target Mesh")]
./DevTools/MeshAuditTool.cs:    public SkinnedMeshRenderer targetMesh;
./DevTools/MeshAuditTool.cs:
./DevTools/MeshAuditTool.cs:    void Start()
./DevTools/MeshAuditTool.cs:    {
./DevTools/MeshAuditTool.cs:        if (targetMesh == null)
./DevTools/MeshAuditTool.cs:        {
./DevTools/MeshAuditTool.cs:            Debug.LogWarning("MeshAuditTool: No target mesh assigned.");
./DevTools/MeshAuditTool.cs:            return;
./DevTools/MeshAuditTool.cs:        }
./DevTools/MeshAuditTool.cs:
./DevTools/MeshAuditTool.cs:        Debug.Log($"🧪 Mesh Audit: {targetMesh.name}");
./DevTools/MeshAuditTool.cs:
./DevTools/MeshAuditTool.cs:        // Audit blend shapes
./DevTools/MeshAuditTool.cs:        int blendShapeCount = targetMesh.sharedMesh.blendShapeCount;
./DevTools/MeshAuditTool.cs:        for (int i = 0; i < blendShapeCount; i++)
./DevTools/MeshAuditTool.cs:        {
./DevTools/MeshAuditTool.cs:            string shapeName = targetMesh.sharedMesh.GetBlendShapeName(i);
./DevTools/MeshAuditTool.cs:            float weight = targetMesh.GetBlendShapeWeight(i);
./DevTools/MeshAuditTool.cs:            Debug.Log($"Blend Shape [{i}]: {shapeName} = {weight}");
./DevTools/MeshAuditTool.cs:        }
./DevTools/MeshAuditTool.cs:
./DevTools/MeshAuditTool.cs:        // Audit bone bindings
./DevTools/MeshAuditTool.cs:        Transform[] bones = targetMesh.bones;
./DevTools/MeshAuditTool.cs:        Debug.Log($"Bone Count: {bones.Length}");
./DevTools/MeshAuditTool.cs:        foreach (Transform bone in bones)
./DevTools/MeshAuditTool.cs:        {
./DevTools/MeshAuditTool.cs:            if (bone == null)
./DevTools/MeshAuditTool.cs:                Debug.LogWarning("⚠️ Missing bone reference.");
./DevTools/MeshAuditTool.cs:            else
./DevTools/MeshAuditTool.cs:                Debug.Log($"Bone: {bone.name}");
./DevTools/MeshAuditTool.cs:        }
./DevTools/MeshAuditTool.cs:
./DevTools/MeshAuditTool.cs:        // Audit root bone
./DevTools/MeshAuditTool.cs:        if (targetMesh.rootBone != null)
./DevTools/MeshAuditTool.cs:            Debug.Log($"Root Bone: {targetMesh.rootBone.name}");
./DevTools/MeshAuditTool.cs:        else
./DevTools/MeshAuditTool.cs:            Debug.LogWarning("⚠️ No root bone assigned.");
./DevTools/MeshAuditTool.cs:    }
./DevTools/MeshAuditTool.cs:}
--
./DevTools/MeshAuditTool.cs.meta:fileFormatVersion: 2
./DevTools/MeshAuditTool.cs.meta:guid: 8565b997af7605f4d90a424dcf10d2fa
--
./DevTools.meta:fileFormatVersion: 2
./DevTools.meta:guid: 72afc69c0f48a0c48bd34d97173d86dd
./DevTools.meta:folderAsset: yes
./DevTools.meta:DefaultImporter:
./DevTools.meta:  externalObjects: {}
./DevTools.meta:  userData: 
./DevTools.meta:  assetBundleName: 
./DevTools.meta:  assetBundleVariant: 
--
./DialogueSystem/DialogueRunner.cs:namespace Dialogue.Yarn {
./DialogueSystem/DialogueRunner.cs:    public class DialogueRunner {
./DialogueSystem/DialogueRunner.cs:        public void StartDialogue(string id) {}
./DialogueSystem/DialogueRunner.cs:    }
./DialogueSystem/DialogueRunner.cs:}
--
./DialogueSystem/DialogueRunner.cs.meta:fileFormatVersion: 2
./DialogueSystem/DialogueRunner.cs.meta:guid: b356f3a5764b56c4bb34a8199af67260
--
./DialogueSystem/DialogueRunner2.cs:using UnityEngine;
./DialogueSystem/DialogueRunner2.cs:
./DialogueSystem/DialogueRunner2.cs:namespace DialogueSystem
./DialogueSystem/DialogueRunner2.cs:{
./DialogueSystem/DialogueRunner2.cs:    public class DialogueRunner : MonoBehaviour
./DialogueSystem/DialogueRunner2.cs:    {
./DialogueSystem/DialogueRunner2.cs:        [SerializeField] private DialogueUI ui;
./DialogueSystem/DialogueRunner2.cs:        [SerializeField] private TextAsset dialogueScript;
./DialogueSystem/DialogueRunner2.cs:
./DialogueSystem/DialogueRunner2.cs:        private string[] lines;
./DialogueSystem/DialogueRunner2.cs:        private int currentLine;
./DialogueSystem/DialogueRunner2.cs:
./DialogueSystem/DialogueRunner2.cs:        private void Start()
./DialogueSystem/DialogueRunner2.cs:        {
./DialogueSystem/DialogueRunner2.cs:            lines = dialogueScript.text.Split('\n');
./DialogueSystem/DialogueRunner2.cs:            currentLine = 0;
./DialogueSystem/DialogueRunner2.cs:            RunNextLine();
./DialogueSystem/DialogueRunner2.cs:        }
./DialogueSystem/DialogueRunner2.cs:
./DialogueSystem/DialogueRunner2.cs:        public void RunNextLine()
./DialogueSystem/DialogueRunner2.cs:        {
./DialogueSystem/DialogueRunner2.cs:            if (currentLine < lines.Length)
./DialogueSystem/DialogueRunner2.cs:            {
./DialogueSystem/DialogueRunner2.cs:                ui.DisplayLine(lines[currentLine]);
./DialogueSystem/DialogueRunner2.cs:                currentLine++;
./DialogueSystem/DialogueRunner2.cs:            }
./DialogueSystem/DialogueRunner2.cs:            else
./DialogueSystem/DialogueRunner2.cs:            {
./DialogueSystem/DialogueRunner2.cs:                ui.HideLine();
./DialogueSystem/DialogueRunner2.cs:            }
./DialogueSystem/DialogueRunner2.cs:        }
./DialogueSystem/DialogueRunner2.cs:
./DialogueSystem/DialogueRunner2.cs:        public void OnContinue()
./DialogueSystem/DialogueRunner2.cs:        {
./DialogueSystem/DialogueRunner2.cs:            RunNextLine();
./DialogueSystem/DialogueRunner2.cs:        }
./DialogueSystem/DialogueRunner2.cs:    }
./DialogueSystem/DialogueRunner2.cs:}
--
./DialogueSystem/DialogueRunner2.cs.meta:fileFormatVersion: 2
./DialogueSystem/DialogueRunner2.cs.meta:guid: e75a2558126e1064484ff37ba63d95a2
--
./DialogueSystem/DialogueSystem.asmdef:{
./DialogueSystem/DialogueSystem.asmdef:  "name": "DialogueSystem",
./DialogueSystem/DialogueSystem.asmdef:  "references": [
./DialogueSystem/DialogueSystem.asmdef:    "Flags",
./DialogueSystem/DialogueSystem.asmdef:    "Core"
./DialogueSystem/DialogueSystem.asmdef:  ],
./DialogueSystem/DialogueSystem.asmdef:  "includePlatforms": [],
./DialogueSystem/DialogueSystem.asmdef:  "excludePlatforms": [],
./DialogueSystem/DialogueSystem.asmdef:  "allowUnsafeCode": false,
./DialogueSystem/DialogueSystem.asmdef:  "overrideReferences": false,
./DialogueSystem/DialogueSystem.asmdef:  "precompiledReferences": [],
./DialogueSystem/DialogueSystem.asmdef:  "autoReferenced": true,
./DialogueSystem/DialogueSystem.asmdef:  "defineConstraints": [],
./DialogueSystem/DialogueSystem.asmdef:  "versionDefines": [],
./DialogueSystem/DialogueSystem.asmdef:  "noEngineReferences": false
./DialogueSystem/DialogueSystem.asmdef:}
--
./DialogueSystem/DialogueSystem.asmdef.meta:fileFormatVersion: 2
./DialogueSystem/DialogueSystem.asmdef.meta:guid: 1bddf088cd858a944a72c18abf3d9ae0
./DialogueSystem/DialogueSystem.asmdef.meta:AssemblyDefinitionImporter:
./DialogueSystem/DialogueSystem.asmdef.meta:  externalObjects: {}
./DialogueSystem/DialogueSystem.asmdef.meta:  userData: 
./DialogueSystem/DialogueSystem.asmdef.meta:  assetBundleName: 
./DialogueSystem/DialogueSystem.asmdef.meta:  assetBundleVariant: 
--
./DialogueSystem/DialogueUI.cs:using UnityEngine;
./DialogueSystem/DialogueUI.cs:using UnityEngine.UI;
./DialogueSystem/DialogueUI.cs:
./DialogueSystem/DialogueUI.cs:namespace DialogueSystem
./DialogueSystem/DialogueUI.cs:{
./DialogueSystem/DialogueUI.cs:    public class DialogueUI : MonoBehaviour
./DialogueSystem/DialogueUI.cs:    {
./DialogueSystem/DialogueUI.cs:        [Header("UI Elements")]
./DialogueSystem/DialogueUI.cs:        [SerializeField] private Text dialogueText;
./DialogueSystem/DialogueUI.cs:        [SerializeField] private Button continueButton;
./DialogueSystem/DialogueUI.cs:
./DialogueSystem/DialogueUI.cs:        public void DisplayLine(string line)
./DialogueSystem/DialogueUI.cs:        {
./DialogueSystem/DialogueUI.cs:            dialogueText.text = line;
./DialogueSystem/DialogueUI.cs:            continueButton.gameObject.SetActive(true);
./DialogueSystem/DialogueUI.cs:        }
./DialogueSystem/DialogueUI.cs:
./DialogueSystem/DialogueUI.cs:        public void HideLine()
./DialogueSystem/DialogueUI.cs:        {
./DialogueSystem/DialogueUI.cs:            dialogueText.text = "";
./DialogueSystem/DialogueUI.cs:            continueButton.gameObject.SetActive(false);
./DialogueSystem/DialogueUI.cs:        }
./DialogueSystem/DialogueUI.cs:    }
./DialogueSystem/DialogueUI.cs:}
--
./DialogueSystem/DialogueUI.cs.meta:fileFormatVersion: 2
./DialogueSystem/DialogueUI.cs.meta:guid: ddcad137278b4a04bbb951e3f03aec46
--
./DialogueSystem/DialogueVariableProxy.cs:using UnityEngine;
./DialogueSystem/DialogueVariableProxy.cs:
./DialogueSystem/DialogueVariableProxy.cs:namespace DialogueSystem
./DialogueSystem/DialogueVariableProxy.cs:{
./DialogueSystem/DialogueVariableProxy.cs:    public class DialogueVariableProxy : MonoBehaviour
./DialogueSystem/DialogueVariableProxy.cs:    {
./DialogueSystem/DialogueVariableProxy.cs:        [SerializeField] private StoryFlags flagSystem;
./DialogueSystem/DialogueVariableProxy.cs:        [SerializeField] private string flagName;
./DialogueSystem/DialogueVariableProxy.cs:
./DialogueSystem/DialogueVariableProxy.cs:        public bool GetValue() => flagSystem.GetFlag(flagName);
./DialogueSystem/DialogueVariableProxy.cs:    }
./DialogueSystem/DialogueVariableProxy.cs:}
--
./DialogueSystem/DialogueVariableProxy.cs.meta:fileFormatVersion: 2
./DialogueSystem/DialogueVariableProxy.cs.meta:guid: 08beb2a4dfae22d44a3a1d5d708d360f
--
./DialogueSystem.meta:fileFormatVersion: 2
./DialogueSystem.meta:guid: 304a816a6b3581348b6a7d9dcf05184f
./DialogueSystem.meta:folderAsset: yes
./DialogueSystem.meta:DefaultImporter:
./DialogueSystem.meta:  externalObjects: {}
./DialogueSystem.meta:  userData: 
./DialogueSystem.meta:  assetBundleName: 
./DialogueSystem.meta:  assetBundleVariant: 
--
./Editor/DiseaseEditorUtility.cs:using UnityEditor;
./Editor/DiseaseEditorUtility.cs:using UnityEngine;
./Editor/DiseaseEditorUtility.cs:
./Editor/DiseaseEditorUtility.cs:namespace Editor.Disease
./Editor/DiseaseEditorUtility.cs:{
./Editor/DiseaseEditorUtility.cs:    public static class DiseaseEditorUtility
./Editor/DiseaseEditorUtility.cs:    {
./Editor/DiseaseEditorUtility.cs:        [MenuItem("Tools/Disease/Validate Registry")]
./Editor/DiseaseEditorUtility.cs:        public static void ValidateRegistry()
./Editor/DiseaseEditorUtility.cs:        {
./Editor/DiseaseEditorUtility.cs:            var allDefs = Resources.LoadAll<Gameplay.Disease.DiseaseDefinition>("DiseaseDefinitions");
./Editor/DiseaseEditorUtility.cs:            foreach (var def in allDefs)
./Editor/DiseaseEditorUtility.cs:            {
./Editor/DiseaseEditorUtility.cs:                if (string.IsNullOrEmpty(def.DiseaseName))
./Editor/DiseaseEditorUtility.cs:                    Debug.LogWarning($"DiseaseDefinition missing name: {def.name}");
./Editor/DiseaseEditorUtility.cs:            }
./Editor/DiseaseEditorUtility.cs:
./Editor/DiseaseEditorUtility.cs:            Debug.Log($"Validated {allDefs.Length} disease definitions.");
./Editor/DiseaseEditorUtility.cs:        }
./Editor/DiseaseEditorUtility.cs:    }
./Editor/DiseaseEditorUtility.cs:}
--
./Editor/DiseaseEditorUtility.cs.meta:fileFormatVersion: 2
./Editor/DiseaseEditorUtility.cs.meta:guid: 2b427b6c2e204fa4a9d4ae6fbacda8d6
--
./Editor/Editor.asmdef:{
./Editor/Editor.asmdef:  "name": "Editor",
./Editor/Editor.asmdef:  "references": [
./Editor/Editor.asmdef:    "Core",
./Editor/Editor.asmdef:    "EditorTools"
./Editor/Editor.asmdef:  ],
./Editor/Editor.asmdef:  "includePlatforms": ["Editor"],
./Editor/Editor.asmdef:  "excludePlatforms": [],
./Editor/Editor.asmdef:  "allowUnsafeCode": false,
./Editor/Editor.asmdef:  "overrideReferences": false,
./Editor/Editor.asmdef:  "precompiledReferences": [],
./Editor/Editor.asmdef:  "autoReferenced": true,
./Editor/Editor.asmdef:  "defineConstraints": [],
./Editor/Editor.asmdef:  "versionDefines": [],
./Editor/Editor.asmdef:  "noEngineReferences": false
./Editor/Editor.asmdef:}
--
./Editor/Editor.asmdef.meta:fileFormatVersion: 2
./Editor/Editor.asmdef.meta:guid: 8e3c6445455cd434fac00f1fc9a604ee
./Editor/Editor.asmdef.meta:AssemblyDefinitionImporter:
./Editor/Editor.asmdef.meta:  externalObjects: {}
./Editor/Editor.asmdef.meta:  userData: 
./Editor/Editor.asmdef.meta:  assetBundleName: 
./Editor/Editor.asmdef.meta:  assetBundleVariant: 
--
./Editor/EditorEnums.cs:namespace Survival.Editor
./Editor/EditorEnums.cs:{
./Editor/EditorEnums.cs:    public enum EditorToolType { Validator, Migrator, Archiver, Cleanup, Profiler }
./Editor/EditorEnums.cs:    public enum ValidationSeverity { Info, Warning, Error, Critical }
./Editor/EditorEnums.cs:    public enum ScriptState { Legacy, Migrating, Stable, Deprecated }
./Editor/EditorEnums.cs:}
--
./Editor/EditorEnums.cs.meta:fileFormatVersion: 2
./Editor/EditorEnums.cs.meta:guid: cc189dc040ad9c1438e599e262140c49
--
./Editor/InventoryUISlotAuditor.cs:﻿using Game.UI;
./Editor/InventoryUISlotAuditor.cs:using UnityEditor;
./Editor/InventoryUISlotAuditor.cs:using UnityEngine;
./Editor/InventoryUISlotAuditor.cs:using UnityEngine.UI;
./Editor/InventoryUISlotAuditor.cs:
./Editor/InventoryUISlotAuditor.cs:public class InventoryUISlotAuditor : EditorWindow
./Editor/InventoryUISlotAuditor.cs:{
./Editor/InventoryUISlotAuditor.cs:    [MenuItem("Tools/Audit/Inventory UI Slot Integrity")]
./Editor/InventoryUISlotAuditor.cs:    public static void ShowWindow()
./Editor/InventoryUISlotAuditor.cs:    {
./Editor/InventoryUISlotAuditor.cs:        GetWindow<InventoryUISlotAuditor>("Inventory UISlot Audit").RunAudit();
./Editor/InventoryUISlotAuditor.cs:    }
./Editor/InventoryUISlotAuditor.cs:
./Editor/InventoryUISlotAuditor.cs:    private void RunAudit()
./Editor/InventoryUISlotAuditor.cs:    {
./Editor/InventoryUISlotAuditor.cs:        string[] guids = AssetDatabase.FindAssets("t:Prefab");
./Editor/InventoryUISlotAuditor.cs:        int missingSlotCount = 0;
./Editor/InventoryUISlotAuditor.cs:
./Editor/InventoryUISlotAuditor.cs:        foreach (string guid in guids)
./Editor/InventoryUISlotAuditor.cs:        {
./Editor/InventoryUISlotAuditor.cs:            string path = AssetDatabase.GUIDToAssetPath(guid);
./Editor/InventoryUISlotAuditor.cs:            GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(path);
./Editor/InventoryUISlotAuditor.cs:
./Editor/InventoryUISlotAuditor.cs:            if (prefab.TryGetComponent(out InventoryUISlot slot))
./Editor/InventoryUISlotAuditor.cs:            {
./Editor/InventoryUISlotAuditor.cs:                bool missing = false;
./Editor/InventoryUISlotAuditor.cs:                if (slot.ItemIcon == null) { Debug.LogWarning($"❌ Missing ItemIcon in {path}"); missing = true; }
./Editor/InventoryUISlotAuditor.cs:                if (slot.UseButton == null) { Debug.LogWarning($"❌ Missing UseButton in {path}"); missing = true; }
./Editor/InventoryUISlotAuditor.cs:                if (slot.DropButton == null) { Debug.LogWarning($"❌ Missing DropButton in {path}"); missing = true; }
./Editor/InventoryUISlotAuditor.cs:
./Editor/InventoryUISlotAuditor.cs:                if (!missing)
./Editor/InventoryUISlotAuditor.cs:                {
./Editor/InventoryUISlotAuditor.cs:                    Debug.Log($"✅ Slot OK: {path}");
./Editor/InventoryUISlotAuditor.cs:                }
./Editor/InventoryUISlotAuditor.cs:                else
./Editor/InventoryUISlotAuditor.cs:                {
./Editor/InventoryUISlotAuditor.cs:                    missingSlotCount++;
./Editor/InventoryUISlotAuditor.cs:                }
./Editor/InventoryUISlotAuditor.cs:            }
./Editor/InventoryUISlotAuditor.cs:        }
./Editor/InventoryUISlotAuditor.cs:
./Editor/InventoryUISlotAuditor.cs:        if (missingSlotCount == 0)
./Editor/InventoryUISlotAuditor.cs:        {
./Editor/InventoryUISlotAuditor.cs:            Debug.Log("🎉 All InventoryUISlot prefabs passed audit.");
./Editor/InventoryUISlotAuditor.cs:        }
./Editor/InventoryUISlotAuditor.cs:        else
./Editor/InventoryUISlotAuditor.cs:        {
./Editor/InventoryUISlotAuditor.cs:            Debug.LogWarning($"⚠️ {missingSlotCount} InventoryUISlot prefabs have missing references.");
./Editor/InventoryUISlotAuditor.cs:        }
./Editor/InventoryUISlotAuditor.cs:    }
./Editor/InventoryUISlotAuditor.cs:}
--
./Editor/InventoryUISlotAuditor.cs.meta:fileFormatVersion: 2
./Editor/InventoryUISlotAuditor.cs.meta:guid: c533783021ae3cb4da2d18913cca98aa
--
./Editor/ItemDatabaseSO.cs:﻿using System.Collections.Generic;
./Editor/ItemDatabaseSO.cs:using UnityEngine;
./Editor/ItemDatabaseSO.cs:
./Editor/ItemDatabaseSO.cs:namespace Game.Inventory
./Editor/ItemDatabaseSO.cs:{
./Editor/ItemDatabaseSO.cs:    [CreateAssetMenu(fileName = "ItemDatabase", menuName = "Game/Item Database")]
./Editor/ItemDatabaseSO.cs:    public class ItemDatabaseSO : ScriptableObject
./Editor/ItemDatabaseSO.cs:    {
./Editor/ItemDatabaseSO.cs:        [Header("📦 Assign all your ItemData assets")]
./Editor/ItemDatabaseSO.cs:        public List<ItemData> allItems = new();
./Editor/ItemDatabaseSO.cs:
./Editor/ItemDatabaseSO.cs:        /// <summary>
./Editor/ItemDatabaseSO.cs:        /// Find item by display name.
./Editor/ItemDatabaseSO.cs:        /// </summary>
./Editor/ItemDatabaseSO.cs:        public ItemData GetByName(string name)
./Editor/ItemDatabaseSO.cs:        {
./Editor/ItemDatabaseSO.cs:            var result = allItems.Find(i => i != null && i.ItemName == name);
./Editor/ItemDatabaseSO.cs:            if (result == null)
./Editor/ItemDatabaseSO.cs:                Debug.LogWarning($"[ItemDatabaseSO] ❌ Item with name '{name}' not found.");
./Editor/ItemDatabaseSO.cs:            return result;
./Editor/ItemDatabaseSO.cs:        }
./Editor/ItemDatabaseSO.cs:
./Editor/ItemDatabaseSO.cs:        /// <summary>
./Editor/ItemDatabaseSO.cs:        /// Find item by unique ID string.
./Editor/ItemDatabaseSO.cs:        /// </summary>
./Editor/ItemDatabaseSO.cs:        public ItemData GetByID(string id)
./Editor/ItemDatabaseSO.cs:        {
./Editor/ItemDatabaseSO.cs:            var result = allItems.Find(i => i != null && i.Id == id);
./Editor/ItemDatabaseSO.cs:            if (result == null)
./Editor/ItemDatabaseSO.cs:                Debug.LogWarning($"[ItemDatabaseSO] ❌ Item with ID '{id}' not found.");
./Editor/ItemDatabaseSO.cs:            return result;
./Editor/ItemDatabaseSO.cs:        }
./Editor/ItemDatabaseSO.cs:
./Editor/ItemDatabaseSO.cs:        /// <summary>
./Editor/ItemDatabaseSO.cs:        /// Check if item name exists in database.
./Editor/ItemDatabaseSO.cs:        /// </summary>
./Editor/ItemDatabaseSO.cs:        public bool Contains(string name)
./Editor/ItemDatabaseSO.cs:        {
./Editor/ItemDatabaseSO.cs:            return allItems.Exists(i => i != null && i.ItemName == name);
./Editor/ItemDatabaseSO.cs:        }
./Editor/ItemDatabaseSO.cs:
./Editor/ItemDatabaseSO.cs:        /// <summary>
./Editor/ItemDatabaseSO.cs:        /// Get items tagged with a specific keyword.
./Editor/ItemDatabaseSO.cs:        /// </summary>
./Editor/ItemDatabaseSO.cs:        public List<ItemData> GetItemsWithTag(string tag)
./Editor/ItemDatabaseSO.cs:        {
./Editor/ItemDatabaseSO.cs:            return allItems.FindAll(i => i != null && i.HasTag(tag));
./Editor/ItemDatabaseSO.cs:        }
./Editor/ItemDatabaseSO.cs:
./Editor/ItemDatabaseSO.cs:        /// <summary>
./Editor/ItemDatabaseSO.cs:        /// Refresh item list (for editor tooling).
./Editor/ItemDatabaseSO.cs:        /// </summary>
./Editor/ItemDatabaseSO.cs:        public void ValidateDatabase()
./Editor/ItemDatabaseSO.cs:        {
./Editor/ItemDatabaseSO.cs:            int nulls = allItems.RemoveAll(i => i == null);
./Editor/ItemDatabaseSO.cs:            Debug.Log($"[ItemDatabaseSO] 🧹 Removed {nulls} null entries. Valid items: {allItems.Count}");
./Editor/ItemDatabaseSO.cs:        }
./Editor/ItemDatabaseSO.cs:
./Editor/ItemDatabaseSO.cs:        /// <summary>
./Editor/ItemDatabaseSO.cs:        /// Print a summary of item types and IDs.
./Editor/ItemDatabaseSO.cs:        /// </summary>
./Editor/ItemDatabaseSO.cs:        public void PrintSummary()
./Editor/ItemDatabaseSO.cs:        {
./Editor/ItemDatabaseSO.cs:            foreach (var item in allItems)
./Editor/ItemDatabaseSO.cs:            {
./Editor/ItemDatabaseSO.cs:                if (item == null) continue;
./Editor/ItemDatabaseSO.cs:                Debug.Log($"📄 {item.ItemName} | ID: {item.Id} | Type: {item.itemType} | Weight: {item.weight}");
./Editor/ItemDatabaseSO.cs:            }
./Editor/ItemDatabaseSO.cs:        }
./Editor/ItemDatabaseSO.cs:    }
./Editor/ItemDatabaseSO.cs:}
--
./Editor/ItemDatabaseSO.cs.meta:fileFormatVersion: 2
./Editor/ItemDatabaseSO.cs.meta:guid: 8ad4d3d77ba56ab40bf75086cb32801c
--
./Editor/MetaTagTracker.cs:// File: Assets/Scripts/Editor/MetaTagTracker.cs
./Editor/MetaTagTracker.cs:using UnityEngine;
./Editor/MetaTagTracker.cs:#if UNITY_EDITOR
./Editor/MetaTagTracker.cs:using UnityEditor;
./Editor/MetaTagTracker.cs:#endif
./Editor/MetaTagTracker.cs:using System.Collections.Generic;
./Editor/MetaTagTracker.cs:
./Editor/MetaTagTracker.cs:namespace Game.DialogueSystem
./Editor/MetaTagTracker.cs:{
./Editor/MetaTagTracker.cs:#if UNITY_EDITOR
./Editor/MetaTagTracker.cs:    [InitializeOnLoad]
./Editor/MetaTagTracker.cs:    public class MetaTagTracker
./Editor/MetaTagTracker.cs:    {
./Editor/MetaTagTracker.cs:        static MetaTagTracker()
./Editor/MetaTagTracker.cs:        {
./Editor/MetaTagTracker.cs:            string[] types = { "NPC", "Interactable", "LoreBit" };
./Editor/MetaTagTracker.cs:            List<string> matches = new();
./Editor/MetaTagTracker.cs:
./Editor/MetaTagTracker.cs:            foreach (var guid in AssetDatabase.FindAssets("t:TextAsset"))
./Editor/MetaTagTracker.cs:            {
./Editor/MetaTagTracker.cs:                var path = AssetDatabase.GUIDToAssetPath(guid);
./Editor/MetaTagTracker.cs:                var content = AssetDatabase.LoadAssetAtPath<TextAsset>(path)?.text;
./Editor/MetaTagTracker.cs:
./Editor/MetaTagTracker.cs:                foreach (var type in types)
./Editor/MetaTagTracker.cs:                {
./Editor/MetaTagTracker.cs:                    if (content != null && content.Contains($"<{type}>"))
./Editor/MetaTagTracker.cs:                        matches.Add($"{type} found in {path}");
./Editor/MetaTagTracker.cs:                }
./Editor/MetaTagTracker.cs:            }
./Editor/MetaTagTracker.cs:
./Editor/MetaTagTracker.cs:            foreach (var line in matches)
./Editor/MetaTagTracker.cs:                Debug.Log($"[MetaTagTracker] {line}");
./Editor/MetaTagTracker.cs:        }
./Editor/MetaTagTracker.cs:    }
./Editor/MetaTagTracker.cs:#endif
./Editor/MetaTagTracker.cs:}
--
./Editor/MetaTagTracker.cs.meta:fileFormatVersion: 2
./Editor/MetaTagTracker.cs.meta:guid: c214f7394710eca45b5c72677ca7c036
--
./Editor/TooltipPreviewEditor.cs:﻿using Survival.UI.Tooltip;
./Editor/TooltipPreviewEditor.cs:using UnityEditor;
./Editor/TooltipPreviewEditor.cs:using UnityEngine;
./Editor/TooltipPreviewEditor.cs:using static UnityEngine.GraphicsBuffer;
./Editor/TooltipPreviewEditor.cs:
./Editor/TooltipPreviewEditor.cs:[CustomEditor(typeof(TooltipTrigger))]
./Editor/TooltipPreviewEditor.cs:public class TooltipPreviewEditor : Editor
./Editor/TooltipPreviewEditor.cs:{
./Editor/TooltipPreviewEditor.cs:    public override void OnInspectorGUI()
./Editor/TooltipPreviewEditor.cs:    {
./Editor/TooltipPreviewEditor.cs:        base.OnInspectorGUI();
./Editor/TooltipPreviewEditor.cs:
./Editor/TooltipPreviewEditor.cs:        TooltipTrigger trigger = (TooltipTrigger)target;
./Editor/TooltipPreviewEditor.cs:        if (trigger.tooltipData != null)
./Editor/TooltipPreviewEditor.cs:        {
./Editor/TooltipPreviewEditor.cs:            EditorGUILayout.Space();
./Editor/TooltipPreviewEditor.cs:            EditorGUILayout.LabelField("🔍 Tooltip Preview", EditorStyles.boldLabel);
./Editor/TooltipPreviewEditor.cs:            EditorGUILayout.HelpBox(trigger.tooltipData.text, MessageType.Info);
./Editor/TooltipPreviewEditor.cs:
./Editor/TooltipPreviewEditor.cs:            if (trigger.tooltipData.icon != null)
./Editor/TooltipPreviewEditor.cs:            {
./Editor/TooltipPreviewEditor.cs:                GUILayout.Label(trigger.tooltipData.icon.texture, GUILayout.Width(64), GUILayout.Height(64));
./Editor/TooltipPreviewEditor.cs:            }
./Editor/TooltipPreviewEditor.cs:        }
./Editor/TooltipPreviewEditor.cs:        else
./Editor/TooltipPreviewEditor.cs:        {
./Editor/TooltipPreviewEditor.cs:            EditorGUILayout.HelpBox("No TooltipData assigned.", MessageType.Warning);
./Editor/TooltipPreviewEditor.cs:        }
./Editor/TooltipPreviewEditor.cs:    }
./Editor/TooltipPreviewEditor.cs:}
--
./Editor/TooltipPreviewEditor.cs.meta:fileFormatVersion: 2
./Editor/TooltipPreviewEditor.cs.meta:guid: a8197c8e0a6fa30468deb676ef38e4e5
--
./Editor.meta:fileFormatVersion: 2
./Editor.meta:guid: 4acd16b979dc9cd47bda9b3d1b370284
./Editor.meta:folderAsset: yes
./Editor.meta:DefaultImporter:
./Editor.meta:  externalObjects: {}
./Editor.meta:  userData: 
./Editor.meta:  assetBundleName: 
./Editor.meta:  assetBundleVariant: 
--
./Environment/CampLoaderData.cs:namespace Environment.Data
./Environment/CampLoaderData.cs:{
./Environment/CampLoaderData.cs:    public static class CampDataLoader
./Environment/CampLoaderData.cs:    {
./Environment/CampLoaderData.cs:        public static void Load(CampData data)
./Environment/CampLoaderData.cs:        {
./Environment/CampLoaderData.cs:            // Placeholder loading logic
./Environment/CampLoaderData.cs:        }
./Environment/CampLoaderData.cs:    }
./Environment/CampLoaderData.cs:}
./Environment/CampLoaderData.cs:namespace Environment.Data
./Environment/CampLoaderData.cs:{
./Environment/CampLoaderData.cs:    public static class CampDataLoader
./Environment/CampLoaderData.cs:    {
./Environment/CampLoaderData.cs:        public static void Load(CampData data)
./Environment/CampLoaderData.cs:        {
./Environment/CampLoaderData.cs:            // TODO: Implement data loading logic for CampData
./Environment/CampLoaderData.cs:        }
./Environment/CampLoaderData.cs:    }
./Environment/CampLoaderData.cs:}
--
./Environment/CampLoaderData.cs.meta:fileFormatVersion: 2
./Environment/CampLoaderData.cs.meta:guid: 60360c7723a891d4c9a775cf1dd1262b
--
./Environment/CampObjectSpawner.cs:using UnityEngine;
./Environment/CampObjectSpawner.cs:
./Environment/CampObjectSpawner.cs:namespace Environment.Spawn
./Environment/CampObjectSpawner.cs:{
./Environment/CampObjectSpawner.cs:    public static class CampObjectSpawner
./Environment/CampObjectSpawner.cs:    {
./Environment/CampObjectSpawner.cs:        public static void Spawn(GameObject[] prefabs, CampData data)
./Environment/CampObjectSpawner.cs:        {
./Environment/CampObjectSpawner.cs:            // TODO: Implement logic to spawn camp objects based on CampData
./Environment/CampObjectSpawner.cs:        }
./Environment/CampObjectSpawner.cs:    }
./Environment/CampObjectSpawner.cs:}
--
./Environment/CampObjectSpawner.cs.meta:fileFormatVersion: 2
./Environment/CampObjectSpawner.cs.meta:guid: c577eaf83c01f074cb500616514fdcc0
--
./Environment/EnviromentHazardFlags.cs:namespace Environment.Flags {
./Environment/EnviromentHazardFlags.cs:    public enum EnvironmentHazardFlags {
./Environment/EnviromentHazardFlags.cs:        None, Fire, Toxic, Flood
./Environment/EnviromentHazardFlags.cs:    }
./Environment/EnviromentHazardFlags.cs:}
--
./Environment/EnviromentHazardFlags.cs.meta:fileFormatVersion: 2
./Environment/EnviromentHazardFlags.cs.meta:guid: 63f03f02bc6805e4e83526b61fa44c37
--
./Environment/Environment.asmdef:{
./Environment/Environment.asmdef:  "name": "Environment",
./Environment/Environment.asmdef:  "references": [
./Environment/Environment.asmdef:    "Flags",
./Environment/Environment.asmdef:    "Inventory"
./Environment/Environment.asmdef:  ],
./Environment/Environment.asmdef:  "includePlatforms": [],
./Environment/Environment.asmdef:  "excludePlatforms": [],
./Environment/Environment.asmdef:  "allowUnsafeCode": false,
./Environment/Environment.asmdef:  "overrideReferences": false,
./Environment/Environment.asmdef:  "precompiledReferences": [],
./Environment/Environment.asmdef:  "autoReferenced": true,
./Environment/Environment.asmdef:  "defineConstraints": [],
./Environment/Environment.asmdef:  "versionDefines": [],
./Environment/Environment.asmdef:  "noEngineReferences": false
./Environment/Environment.asmdef:}
--
./Environment/Environment.asmdef.meta:fileFormatVersion: 2
./Environment/Environment.asmdef.meta:guid: 665ee4766fe1e30478bfae5c15a983e5
./Environment/Environment.asmdef.meta:AssemblyDefinitionImporter:
./Environment/Environment.asmdef.meta:  externalObjects: {}
./Environment/Environment.asmdef.meta:  userData: 
./Environment/Environment.asmdef.meta:  assetBundleName: 
./Environment/Environment.asmdef.meta:  assetBundleVariant: 
--
./Environment/EnvironmentHazardManager.cs:using System.Collections.Generic;
./Environment/EnvironmentHazardManager.cs:using UnityEngine;
./Environment/EnvironmentHazardManager.cs:
./Environment/EnvironmentHazardManager.cs:namespace Environment.Hazards
./Environment/EnvironmentHazardManager.cs:{
./Environment/EnvironmentHazardManager.cs:    public class EnvironmentHazardManager : MonoBehaviour
./Environment/EnvironmentHazardManager.cs:    {
./Environment/EnvironmentHazardManager.cs:        public HashSet<EnvironmentHazardFlags> activeHazards = new();
./Environment/EnvironmentHazardManager.cs:
./Environment/EnvironmentHazardManager.cs:        public void AddHazard(EnvironmentHazardFlags hazard)
./Environment/EnvironmentHazardManager.cs:        {
./Environment/EnvironmentHazardManager.cs:            activeHazards.Add(hazard);
./Environment/EnvironmentHazardManager.cs:            Debug.Log("Hazard detected: " + hazard);
./Environment/EnvironmentHazardManager.cs:        }
./Environment/EnvironmentHazardManager.cs:
./Environment/EnvironmentHazardManager.cs:        public void RemoveHazard(EnvironmentHazardFlags hazard)
./Environment/EnvironmentHazardManager.cs:        {
./Environment/EnvironmentHazardManager.cs:            if (activeHazards.Contains(hazard))
./Environment/EnvironmentHazardManager.cs:            {
./Environment/EnvironmentHazardManager.cs:                activeHazards.Remove(hazard);
./Environment/EnvironmentHazardManager.cs:                Debug.Log("Hazard resolved: " + hazard);
./Environment/EnvironmentHazardManager.cs:            }
./Environment/EnvironmentHazardManager.cs:        }
./Environment/EnvironmentHazardManager.cs:
./Environment/EnvironmentHazardManager.cs:        public bool HasHazard(EnvironmentHazardFlags hazard) => activeHazards.Contains(hazard);
./Environment/EnvironmentHazardManager.cs:    }
./Environment/EnvironmentHazardManager.cs:}
--
./Environment/EnvironmentHazardManager.cs.meta:fileFormatVersion: 2
./Environment/EnvironmentHazardManager.cs.meta:guid: f6a3a98c7f6905d49938d72703d1cd6a
--
./Environment/WeatherSimulator.cs:using UnityEngine;
./Environment/WeatherSimulator.cs:
./Environment/WeatherSimulator.cs:namespace Environment
./Environment/WeatherSimulator.cs:{
./Environment/WeatherSimulator.cs:    public enum WeatherType { Clear, Rain, Fog, Storm }
./Environment/WeatherSimulator.cs:
./Environment/WeatherSimulator.cs:    public class WeatherSimulator : MonoBehaviour
./Environment/WeatherSimulator.cs:    {
./Environment/WeatherSimulator.cs:        [SerializeField] private WeatherType currentWeather;
./Environment/WeatherSimulator.cs:
./Environment/WeatherSimulator.cs:        public void SetWeather(WeatherType type)
./Environment/WeatherSimulator.cs:        {
./Environment/WeatherSimulator.cs:            currentWeather = type;
./Environment/WeatherSimulator.cs:            Debug.Log($"[WeatherSimulator] Weather changed to: {type}");
./Environment/WeatherSimulator.cs:            // Extend: modify ambient text or disease risk
./Environment/WeatherSimulator.cs:        }
./Environment/WeatherSimulator.cs:
./Environment/WeatherSimulator.cs:        public WeatherType GetCurrentWeather() => currentWeather;
./Environment/WeatherSimulator.cs:    }
./Environment/WeatherSimulator.cs:}
--
./Environment/WeatherSimulator.cs.meta:fileFormatVersion: 2
./Environment/WeatherSimulator.cs.meta:guid: 03367765f3a59fb45a9fcee5d9c3dc35
--
./Environment.meta:fileFormatVersion: 2
./Environment.meta:guid: 80057a11bb4acde4fb1c46e414371e70
./Environment.meta:folderAsset: yes
./Environment.meta:DefaultImporter:
./Environment.meta:  externalObjects: {}
./Environment.meta:  userData: 
./Environment.meta:  assetBundleName: 
./Environment.meta:  assetBundleVariant: 
--
./Flags/EnviromentHazardFlags.cs:namespace Flags
./Flags/EnviromentHazardFlags.cs:{
./Flags/EnviromentHazardFlags.cs:    public enum EnvironmentHazardFlags
./Flags/EnviromentHazardFlags.cs:    {
./Flags/EnviromentHazardFlags.cs:        Radiation,
./Flags/EnviromentHazardFlags.cs:        ToxicFog,
./Flags/EnviromentHazardFlags.cs:        CollapsingStructure,
./Flags/EnviromentHazardFlags.cs:        LooseWiring,
./Flags/EnviromentHazardFlags.cs:        DiseasedWater,
./Flags/EnviromentHazardFlags.cs:        EchoField
./Flags/EnviromentHazardFlags.cs:    }
./Flags/EnviromentHazardFlags.cs:}
--
./Flags/EnviromentHazardFlags.cs.meta:fileFormatVersion: 2
./Flags/EnviromentHazardFlags.cs.meta:guid: 772afac63d89e9d49bcd66dcb8205a47
--
./Flags/ExposureFlags.cs:namespace Flags
./Flags/ExposureFlags.cs:{
./Flags/ExposureFlags.cs:    public enum ExposureFlags
./Flags/ExposureFlags.cs:    {
./Flags/ExposureFlags.cs:        ExtremeHeat,
./Flags/ExposureFlags.cs:        FreezingCold,
./Flags/ExposureFlags.cs:        ProlongedDarkness,
./Flags/ExposureFlags.cs:        Overstimulation,
./Flags/ExposureFlags.cs:        Isolation,
./Flags/ExposureFlags.cs:        UnknownRadiance
./Flags/ExposureFlags.cs:    }
./Flags/ExposureFlags.cs:}
--
./Flags/ExposureFlags.cs.meta:fileFormatVersion: 2
./Flags/ExposureFlags.cs.meta:guid: 697c0ef9c124c1140be3e834c80a05fa
--
./Flags/FlagConditionChecker.cs:using UnityEngine;
./Flags/FlagConditionChecker.cs:using UnityEngine.Events;
./Flags/FlagConditionChecker.cs:
./Flags/FlagConditionChecker.cs:namespace Flags
./Flags/FlagConditionChecker.cs:{
./Flags/FlagConditionChecker.cs:    public class FlagConditionChecker : MonoBehaviour
./Flags/FlagConditionChecker.cs:    {
./Flags/FlagConditionChecker.cs:        [SerializeField] private StoryFlags flagSystem;
./Flags/FlagConditionChecker.cs:        [SerializeField] private string flagName;
./Flags/FlagConditionChecker.cs:        [SerializeField] private UnityEvent ifTrue;
./Flags/FlagConditionChecker.cs:        [SerializeField] private UnityEvent ifFalse;
./Flags/FlagConditionChecker.cs:
./Flags/FlagConditionChecker.cs:        public void Evaluate()
./Flags/FlagConditionChecker.cs:        {
./Flags/FlagConditionChecker.cs:            if (flagSystem.GetFlag(flagName))
./Flags/FlagConditionChecker.cs:                ifTrue.Invoke();
./Flags/FlagConditionChecker.cs:            else
./Flags/FlagConditionChecker.cs:                ifFalse.Invoke();
./Flags/FlagConditionChecker.cs:        }
./Flags/FlagConditionChecker.cs:    }
./Flags/FlagConditionChecker.cs:}
--
./Flags/FlagConditionChecker.cs.meta:fileFormatVersion: 2
./Flags/FlagConditionChecker.cs.meta:guid: c09f426743b41274cb4b8d9875d9a7af
--
./Flags/FlagGRoupLoader.cs:using UnityEngine;
./Flags/FlagGRoupLoader.cs:
./Flags/FlagGRoupLoader.cs:namespace Flags
./Flags/FlagGRoupLoader.cs:{
./Flags/FlagGRoupLoader.cs:    [System.Serializable]
./Flags/FlagGRoupLoader.cs:    public class FlagGroup
./Flags/FlagGRoupLoader.cs:    {
./Flags/FlagGRoupLoader.cs:        public string name;
./Flags/FlagGRoupLoader.cs:        public string[] flags;
./Flags/FlagGRoupLoader.cs:    }
./Flags/FlagGRoupLoader.cs:
./Flags/FlagGRoupLoader.cs:    public class FlagGroupLoader : MonoBehaviour
./Flags/FlagGRoupLoader.cs:    {
./Flags/FlagGRoupLoader.cs:        [SerializeField] private StoryFlags flagSystem;
./Flags/FlagGRoupLoader.cs:        [SerializeField] private FlagGroup[] groups;
./Flags/FlagGRoupLoader.cs:
./Flags/FlagGRoupLoader.cs:        public void LoadGroup(string groupName)
./Flags/FlagGRoupLoader.cs:        {
./Flags/FlagGRoupLoader.cs:            foreach (var g in groups)
./Flags/FlagGRoupLoader.cs:            {
./Flags/FlagGRoupLoader.cs:                if (g.name == groupName)
./Flags/FlagGRoupLoader.cs:                {
./Flags/FlagGRoupLoader.cs:                    foreach (var f in g.flags)
./Flags/FlagGRoupLoader.cs:                        flagSystem.SetFlag(f, true);
./Flags/FlagGRoupLoader.cs:                    break;
./Flags/FlagGRoupLoader.cs:                }
./Flags/FlagGRoupLoader.cs:            }
./Flags/FlagGRoupLoader.cs:        }
./Flags/FlagGRoupLoader.cs:    }
./Flags/FlagGRoupLoader.cs:}
--
./Flags/FlagGRoupLoader.cs.meta:fileFormatVersion: 2
./Flags/FlagGRoupLoader.cs.meta:guid: ce6aa6f74a173bf4293444a2ea38eacf
--
./Flags/FlagListener.cs:using UnityEngine;
./Flags/FlagListener.cs:using UnityEngine.Events;
./Flags/FlagListener.cs:
./Flags/FlagListener.cs:namespace Flags
./Flags/FlagListener.cs:{
./Flags/FlagListener.cs:    public class FlagListener : MonoBehaviour
./Flags/FlagListener.cs:    {
./Flags/FlagListener.cs:        [SerializeField] private StoryFlags flagSystem;
./Flags/FlagListener.cs:        [SerializeField] private string flagName;
./Flags/FlagListener.cs:        [SerializeField] private UnityEvent onTrue;
./Flags/FlagListener.cs:
./Flags/FlagListener.cs:        private void Start()
./Flags/FlagListener.cs:        {
./Flags/FlagListener.cs:            if (flagSystem.GetFlag(flagName))
./Flags/FlagListener.cs:                onTrue.Invoke();
./Flags/FlagListener.cs:        }
./Flags/FlagListener.cs:    }
./Flags/FlagListener.cs:}
--
./Flags/FlagListener.cs.meta:fileFormatVersion: 2
./Flags/FlagListener.cs.meta:guid: 8f50881a4ae5afa49bc0209c9727ef24
--
./Flags/Flags.asmdef:{
./Flags/Flags.asmdef:  "name": "Flags",
./Flags/Flags.asmdef:  "references": [],
./Flags/Flags.asmdef:  "includePlatforms": [],
./Flags/Flags.asmdef:  "excludePlatforms": [],
./Flags/Flags.asmdef:  "allowUnsafeCode": false,
./Flags/Flags.asmdef:  "overrideReferences": false,
./Flags/Flags.asmdef:  "precompiledReferences": [],
./Flags/Flags.asmdef:  "autoReferenced": true,
./Flags/Flags.asmdef:  "defineConstraints": [],
./Flags/Flags.asmdef:  "versionDefines": [],
./Flags/Flags.asmdef:  "noEngineReferences": false
./Flags/Flags.asmdef:}
--
./Flags/Flags.asmdef.meta:fileFormatVersion: 2
./Flags/Flags.asmdef.meta:guid: fc9f928acd5a6e14ea202310386f3869
./Flags/Flags.asmdef.meta:AssemblyDefinitionImporter:
./Flags/Flags.asmdef.meta:  externalObjects: {}
./Flags/Flags.asmdef.meta:  userData: 
./Flags/Flags.asmdef.meta:  assetBundleName: 
./Flags/Flags.asmdef.meta:  assetBundleVariant: 
--
./Flags/FlagSetter.cs:using UnityEngine;
./Flags/FlagSetter.cs:
./Flags/FlagSetter.cs:namespace Flags
./Flags/FlagSetter.cs:{
./Flags/FlagSetter.cs:    public class FlagSetter : MonoBehaviour
./Flags/FlagSetter.cs:    {
./Flags/FlagSetter.cs:        [SerializeField] private StoryFlags flagSystem;
./Flags/FlagSetter.cs:        [SerializeField] private string flagName;
./Flags/FlagSetter.cs:        [SerializeField] private bool value;
./Flags/FlagSetter.cs:
./Flags/FlagSetter.cs:        public void TriggerFlagChange() => flagSystem.SetFlag(flagName, value);
./Flags/FlagSetter.cs:    }
./Flags/FlagSetter.cs:}
--
./Flags/FlagSetter.cs.meta:fileFormatVersion: 2
./Flags/FlagSetter.cs.meta:guid: ae6db356c63f5e94ebd27545c8a29392
--
./Flags/GameStateFlags.cs:namespace Flags
./Flags/GameStateFlags.cs:{
./Flags/GameStateFlags.cs:    [System.Serializable]
./Flags/GameStateFlags.cs:    public class GameStateFlags
./Flags/GameStateFlags.cs:    {
./Flags/GameStateFlags.cs:        public bool isPaused;
./Flags/GameStateFlags.cs:        public bool isInCombat;
./Flags/GameStateFlags.cs:        public bool isGameOver;
./Flags/GameStateFlags.cs:    }
./Flags/GameStateFlags.cs:}
--
./Flags/GameStateFlags.cs.meta:fileFormatVersion: 2
./Flags/GameStateFlags.cs.meta:guid: 5c4e5b888e5faaa4a971862f38c093b7
--
./Flags/InfectionFlags.cs:namespace Flags
./Flags/InfectionFlags.cs:{
./Flags/InfectionFlags.cs:    public enum InfectionFlags
./Flags/InfectionFlags.cs:    {
./Flags/InfectionFlags.cs:        Rabid,
./Flags/InfectionFlags.cs:        FungalGrowth,
./Flags/InfectionFlags.cs:        NeuralDecay,
./Flags/InfectionFlags.cs:        AcidBlood,
./Flags/InfectionFlags.cs:        BlackVein,
./Flags/InfectionFlags.cs:        VoiceEcho
./Flags/InfectionFlags.cs:    }
./Flags/InfectionFlags.cs:}
--
./Flags/InfectionFlags.cs.meta:fileFormatVersion: 2
./Flags/InfectionFlags.cs.meta:guid: b0e99fe7a22f99d42bdb88dfd44bdb51
--
./Flags/InteractionTags.cs:namespace Flags
./Flags/InteractionTags.cs:{
./Flags/InteractionTags.cs:    public enum InteractionTags
./Flags/InteractionTags.cs:    {
./Flags/InteractionTags.cs:        Searchable,
./Flags/InteractionTags.cs:        Lootable,
./Flags/InteractionTags.cs:        Locked,
./Flags/InteractionTags.cs:        RequiresTool,
./Flags/InteractionTags.cs:        Hazardous,
./Flags/InteractionTags.cs:        OneTimeUse
./Flags/InteractionTags.cs:    }
./Flags/InteractionTags.cs:}
--
./Flags/InteractionTags.cs.meta:fileFormatVersion: 2
./Flags/InteractionTags.cs.meta:guid: 8e32173ac3c363d4684a57f46dfb257b
--
./Flags/PlayerConditionFlags.cs:namespace Flags
./Flags/PlayerConditionFlags.cs:{
./Flags/PlayerConditionFlags.cs:    /// <summary>
./Flags/PlayerConditionFlags.cs:    /// Bitwise flags representing player conditions. Supports multi-status tracking.
./Flags/PlayerConditionFlags.cs:    /// </summary>
./Flags/PlayerConditionFlags.cs:    [System.Flags]
./Flags/PlayerConditionFlags.cs:    public enum PlayerConditionFlags
./Flags/PlayerConditionFlags.cs:    {
./Flags/PlayerConditionFlags.cs:        None = 0,
./Flags/PlayerConditionFlags.cs:        Injured = 1 << 0,
./Flags/PlayerConditionFlags.cs:        Starving = 1 << 1,
./Flags/PlayerConditionFlags.cs:        Overencumbered = 1 << 2,
./Flags/PlayerConditionFlags.cs:        Exhausted = 1 << 3,
./Flags/PlayerConditionFlags.cs:        Sick = 1 << 4,
./Flags/PlayerConditionFlags.cs:        Dehydrated = 1 << 5,
./Flags/PlayerConditionFlags.cs:        Cold = 1 << 6,
./Flags/PlayerConditionFlags.cs:        Hot = 1 << 7,
./Flags/PlayerConditionFlags.cs:        Poisoned = 1 << 8
./Flags/PlayerConditionFlags.cs:        // Add more as needed
./Flags/PlayerConditionFlags.cs:    }
./Flags/PlayerConditionFlags.cs:}
--
./Flags/PlayerConditionFlags.cs.meta:fileFormatVersion: 2
./Flags/PlayerConditionFlags.cs.meta:guid: b0cded822470ba6448b7e07d08d625b5
--
./Flags/PlayerDeathFlags.cs:namespace Flags
./Flags/PlayerDeathFlags.cs:{
./Flags/PlayerDeathFlags.cs:    public enum PlayerDeathFlags
./Flags/PlayerDeathFlags.cs:    {
./Flags/PlayerDeathFlags.cs:        HeartFailure,
./Flags/PlayerDeathFlags.cs:        BloodLoss,
./Flags/PlayerDeathFlags.cs:        HeadTrauma,
./Flags/PlayerDeathFlags.cs:        Suffocation,
./Flags/PlayerDeathFlags.cs:        OrganFailure,
./Flags/PlayerDeathFlags.cs:        PsychologicalCollapse
./Flags/PlayerDeathFlags.cs:    }
./Flags/PlayerDeathFlags.cs:}
--
./Flags/PlayerDeathFlags.cs.meta:fileFormatVersion: 2
./Flags/PlayerDeathFlags.cs.meta:guid: 81a052cf76fe48a409d9ef35a8d5cc7b
--
./Flags/SanityFlags.cs:namespace Flags
./Flags/SanityFlags.cs:{
./Flags/SanityFlags.cs:    public enum SanityFlags
./Flags/SanityFlags.cs:    {
./Flags/SanityFlags.cs:        HearingVoices,
./Flags/SanityFlags.cs:        VisualDistortions,
./Flags/SanityFlags.cs:        DetachedReality,
./Flags/SanityFlags.cs:        TimeLoss,
./Flags/SanityFlags.cs:        UnknownFear,
./Flags/SanityFlags.cs:        ObjectPersonification
./Flags/SanityFlags.cs:    }
./Flags/SanityFlags.cs:}
--
./Flags/SanityFlags.cs.meta:fileFormatVersion: 2
./Flags/SanityFlags.cs.meta:guid: 2ee098d7af7c1f24185fdae49a6c85e0
--
./Flags/StoryFlags.cs:using UnityEngine;
./Flags/StoryFlags.cs:using System.Collections.Generic;
./Flags/StoryFlags.cs:
./Flags/StoryFlags.cs:namespace Flags
./Flags/StoryFlags.cs:{
./Flags/StoryFlags.cs:    [CreateAssetMenu(fileName = "StoryFlags", menuName = "Game/StoryFlags")]
./Flags/StoryFlags.cs:    public class StoryFlags : ScriptableObject
./Flags/StoryFlags.cs:    {
./Flags/StoryFlags.cs:        public Dictionary<string, bool> flags = new();
./Flags/StoryFlags.cs:
./Flags/StoryFlags.cs:        public bool GetFlag(string key) => flags.ContainsKey(key) && flags[key];
./Flags/StoryFlags.cs:
./Flags/StoryFlags.cs:        public void SetFlag(string key, bool value) => flags[key] = value;
./Flags/StoryFlags.cs:    }
./Flags/StoryFlags.cs:}
--
./Flags/StoryFlags.cs.meta:fileFormatVersion: 2
./Flags/StoryFlags.cs.meta:guid: 3a80a805dd33d7c4aadec2e41e8bab39
--
./Flags.meta:fileFormatVersion: 2
./Flags.meta:guid: 9443ce6f4c449cc46aad651d0584b1f4
./Flags.meta:folderAsset: yes
./Flags.meta:DefaultImporter:
./Flags.meta:  externalObjects: {}
./Flags.meta:  userData: 
./Flags.meta:  assetBundleName: 
./Flags.meta:  assetBundleVariant: 
--
./Interaction/InteractableObject.cs:using UnityEngine;
./Interaction/InteractableObject.cs:using UnityEngine.Events;
./Interaction/InteractableObject.cs:
./Interaction/InteractableObject.cs:namespace Game.Interaction
./Interaction/InteractableObject.cs:{
./Interaction/InteractableObject.cs:    public class InteractableObject : MonoBehaviour
./Interaction/InteractableObject.cs:    {
./Interaction/InteractableObject.cs:        [Header("Interaction Metadata")]
./Interaction/InteractableObject.cs:        [SerializeField] private string interactionPrompt = "Examine";
./Interaction/InteractableObject.cs:        [SerializeField] private InteractionTags[] interactionTags;
./Interaction/InteractableObject.cs:
./Interaction/InteractableObject.cs:        [Header("Interaction Events")]
./Interaction/InteractableObject.cs:        [SerializeField] private UnityEvent onInteract;
./Interaction/InteractableObject.cs:
./Interaction/InteractableObject.cs:        public string GetPrompt() => interactionPrompt;
./Interaction/InteractableObject.cs:
./Interaction/InteractableObject.cs:        public bool HasTag(InteractionTags tag)
./Interaction/InteractableObject.cs:        {
./Interaction/InteractableObject.cs:            foreach (var t in interactionTags)
./Interaction/InteractableObject.cs:                if (t == tag) return true;
./Interaction/InteractableObject.cs:
./Interaction/InteractableObject.cs:            return false;
./Interaction/InteractableObject.cs:        }
./Interaction/InteractableObject.cs:
./Interaction/InteractableObject.cs:        public void Interact()
./Interaction/InteractableObject.cs:        {
./Interaction/InteractableObject.cs:            Debug.Log($"[InteractableObject] Player interacted: {interactionPrompt}");
./Interaction/InteractableObject.cs:            onInteract.Invoke();
./Interaction/InteractableObject.cs:        }
./Interaction/InteractableObject.cs:    }
./Interaction/InteractableObject.cs:}
--
./Interaction/InteractableObject.cs.meta:fileFormatVersion: 2
./Interaction/InteractableObject.cs.meta:guid: 0e1e4aa25ca4e54438459bce3da04fb0
--
./Interaction/Interaction.asmdef:{
./Interaction/Interaction.asmdef:  "name": "Interaction",
./Interaction/Interaction.asmdef:  "references": [
./Interaction/Interaction.asmdef:    "Flags",
./Interaction/Interaction.asmdef:    "DialogueSystem"
./Interaction/Interaction.asmdef:  ],
./Interaction/Interaction.asmdef:  "includePlatforms": [],
./Interaction/Interaction.asmdef:  "excludePlatforms": [],
./Interaction/Interaction.asmdef:  "allowUnsafeCode": false,
./Interaction/Interaction.asmdef:  "overrideReferences": false,
./Interaction/Interaction.asmdef:  "precompiledReferences": [],
./Interaction/Interaction.asmdef:  "autoReferenced": true,
./Interaction/Interaction.asmdef:  "defineConstraints": [],
./Interaction/Interaction.asmdef:  "versionDefines": [],
./Interaction/Interaction.asmdef:  "noEngineReferences": false
./Interaction/Interaction.asmdef:}
--
./Interaction/Interaction.asmdef.meta:fileFormatVersion: 2
./Interaction/Interaction.asmdef.meta:guid: 4009769f62fd56646be1a1bd0c1f8198
./Interaction/Interaction.asmdef.meta:AssemblyDefinitionImporter:
./Interaction/Interaction.asmdef.meta:  externalObjects: {}
./Interaction/Interaction.asmdef.meta:  userData: 
./Interaction/Interaction.asmdef.meta:  assetBundleName: 
./Interaction/Interaction.asmdef.meta:  assetBundleVariant: 
--
./Interaction/InteractionTags.cs:namespace Interaction.Core {
./Interaction/InteractionTags.cs:    public enum InteractionTags {
./Interaction/InteractionTags.cs:        Interact, Pickup, Talk
./Interaction/InteractionTags.cs:    }
./Interaction/InteractionTags.cs:}
--
./Interaction/InteractionTags.cs.meta:fileFormatVersion: 2
./Interaction/InteractionTags.cs.meta:guid: 51abd4a0d701d1045878d86ff59419eb
--
./Interaction/YarnTriggerZone.cs:// File: Assets/Scripts/Interaction/YarnTriggerZone.cs
./Interaction/YarnTriggerZone.cs:using UnityEngine;
./Interaction/YarnTriggerZone.cs:
./Interaction/YarnTriggerZone.cs:namespace Game.DialogueSystem
./Interaction/YarnTriggerZone.cs:{
./Interaction/YarnTriggerZone.cs:    public class YarnTriggerZone : MonoBehaviour
./Interaction/YarnTriggerZone.cs:    {
./Interaction/YarnTriggerZone.cs:        [SerializeField] private DialogueRunner runner;
./Interaction/YarnTriggerZone.cs:
./Interaction/YarnTriggerZone.cs:        private void OnTriggerEnter(Collider other)
./Interaction/YarnTriggerZone.cs:        {
./Interaction/YarnTriggerZone.cs:            if (other.CompareTag("Player"))
./Interaction/YarnTriggerZone.cs:                runner.RunNextLine();
./Interaction/YarnTriggerZone.cs:        }
./Interaction/YarnTriggerZone.cs:    }
./Interaction/YarnTriggerZone.cs:}
--
./Interaction/YarnTriggerZone.cs.meta:fileFormatVersion: 2
./Interaction/YarnTriggerZone.cs.meta:guid: cf5663bc7e690a4468add22dfe2462db
--
./Interaction.meta:fileFormatVersion: 2
./Interaction.meta:guid: ad5eaad873e09f148b9731666786000b
./Interaction.meta:folderAsset: yes
./Interaction.meta:DefaultImporter:
./Interaction.meta:  externalObjects: {}
./Interaction.meta:  userData: 
./Interaction.meta:  assetBundleName: 
./Interaction.meta:  assetBundleVariant: 
--
./Inventory/EquipmentManager.cs:// File: Assets/Scripts/Inventory/EquipmentManager.cs
./Inventory/EquipmentManager.cs:using System.Collections.Generic;
./Inventory/EquipmentManager.cs:using UnityEngine;
./Inventory/EquipmentManager.cs:using Game.Inventory;
./Inventory/EquipmentManager.cs:
./Inventory/EquipmentManager.cs:namespace Game.Inventory
./Inventory/EquipmentManager.cs:{
./Inventory/EquipmentManager.cs:    public class EquipmentManager : MonoBehaviour
./Inventory/EquipmentManager.cs:    {
./Inventory/EquipmentManager.cs:        [Header("Equipment Slots")]
./Inventory/EquipmentManager.cs:        public Dictionary<string, InventoryItem> equippedItems = new();
./Inventory/EquipmentManager.cs:
./Inventory/EquipmentManager.cs:        public delegate void EquipmentEvent(InventoryItem item);
./Inventory/EquipmentManager.cs:        public event EquipmentEvent OnEquip;
./Inventory/EquipmentManager.cs:        public event EquipmentEvent OnUnequip;
./Inventory/EquipmentManager.cs:
./Inventory/EquipmentManager.cs:        public void EquipItem(string slotName, InventoryItem item)
./Inventory/EquipmentManager.cs:        {
./Inventory/EquipmentManager.cs:            if (item == null || string.IsNullOrEmpty(slotName)) return;
./Inventory/EquipmentManager.cs:
./Inventory/EquipmentManager.cs:            equippedItems[slotName] = item;
./Inventory/EquipmentManager.cs:            OnEquip?.Invoke(item);
./Inventory/EquipmentManager.cs:            Debug.Log($"Equipped {item.ItemName} to {slotName}");
./Inventory/EquipmentManager.cs:        }
./Inventory/EquipmentManager.cs:
./Inventory/EquipmentManager.cs:        public void UnequipItem(string slotName)
./Inventory/EquipmentManager.cs:        {
./Inventory/EquipmentManager.cs:            if (!equippedItems.ContainsKey(slotName)) return;
./Inventory/EquipmentManager.cs:
./Inventory/EquipmentManager.cs:            var removed = equippedItems[slotName];
./Inventory/EquipmentManager.cs:            equippedItems.Remove(slotName);
./Inventory/EquipmentManager.cs:            OnUnequip?.Invoke(removed);
./Inventory/EquipmentManager.cs:            Debug.Log($"Unequipped {removed.ItemName} from {slotName}");
./Inventory/EquipmentManager.cs:        }
./Inventory/EquipmentManager.cs:
./Inventory/EquipmentManager.cs:        public InventoryItem GetEquippedItem(string slotName)
./Inventory/EquipmentManager.cs:        {
./Inventory/EquipmentManager.cs:            equippedItems.TryGetValue(slotName, out var item);
./Inventory/EquipmentManager.cs:            return item;
./Inventory/EquipmentManager.cs:        }
./Inventory/EquipmentManager.cs:
./Inventory/EquipmentManager.cs:        public bool IsEquipped(string itemName)
./Inventory/EquipmentManager.cs:        {
./Inventory/EquipmentManager.cs:            foreach (var kvp in equippedItems)
./Inventory/EquipmentManager.cs:            {
./Inventory/EquipmentManager.cs:                if (kvp.Value != null && kvp.Value.ItemName == itemName)
./Inventory/EquipmentManager.cs:                    return true;
./Inventory/EquipmentManager.cs:            }
./Inventory/EquipmentManager.cs:            return false;
./Inventory/EquipmentManager.cs:        }
./Inventory/EquipmentManager.cs:
./Inventory/EquipmentManager.cs:        public Dictionary<string, InventoryItem> GetAllEquippedItems() =>
./Inventory/EquipmentManager.cs:            new(equippedItems);
./Inventory/EquipmentManager.cs:    }
./Inventory/EquipmentManager.cs:}
--
./Inventory/EquipmentManager.cs.meta:fileFormatVersion: 2
./Inventory/EquipmentManager.cs.meta:guid: d824ae705da78fd44aa4abaa00e792d5
--
./Inventory/Inventory.asmdef:{
./Inventory/Inventory.asmdef:  "name": "Inventory",
./Inventory/Inventory.asmdef:  "references": [
./Inventory/Inventory.asmdef:    "Flags",
./Inventory/Inventory.asmdef:    "Core"
./Inventory/Inventory.asmdef:  ],
./Inventory/Inventory.asmdef:  "includePlatforms": [],
./Inventory/Inventory.asmdef:  "excludePlatforms": [],
./Inventory/Inventory.asmdef:  "allowUnsafeCode": false,
./Inventory/Inventory.asmdef:  "overrideReferences": false,
./Inventory/Inventory.asmdef:  "precompiledReferences": [],
./Inventory/Inventory.asmdef:  "autoReferenced": true,
./Inventory/Inventory.asmdef:  "defineConstraints": [],
./Inventory/Inventory.asmdef:  "versionDefines": [],
./Inventory/Inventory.asmdef:  "noEngineReferences": false
./Inventory/Inventory.asmdef:}
--
./Inventory/Inventory.asmdef.meta:fileFormatVersion: 2
./Inventory/Inventory.asmdef.meta:guid: 96844f676b6d0554c902cd46ea2d08d5
./Inventory/Inventory.asmdef.meta:AssemblyDefinitionImporter:
./Inventory/Inventory.asmdef.meta:  externalObjects: {}
./Inventory/Inventory.asmdef.meta:  userData: 
./Inventory/Inventory.asmdef.meta:  assetBundleName: 
./Inventory/Inventory.asmdef.meta:  assetBundleVariant: 
--
./Inventory/InventoryManager.cs:﻿// File: Assets/Scripts/Inventory/InventoryManager.cs
./Inventory/InventoryManager.cs:using Game.Inventory;
./Inventory/InventoryManager.cs:using System.Collections.Generic;
./Inventory/InventoryManager.cs:using System.Linq;
./Inventory/InventoryManager.cs:using UnityEngine;
./Inventory/InventoryManager.cs:
./Inventory/InventoryManager.cs:namespace Game.Inventory
./Inventory/InventoryManager.cs:{
./Inventory/InventoryManager.cs:    public class InventoryManager : MonoBehaviour
./Inventory/InventoryManager.cs:    {
./Inventory/InventoryManager.cs:        [SerializeField] private List<StackSlot> inventoryGrid = new();
./Inventory/InventoryManager.cs:
./Inventory/InventoryManager.cs:        public void AddItem(InventoryItem item)
./Inventory/InventoryManager.cs:        {
./Inventory/InventoryManager.cs:            if (item == null || string.IsNullOrEmpty(item.ItemName)) return;
./Inventory/InventoryManager.cs:
./Inventory/InventoryManager.cs:            var existingSlot = inventoryGrid.FirstOrDefault(slot => slot.item != null && slot.item.ItemName == item.ItemName);
./Inventory/InventoryManager.cs:            if (existingSlot != null && item.IsStackable)
./Inventory/InventoryManager.cs:            {
./Inventory/InventoryManager.cs:                existingSlot.Add(1);
./Inventory/InventoryManager.cs:                Debug.Log($"[InventoryManager] 🔁 Stacked item: {item.ItemName} ➕ Quantity now: {existingSlot.quantity}");
./Inventory/InventoryManager.cs:                return;
./Inventory/InventoryManager.cs:            }
./Inventory/InventoryManager.cs:
./Inventory/InventoryManager.cs:            var emptySlot = inventoryGrid.FirstOrDefault(slot => slot.IsEmpty);
./Inventory/InventoryManager.cs:            if (emptySlot != null)
./Inventory/InventoryManager.cs:            {
./Inventory/InventoryManager.cs:                emptySlot.item = item;
./Inventory/InventoryManager.cs:                emptySlot.quantity = 1;
./Inventory/InventoryManager.cs:                Debug.Log($"[InventoryManager] ✅ Item added: {item.ItemName}");
./Inventory/InventoryManager.cs:            }
./Inventory/InventoryManager.cs:            else
./Inventory/InventoryManager.cs:            {
./Inventory/InventoryManager.cs:                Debug.LogWarning("[InventoryManager] ⚠️ No empty inventory slots available.");
./Inventory/InventoryManager.cs:            }
./Inventory/InventoryManager.cs:        }
./Inventory/InventoryManager.cs:
./Inventory/InventoryManager.cs:        public void RemoveItem(string itemName)
./Inventory/InventoryManager.cs:        {
./Inventory/InventoryManager.cs:            var slot = inventoryGrid.FirstOrDefault(s => s.item != null && s.item.ItemName == itemName);
./Inventory/InventoryManager.cs:            if (slot != null)
./Inventory/InventoryManager.cs:            {
./Inventory/InventoryManager.cs:                slot.item = null;
./Inventory/InventoryManager.cs:                slot.quantity = 0;
./Inventory/InventoryManager.cs:                Debug.Log($"[InventoryManager] 🗑️ Item removed: {itemName}");
./Inventory/InventoryManager.cs:            }
./Inventory/InventoryManager.cs:            else
./Inventory/InventoryManager.cs:            {
./Inventory/InventoryManager.cs:                Debug.LogWarning($"[InventoryManager] ❌ Item not found: {itemName}");
./Inventory/InventoryManager.cs:            }
./Inventory/InventoryManager.cs:        }
./Inventory/InventoryManager.cs:
./Inventory/InventoryManager.cs:        public bool HasItem(string itemName) =>
./Inventory/InventoryManager.cs:            inventoryGrid.Any(slot => slot.item != null && slot.item.ItemName == itemName);
./Inventory/InventoryManager.cs:
./Inventory/InventoryManager.cs:        public InventoryItem GetItem(string itemName) =>
./Inventory/InventoryManager.cs:            inventoryGrid.FirstOrDefault(slot => slot.item != null && slot.item.ItemName == itemName)?.item;
./Inventory/InventoryManager.cs:
./Inventory/InventoryManager.cs:        public List<InventoryItem> GetAllItems() =>
./Inventory/InventoryManager.cs:            inventoryGrid.Where(slot => slot.item != null).Select(slot => slot.item).ToList();
./Inventory/InventoryManager.cs:
./Inventory/InventoryManager.cs:        public int CountItemByName(string itemName) =>
./Inventory/InventoryManager.cs:            inventoryGrid.Where(slot => slot.item != null && slot.item.ItemName == itemName).Sum(slot => slot.quantity);
./Inventory/InventoryManager.cs:
./Inventory/InventoryManager.cs:        public void RemoveItemsByName(string itemName, int quantity)
./Inventory/InventoryManager.cs:        {
./Inventory/InventoryManager.cs:            var remaining = quantity;
./Inventory/InventoryManager.cs:            foreach (var slot in inventoryGrid.Where(s => s.item != null && s.item.ItemName == itemName))
./Inventory/InventoryManager.cs:            {
./Inventory/InventoryManager.cs:                if (remaining <= 0) break;
./Inventory/InventoryManager.cs:
./Inventory/InventoryManager.cs:                if (slot.quantity <= remaining)
./Inventory/InventoryManager.cs:                {
./Inventory/InventoryManager.cs:                    remaining -= slot.quantity;
./Inventory/InventoryManager.cs:                    slot.item = null;
./Inventory/InventoryManager.cs:                    slot.quantity = 0;
./Inventory/InventoryManager.cs:                }
./Inventory/InventoryManager.cs:                else
./Inventory/InventoryManager.cs:                {
./Inventory/InventoryManager.cs:                    slot.quantity -= remaining;
./Inventory/InventoryManager.cs:                    remaining = 0;
./Inventory/InventoryManager.cs:                }
./Inventory/InventoryManager.cs:            }
./Inventory/InventoryManager.cs:
./Inventory/InventoryManager.cs:            Debug.Log($"[InventoryManager] 🧹 Removed {quantity - remaining}x '{itemName}'");
./Inventory/InventoryManager.cs:        }
./Inventory/InventoryManager.cs:    }
./Inventory/InventoryManager.cs:}
--
./Inventory/InventoryManager.cs.meta:fileFormatVersion: 2
./Inventory/InventoryManager.cs.meta:guid: 4fa78204f3987f3409e1c20b19a4a435
--
./Inventory/InventorySystem.cs:﻿using System.Collections.Generic;
./Inventory/InventorySystem.cs:using UnityEngine;
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:namespace Game.Inventory
./Inventory/InventorySystem.cs:{
./Inventory/InventorySystem.cs:    /// <summary>
./Inventory/InventorySystem.cs:    /// Global inventory service for stacking, slot compatibility, and item registry.
./Inventory/InventorySystem.cs:    /// </summary>
./Inventory/InventorySystem.cs:    [AddComponentMenu("Inventory/Inventory System")]
./Inventory/InventorySystem.cs:    public class InventorySystem : MonoBehaviour
./Inventory/InventorySystem.cs:    {
./Inventory/InventorySystem.cs:        [Header("System Settings")]
./Inventory/InventorySystem.cs:        [Tooltip("Maximum number of slots available in inventory")]
./Inventory/InventorySystem.cs:        [SerializeField] private int maxSlots = 20;
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:        [Tooltip("Current stacked items across inventory")]
./Inventory/InventorySystem.cs:        [SerializeField] private List<InventorySlot> slots = new();
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:        public bool AddItem(InventoryItem item, int amount)
./Inventory/InventorySystem.cs:        {
./Inventory/InventorySystem.cs:            if (item == null)
./Inventory/InventorySystem.cs:            {
./Inventory/InventorySystem.cs:                Debug.LogWarning("[InventorySystem] ⚠️ Tried to add null item.");
./Inventory/InventorySystem.cs:                return false;
./Inventory/InventorySystem.cs:            }
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:            if (!CanPlaceInSlot(item, item.assignedSlotType))
./Inventory/InventorySystem.cs:            {
./Inventory/InventorySystem.cs:                Debug.LogWarning($"[InventorySystem] ❌ Cannot place '{item.ItemName}' in '{item.assignedSlotType}'");
./Inventory/InventorySystem.cs:                return false;
./Inventory/InventorySystem.cs:            }
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:            if (IsItemRegistered(item))
./Inventory/InventorySystem.cs:            {
./Inventory/InventorySystem.cs:                Debug.LogWarning($"[InventorySystem] ⛔ Item '{item.ItemName}' already exists.");
./Inventory/InventorySystem.cs:                return false;
./Inventory/InventorySystem.cs:            }
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:            foreach (var slot in slots)
./Inventory/InventorySystem.cs:            {
./Inventory/InventorySystem.cs:                if (slot.item == item && slot.quantity < item.maxStack)
./Inventory/InventorySystem.cs:                {
./Inventory/InventorySystem.cs:                    slot.Add(amount);
./Inventory/InventorySystem.cs:                    Debug.Log($"[InventorySystem] ➕ Stacked '{item.ItemName}' x{amount}");
./Inventory/InventorySystem.cs:                    return true;
./Inventory/InventorySystem.cs:                }
./Inventory/InventorySystem.cs:            }
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:            if (slots.Count < maxSlots)
./Inventory/InventorySystem.cs:            {
./Inventory/InventorySystem.cs:                slots.Add(new InventorySlot { item = item, quantity = amount });
./Inventory/InventorySystem.cs:                Debug.Log($"[InventorySystem] ✅ Added new '{item.ItemName}' x{amount}");
./Inventory/InventorySystem.cs:                return true;
./Inventory/InventorySystem.cs:            }
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:            Debug.LogWarning("[InventorySystem] ❌ Inventory full.");
./Inventory/InventorySystem.cs:            return false;
./Inventory/InventorySystem.cs:        }
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:        public bool TryTransferItem(InventoryItem item, SlotType targetSlot)
./Inventory/InventorySystem.cs:        {
./Inventory/InventorySystem.cs:            if (item == null)
./Inventory/InventorySystem.cs:            {
./Inventory/InventorySystem.cs:                Debug.LogWarning("[InventorySystem] ⚠️ Tried to transfer null item.");
./Inventory/InventorySystem.cs:                return false;
./Inventory/InventorySystem.cs:            }
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:            if (!CanPlaceInSlot(item, targetSlot))
./Inventory/InventorySystem.cs:            {
./Inventory/InventorySystem.cs:                Debug.LogWarning($"[InventorySystem] ❌ Transfer blocked: '{item.ItemName}' → '{targetSlot}'");
./Inventory/InventorySystem.cs:                return false;
./Inventory/InventorySystem.cs:            }
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:            if (IsItemRegistered(item))
./Inventory/InventorySystem.cs:            {
./Inventory/InventorySystem.cs:                Debug.LogWarning($"[InventorySystem] ⛔ Item '{item.ItemName}' already in inventory.");
./Inventory/InventorySystem.cs:                return false;
./Inventory/InventorySystem.cs:            }
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:            slots.Add(new InventorySlot { item = item, quantity = 1 });
./Inventory/InventorySystem.cs:            Debug.Log($"[InventorySystem] 🔄 Transferred '{item.ItemName}' to '{targetSlot}'");
./Inventory/InventorySystem.cs:            return true;
./Inventory/InventorySystem.cs:        }
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:        public bool CanPlaceInSlot(InventoryItem item, SlotType slotType)
./Inventory/InventorySystem.cs:        {
./Inventory/InventorySystem.cs:            if (item == null) return false;
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:            if (item.IsContainer() && (slotType == SlotType.Clothing || slotType == SlotType.General))
./Inventory/InventorySystem.cs:            {
./Inventory/InventorySystem.cs:                Debug.LogWarning($"[InventorySystem] 🛑 Blocked nested container: '{item.ItemName}'");
./Inventory/InventorySystem.cs:                return false;
./Inventory/InventorySystem.cs:            }
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:            return ValidateSlotCompatibility(item.itemType, slotType);
./Inventory/InventorySystem.cs:        }
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:        private bool ValidateSlotCompatibility(ItemTypeEnum itemType, SlotType slotType) => itemType switch
./Inventory/InventorySystem.cs:        {
./Inventory/InventorySystem.cs:            ItemTypeEnum.Handheld => slotType == SlotType.Utility,
./Inventory/InventorySystem.cs:            ItemTypeEnum.Consumable => slotType == SlotType.Food,
./Inventory/InventorySystem.cs:            ItemTypeEnum.Clothing => slotType == SlotType.Clothing,
./Inventory/InventorySystem.cs:            ItemTypeEnum.Holster => slotType == SlotType.Holster,
./Inventory/InventorySystem.cs:            ItemTypeEnum.Bag => slotType == SlotType.General,
./Inventory/InventorySystem.cs:            _ => false,
./Inventory/InventorySystem.cs:        };
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:        public bool IsItemRegistered(InventoryItem item) =>
./Inventory/InventorySystem.cs:            item != null && slots.Exists(s => s.item == item);
./Inventory/InventorySystem.cs:
./Inventory/InventorySystem.cs:        public void ClearInventory()
./Inventory/InventorySystem.cs:        {
./Inventory/InventorySystem.cs:            slots.Clear();
./Inventory/InventorySystem.cs:            Debug.Log("[InventorySystem] 🧹 Inventory wiped.");
./Inventory/InventorySystem.cs:        }
./Inventory/InventorySystem.cs:    }
./Inventory/InventorySystem.cs:}
--
./Inventory/InventorySystem.cs.meta:fileFormatVersion: 2
./Inventory/InventorySystem.cs.meta:guid: 9b1aaefd912726e44b1ffe86f59c5667
--
./Inventory/Item.cs:// Item.cs
./Inventory/Item.cs:namespace InventorySystem
./Inventory/Item.cs:{
./Inventory/Item.cs:    public class Item
./Inventory/Item.cs:    {
./Inventory/Item.cs:        public string itemName;
./Inventory/Item.cs:        public int itemID;
./Inventory/Item.cs:
./Inventory/Item.cs:        public Item(string name, int id)
./Inventory/Item.cs:        {
./Inventory/Item.cs:            itemName = name;
./Inventory/Item.cs:            itemID = id;
./Inventory/Item.cs:        }
./Inventory/Item.cs:    }
./Inventory/Item.cs:}
--
./Inventory/Item.cs.meta:fileFormatVersion: 2
./Inventory/Item.cs.meta:guid: eb4407ae0f80ac844b54e6ebdb8d5303
--
./Inventory/ItemData.cs:﻿using System.Collections.Generic;
./Inventory/ItemData.cs:using UnityEngine;
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:namespace Game.Inventory
./Inventory/ItemData.cs:{
./Inventory/ItemData.cs:    [CreateAssetMenu(fileName = "New Item", menuName = "Inventory/Item")]
./Inventory/ItemData.cs:    public class ItemData : ScriptableObject
./Inventory/ItemData.cs:    {
./Inventory/ItemData.cs:        [Header("🆔 Basic Info")]
./Inventory/ItemData.cs:        [Tooltip("Unique item ID (use GUID or meaningful string)")]
./Inventory/ItemData.cs:        [SerializeField] private string id;
./Inventory/ItemData.cs:        public string Id => string.IsNullOrEmpty(id) ? "Unnamed_Item" : id;
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        [Tooltip("Item name used in UI")]
./Inventory/ItemData.cs:        [SerializeField] private string itemName;
./Inventory/ItemData.cs:        public string ItemName => string.IsNullOrEmpty(itemName) ? "Unnamed" : itemName;
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        [Tooltip("Main tooltip description")]
./Inventory/ItemData.cs:        [TextArea(3, 5)]
./Inventory/ItemData.cs:        [SerializeField] private string tooltipText;
./Inventory/ItemData.cs:        public string TooltipText => tooltipText;
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        [Header("🎨 Visuals")]
./Inventory/ItemData.cs:        [Tooltip("Main UI icon")]
./Inventory/ItemData.cs:        public Sprite icon;
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        [Tooltip("Optional override when equipped")]
./Inventory/ItemData.cs:        public Sprite equippedSprite;
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        [Header("⚙️ Item Properties")]
./Inventory/ItemData.cs:        public ItemTypeEnum itemType;
./Inventory/ItemData.cs:        public Rarity rarity;
./Inventory/ItemData.cs:        public float condition = 100f;
./Inventory/ItemData.cs:        public float weight = 1f;
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        [Header("👕 Equip & Slot Info")]
./Inventory/ItemData.cs:        public ClothingSlot clothingSlot;
./Inventory/ItemData.cs:        public SlotType slotType;
./Inventory/ItemData.cs:        public GearSlotType gearSlotType;
./Inventory/ItemData.cs:        public int slotFootprint = 1; // For grid-based storage
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        [Header("🔥 Cooking")]
./Inventory/ItemData.cs:        public bool isHot = false;
./Inventory/ItemData.cs:        public float hotDuration = 0f;
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        [Header("📦 Container Settings")]
./Inventory/ItemData.cs:        public bool isContainer = false;
./Inventory/ItemData.cs:        public int containerCapacity = 0;
./Inventory/ItemData.cs:        public int storageSlotCapacity = 0;
./Inventory/ItemData.cs:        public int storageCapacity = 0; // 🔧 Added to match InventoryItem
./Inventory/ItemData.cs:        public List<SlotType> slotTypes = new();
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        [Header("🏷️ Tags & Metadata")]
./Inventory/ItemData.cs:        [SerializeField] private List<string> tags = new();
./Inventory/ItemData.cs:        public List<string> Tags => tags;
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        // ──────────────────────────────────────
./Inventory/ItemData.cs:        // 🧠 Utility Accessors & Helpers
./Inventory/ItemData.cs:        // ──────────────────────────────────────
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        public bool IsEquippable =>
./Inventory/ItemData.cs:            itemType == ItemTypeEnum.Clothing || itemType == ItemTypeEnum.Holster;
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        public bool IsStackable =>
./Inventory/ItemData.cs:            !isContainer && condition == 100f && weight < 5f;
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        public bool HasStorage =>
./Inventory/ItemData.cs:            isContainer && containerCapacity > 0;
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        public bool AcceptsSlotType(SlotType type) =>
./Inventory/ItemData.cs:            slotTypes != null && slotTypes.Contains(type);
./Inventory/ItemData.cs:
./Inventory/ItemData.cs:        public bool HasTag(string query) =>
./Inventory/ItemData.cs:            tags != null && tags.Contains(query);
./Inventory/ItemData.cs:    }
./Inventory/ItemData.cs:}
--
./Inventory/ItemData.cs.meta:fileFormatVersion: 2
./Inventory/ItemData.cs.meta:guid: bb9d12fc4dd3bda40bedf1f86e1bdb5c
--
./Inventory/ItemDatabase.cs:﻿using Game.Inventory;
./Inventory/ItemDatabase.cs:using System.Collections.Generic;
./Inventory/ItemDatabase.cs:using UnityEngine;
./Inventory/ItemDatabase.cs:using static UnityEditor.Progress;
./Inventory/ItemDatabase.cs:
./Inventory/ItemDatabase.cs:public class ItemDatabase : MonoBehaviour
./Inventory/ItemDatabase.cs:{
./Inventory/ItemDatabase.cs:    [Header("📦 Assign all your ItemData ScriptableObjects here")]
./Inventory/ItemDatabase.cs:    public List<ItemData> allItemDataAssets = new();
./Inventory/ItemDatabase.cs:
./Inventory/ItemDatabase.cs:    [HideInInspector] public List<ItemData> allItems = new();
./Inventory/ItemDatabase.cs:
./Inventory/ItemDatabase.cs:    private void Awake()
./Inventory/ItemDatabase.cs:    {
./Inventory/ItemDatabase.cs:        RefreshDatabase();
./Inventory/ItemDatabase.cs:    }
./Inventory/ItemDatabase.cs:
./Inventory/ItemDatabase.cs:    /// <summary>
./Inventory/ItemDatabase.cs:    /// Syncs runtime-accessible list with editor-assigned assets.
./Inventory/ItemDatabase.cs:    /// </summary>
./Inventory/ItemDatabase.cs:    public void RefreshDatabase()
./Inventory/ItemDatabase.cs:    {
./Inventory/ItemDatabase.cs:        allItems = allItemDataAssets.FindAll(i => i != null);
./Inventory/ItemDatabase.cs:    }
./Inventory/ItemDatabase.cs:
./Inventory/ItemDatabase.cs:    /// <summary>
./Inventory/ItemDatabase.cs:    /// Get item by display name.
./Inventory/ItemDatabase.cs:    /// </summary>
./Inventory/ItemDatabase.cs:    public Item GetItemByName(string itemName)
./Inventory/ItemDatabase.cs:    {
./Inventory/ItemDatabase.cs:        var data = allItems.Find(i => i.ItemName == itemName);
./Inventory/ItemDatabase.cs:        if (data != null) return new Item(data);
./Inventory/ItemDatabase.cs:
./Inventory/ItemDatabase.cs:        Debug.LogWarning($"⚠️ Item '{itemName}' not found.");
./Inventory/ItemDatabase.cs:        return null;
./Inventory/ItemDatabase.cs:    }
./Inventory/ItemDatabase.cs:
./Inventory/ItemDatabase.cs:    /// <summary>
./Inventory/ItemDatabase.cs:    /// Get item by unique ID string.
./Inventory/ItemDatabase.cs:    /// </summary>
./Inventory/ItemDatabase.cs:    public Item GetItemByID(string id)
./Inventory/ItemDatabase.cs:    {
./Inventory/ItemDatabase.cs:        var data = allItems.Find(i => i.Id == id);
./Inventory/ItemDatabase.cs:        if (data != null) return new Item(data);
./Inventory/ItemDatabase.cs:
./Inventory/ItemDatabase.cs:        Debug.LogWarning($"⚠️ Item with ID '{id}' not found.");
./Inventory/ItemDatabase.cs:        return null;
./Inventory/ItemDatabase.cs:    }
./Inventory/ItemDatabase.cs:
./Inventory/ItemDatabase.cs:    /// <summary>
./Inventory/ItemDatabase.cs:    /// Try safe fetch by name using 'out' pattern.
./Inventory/ItemDatabase.cs:    /// </summary>
./Inventory/ItemDatabase.cs:    public bool TryGetItemByName(string itemName, out Item item)
./Inventory/ItemDatabase.cs:    {
./Inventory/ItemDatabase.cs:        item = null;
./Inventory/ItemDatabase.cs:        var data = allItems.Find(i => i.ItemName == itemName);
./Inventory/ItemDatabase.cs:        if (data != null)
./Inventory/ItemDatabase.cs:        {
./Inventory/ItemDatabase.cs:            item = new Item(data);
./Inventory/ItemDatabase.cs:            return true;
./Inventory/ItemDatabase.cs:        }
./Inventory/ItemDatabase.cs:        return false;
./Inventory/ItemDatabase.cs:    }
./Inventory/ItemDatabase.cs:
./Inventory/ItemDatabase.cs:    /// <summary>
./Inventory/ItemDatabase.cs:    /// Return all item names.
./Inventory/ItemDatabase.cs:    /// </summary>
./Inventory/ItemDatabase.cs:    public List<string> GetAllItemNames()
./Inventory/ItemDatabase.cs:    {
./Inventory/ItemDatabase.cs:        List<string> names = new();
./Inventory/ItemDatabase.cs:        foreach (var data in allItems)
./Inventory/ItemDatabase.cs:            names.Add(data.ItemName);
./Inventory/ItemDatabase.cs:        return names;
./Inventory/ItemDatabase.cs:    }
./Inventory/ItemDatabase.cs:
./Inventory/ItemDatabase.cs:    /// <summary>
./Inventory/ItemDatabase.cs:    /// Get all items matching a rarity level.
./Inventory/ItemDatabase.cs:    /// </summary>
./Inventory/ItemDatabase.cs:    public List<ItemData> GetItemsByRarity(Rarity rarity)
./Inventory/ItemDatabase.cs:    {
./Inventory/ItemDatabase.cs:        return allItems.FindAll(i => i.rarity == rarity);
./Inventory/ItemDatabase.cs:    }
./Inventory/ItemDatabase.cs:
./Inventory/ItemDatabase.cs:    /// <summary>
./Inventory/ItemDatabase.cs:    /// Get all items that contain a specific tag.
./Inventory/ItemDatabase.cs:    /// </summary>
./Inventory/ItemDatabase.cs:    public List<ItemData> GetItemsWithTag(string tag)
./Inventory/ItemDatabase.cs:    {
./Inventory/ItemDatabase.cs:        return allItems.FindAll(i => i.HasTag(tag));
./Inventory/ItemDatabase.cs:    }
./Inventory/ItemDatabase.cs:
./Inventory/ItemDatabase.cs:    /// <summary>
./Inventory/ItemDatabase.cs:    /// Print a basic summary of all registered items.
./Inventory/ItemDatabase.cs:    /// </summary>
./Inventory/ItemDatabase.cs:    public void PrintItemSummary()
./Inventory/ItemDatabase.cs:    {
./Inventory/ItemDatabase.cs:        foreach (var data in allItems)
./Inventory/ItemDatabase.cs:        {
./Inventory/ItemDatabase.cs:            string summary = $"🧾 {data.ItemName} | Type: {data.itemType} | Weight: {data.weight} | Storage: {data.storageCapacity}";
./Inventory/ItemDatabase.cs:            Debug.Log(summary);
./Inventory/ItemDatabase.cs:        }
./Inventory/ItemDatabase.cs:    }
./Inventory/ItemDatabase.cs:}
--
./Inventory/ItemDatabase.cs.meta:fileFormatVersion: 2
./Inventory/ItemDatabase.cs.meta:guid: 80960da8510cd034ca1316e3f3073adc
--
./Inventory/ItemTypeEnum.cs:// File: Assets/Scripts/Inventory/ItemType.cs
./Inventory/ItemTypeEnum.cs:namespace Game.Inventory
./Inventory/ItemTypeEnum.cs:{
./Inventory/ItemTypeEnum.cs:    public enum ItemTypeEnum
./Inventory/ItemTypeEnum.cs:    {
./Inventory/ItemTypeEnum.cs:        Weapon,
./Inventory/ItemTypeEnum.cs:        Armor,
./Inventory/ItemTypeEnum.cs:        Tool,
./Inventory/ItemTypeEnum.cs:        Consumable,
./Inventory/ItemTypeEnum.cs:        Quest
./Inventory/ItemTypeEnum.cs:    }
./Inventory/ItemTypeEnum.cs:}
--
./Inventory/ItemTypeEnum.cs.meta:fileFormatVersion: 2
./Inventory/ItemTypeEnum.cs.meta:guid: fca723d4752b3104d8a9a2f38ca6e07b
--
./Inventory/PlayerInventory.cs:﻿using System.Collections.Generic;
./Inventory/PlayerInventory.cs:using System.Linq;
./Inventory/PlayerInventory.cs:using UnityEngine;
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:namespace Game.Inventory
./Inventory/PlayerInventory.cs:{
./Inventory/PlayerInventory.cs:    /// <summary>
./Inventory/PlayerInventory.cs:    /// Local inventory component for equipped gear, container logic, and storage delegation.
./Inventory/PlayerInventory.cs:    /// </summary>
./Inventory/PlayerInventory.cs:    [AddComponentMenu("Inventory/Player Inventory")]
./Inventory/PlayerInventory.cs:    public class PlayerInventory : MonoBehaviour
./Inventory/PlayerInventory.cs:    {
./Inventory/PlayerInventory.cs:        public List<InventoryItem> ownedItems = new();
./Inventory/PlayerInventory.cs:        public InventoryItem rightHand;
./Inventory/PlayerInventory.cs:        public InventoryItem leftHand;
./Inventory/PlayerInventory.cs:        public bool auditComplete = false;
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:        private List<InventoryItem> registeredContainers = new();
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:        public bool hasRegisteredGearContainers => registeredContainers.Any(item =>
./Inventory/PlayerInventory.cs:            item != null &&
./Inventory/PlayerInventory.cs:            item.isContainer &&
./Inventory/PlayerInventory.cs:            item.isEquipped &&
./Inventory/PlayerInventory.cs:            item.storageCapacity > 0 &&
./Inventory/PlayerInventory.cs:            item.internalStorage != null);
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:        public void AutoEquipStarterGear()
./Inventory/PlayerInventory.cs:        {
./Inventory/PlayerInventory.cs:            foreach (var item in ownedItems)
./Inventory/PlayerInventory.cs:            {
./Inventory/PlayerInventory.cs:                if (item.itemType == ItemTypeEnum.Clothing && !item.isEquipped)
./Inventory/PlayerInventory.cs:                {
./Inventory/PlayerInventory.cs:                    EquipItem(item);
./Inventory/PlayerInventory.cs:                    Debug.Log($"[PlayerInventory] Auto-equipped: {item.ItemName}");
./Inventory/PlayerInventory.cs:                }
./Inventory/PlayerInventory.cs:            }
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:            Debug.Log("[PlayerInventory] Starter gear auto-equipped.");
./Inventory/PlayerInventory.cs:        }
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:        public void AuditGearContainers()
./Inventory/PlayerInventory.cs:        {
./Inventory/PlayerInventory.cs:            registeredContainers.Clear();
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:            foreach (var item in ownedItems)
./Inventory/PlayerInventory.cs:            {
./Inventory/PlayerInventory.cs:                if (item == null)
./Inventory/PlayerInventory.cs:                {
./Inventory/PlayerInventory.cs:                    Debug.LogWarning("[PlayerInventory] 🛑 Audit skipped null gear entry.");
./Inventory/PlayerInventory.cs:                    continue;
./Inventory/PlayerInventory.cs:                }
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:                Debug.Log($"[PlayerInventory] 🔍 Audit: {item.ItemName} | isContainer: {item.isContainer} | Cap: {item.storageCapacity} | Equipped: {item.isEquipped}");
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:                if (item.isContainer && item.storageCapacity > 0)
./Inventory/PlayerInventory.cs:                {
./Inventory/PlayerInventory.cs:                    item.internalStorage ??= new List<InventoryItem>();
./Inventory/PlayerInventory.cs:                    RegisterContainer(item);
./Inventory/PlayerInventory.cs:                }
./Inventory/PlayerInventory.cs:            }
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:            auditComplete = true;
./Inventory/PlayerInventory.cs:            Debug.Log($"[PlayerInventory] ✅ Audit complete. Registered: {registeredContainers.Count}");
./Inventory/PlayerInventory.cs:        }
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:        private void RegisterContainer(InventoryItem containerGear)
./Inventory/PlayerInventory.cs:        {
./Inventory/PlayerInventory.cs:            if (containerGear == null || containerGear.storageCapacity <= 0)
./Inventory/PlayerInventory.cs:            {
./Inventory/PlayerInventory.cs:                Debug.LogWarning($"[PlayerInventory] ⚠️ Invalid container: {containerGear?.ItemName}");
./Inventory/PlayerInventory.cs:                return;
./Inventory/PlayerInventory.cs:            }
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:            if (!registeredContainers.Contains(containerGear))
./Inventory/PlayerInventory.cs:            {
./Inventory/PlayerInventory.cs:                registeredContainers.Add(containerGear);
./Inventory/PlayerInventory.cs:                Debug.Log($"[PlayerInventory] 📦 Registered: {containerGear.ItemName}");
./Inventory/PlayerInventory.cs:            }
./Inventory/PlayerInventory.cs:        }
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:        public void EquipItem(InventoryItem item)
./Inventory/PlayerInventory.cs:        {
./Inventory/PlayerInventory.cs:            if (item == null || item.itemType != ItemTypeEnum.Clothing)
./Inventory/PlayerInventory.cs:            {
./Inventory/PlayerInventory.cs:                Debug.LogWarning($"[PlayerInventory] ❌ Cannot equip: {item?.ItemName}");
./Inventory/PlayerInventory.cs:                return;
./Inventory/PlayerInventory.cs:            }
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:            item.isEquipped = true;
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:            if (!ownedItems.Contains(item))
./Inventory/PlayerInventory.cs:                ownedItems.Add(item);
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:            item.internalStorage ??= new List<InventoryItem>();
./Inventory/PlayerInventory.cs:            RegisterContainer(item);
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:            Debug.Log($"[PlayerInventory] 🧥 Equipped: {item.ItemName}");
./Inventory/PlayerInventory.cs:        }
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:        public void AddItem(InventoryItem item)
./Inventory/PlayerInventory.cs:        {
./Inventory/PlayerInventory.cs:            if (item == null)
./Inventory/PlayerInventory.cs:            {
./Inventory/PlayerInventory.cs:                Debug.LogWarning("[PlayerInventory] ⚠️ Null item ignored.");
./Inventory/PlayerInventory.cs:                return;
./Inventory/PlayerInventory.cs:            }
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:            ownedItems.Add(item);
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:            foreach (var gear in registeredContainers)
./Inventory/PlayerInventory.cs:            {
./Inventory/PlayerInventory.cs:                gear.internalStorage ??= new List<InventoryItem>();
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:                if (gear.internalStorage.Count < gear.storageCapacity)
./Inventory/PlayerInventory.cs:                {
./Inventory/PlayerInventory.cs:                    gear.internalStorage.Add(item);
./Inventory/PlayerInventory.cs:                    Debug.Log($"[PlayerInventory] ✅ Stored '{item.ItemName}' in '{gear.ItemName}'");
./Inventory/PlayerInventory.cs:                    return;
./Inventory/PlayerInventory.cs:                }
./Inventory/PlayerInventory.cs:            }
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:            Debug.LogWarning($"[PlayerInventory] ❌ No available storage for '{item.ItemName}'");
./Inventory/PlayerInventory.cs:        }
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:        public List<InventoryItem> GetEquippedGear() =>
./Inventory/PlayerInventory.cs:            ownedItems.Where(i => i != null && i.isEquipped).ToList();
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:        public ItemData GetEquippedItemBySlotType(GearSlotType slotType) =>
./Inventory/PlayerInventory.cs:            ownedItems.FirstOrDefault(i => i != null && i.isEquipped && i.gearSlotType == slotType)?.data;
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:        public List<InventoryItem> GetActiveStorageGear() => registeredContainers;
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:        public void PrintStorageDebug()
./Inventory/PlayerInventory.cs:        {
./Inventory/PlayerInventory.cs:            foreach (var gear in registeredContainers)
./Inventory/PlayerInventory.cs:            {
./Inventory/PlayerInventory.cs:                int used = gear.internalStorage?.Count ?? 0;
./Inventory/PlayerInventory.cs:                Debug.Log($"[PlayerInventory] {gear.ItemName}: {used}/{gear.storageCapacity}");
./Inventory/PlayerInventory.cs:            }
./Inventory/PlayerInventory.cs:        }
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:        public List<InventoryItem> GetAllItems()
./Inventory/PlayerInventory.cs:        {
./Inventory/PlayerInventory.cs:            List<InventoryItem> all = new(ownedItems);
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:            foreach (var gear in registeredContainers)
./Inventory/PlayerInventory.cs:            {
./Inventory/PlayerInventory.cs:                if (gear?.internalStorage != null)
./Inventory/PlayerInventory.cs:                    all.AddRange(gear.internalStorage);
./Inventory/PlayerInventory.cs:            }
./Inventory/PlayerInventory.cs:
./Inventory/PlayerInventory.cs:            return all;
./Inventory/PlayerInventory.cs:        }
./Inventory/PlayerInventory.cs:    }
./Inventory/PlayerInventory.cs:}
--
./Inventory/PlayerInventory.cs.meta:fileFormatVersion: 2
./Inventory/PlayerInventory.cs.meta:guid: 033ebc422f2a4094cbf25d1023be5be3
--
./Inventory/StackSlot.cs:using UnityEngine;
./Inventory/StackSlot.cs:
./Inventory/StackSlot.cs:namespace Game.Inventory
./Inventory/StackSlot.cs:{
./Inventory/StackSlot.cs:    /// <summary>
./Inventory/StackSlot.cs:    /// Serializable stack slot for item and quantity tracking.
./Inventory/StackSlot.cs:    /// Used in global inventory systems.
./Inventory/StackSlot.cs:    /// </summary>
./Inventory/StackSlot.cs:    [System.Serializable]
./Inventory/StackSlot.cs:    public class StackSlot
./Inventory/StackSlot.cs:    {
./Inventory/StackSlot.cs:        public InventoryItem item;
./Inventory/StackSlot.cs:        public int quantity;
./Inventory/StackSlot.cs:
./Inventory/StackSlot.cs:        public bool IsEmpty => item == null || quantity <= 0;
./Inventory/StackSlot.cs:
./Inventory/StackSlot.cs:        public void Add(int amount) => quantity += amount;
./Inventory/StackSlot.cs:    }
./Inventory/StackSlot.cs:}
--
./Inventory/StackSlot.cs.meta:fileFormatVersion: 2
./Inventory/StackSlot.cs.meta:guid: d8ec004caf393ab45957c39b5853224e
--
./Inventory.meta:fileFormatVersion: 2
./Inventory.meta:guid: 188d47b36302c164bb66433ecfa9286d
./Inventory.meta:folderAsset: yes
./Inventory.meta:DefaultImporter:
./Inventory.meta:  externalObjects: {}
./Inventory.meta:  userData: 
./Inventory.meta:  assetBundleName: 
./Inventory.meta:  assetBundleVariant: 
--
./names.txt:./Audio/Audio.asmdef:  "name": "Audio",
./names.txt:./Combat/Combat.asmdef:  "name": "Combat",
./names.txt:./Core/Core.asmdef:  "name": "Core",
./names.txt:./Crafting/Crafting.asmdef:  "name": "Crafting",
./names.txt:./Debug/Debug.asmdef:  "name": "Debug",
./names.txt:./DevTools/DevTools.asmdef:  "name": "DevTools",
./names.txt:./DialogueSystem/DialogueSystem.asmdef:  "name": "DialogueSystem",
./names.txt:./Editor/Editor.asmdef:  "name": "Editor",
./names.txt:./Environment/Environment.asmdef:  "name": "Environment",
./names.txt:./Flags/Flags.asmdef:  "name": "Flags",
./names.txt:./Interaction/Interaction.asmdef:  "name": "Interaction",
./names.txt:./Inventory/Inventory.asmdef:  "name": "Inventory",
./names.txt:./Narrative/Narrative.asmdef:  "name": "Narrative",
./names.txt:./Player/Player.asmdef:  "name": "Player",
./names.txt:./Quests/Quests.asmdef:  "name": "Quests",
./names.txt:./Scene/Scene.asmdef:  "name": "Scene",
./names.txt:./Systems/Systems.asmdef:  "name": "Systems",
./names.txt:./UI/UI.asmdef:  "name": "UI",
./names.txt:./Validation/Validation.asmdef:  "name": "Validation",
./names.txt:./World/World.asmdef:  "name": "World",
--
./Narrative/ChoiceData.cs:using UnityEngine;
./Narrative/ChoiceData.cs:
./Narrative/ChoiceData.cs:namespace Survival.Narrative.Logic
./Narrative/ChoiceData.cs:{
./Narrative/ChoiceData.cs:    [System.Serializable]
./Narrative/ChoiceData.cs:    public class ChoiceData
./Narrative/ChoiceData.cs:    {
./Narrative/ChoiceData.cs:        public string label;
./Narrative/ChoiceData.cs:        public string nextNodeId;
./Narrative/ChoiceData.cs:        public bool requiresConfirmation;
./Narrative/ChoiceData.cs:        public string effectTag;
./Narrative/ChoiceData.cs:    }
./Narrative/ChoiceData.cs:}
--
./Narrative/ChoiceData.cs.meta:fileFormatVersion: 2
./Narrative/ChoiceData.cs.meta:guid: 35c1fd2794eabea4187ffb74cb898b9c
--
./Narrative/EmotionPrompt.cs:// File: Assets/Scripts/Narrative/EmotionPrompt.cs
./Narrative/EmotionPrompt.cs:using UnityEngine;
./Narrative/EmotionPrompt.cs:
./Narrative/EmotionPrompt.cs:namespace Game.Narrative
./Narrative/EmotionPrompt.cs:{
./Narrative/EmotionPrompt.cs:    public class EmotionPrompt : MonoBehaviour
./Narrative/EmotionPrompt.cs:    {
./Narrative/EmotionPrompt.cs:        [TextArea] public string emotionalText;
./Narrative/EmotionPrompt.cs:
./Narrative/EmotionPrompt.cs:        public void TriggerEmotion()
./Narrative/EmotionPrompt.cs:        {
./Narrative/EmotionPrompt.cs:            Debug.Log($"[EmotionPrompt] Emotion triggered: {emotionalText}");
./Narrative/EmotionPrompt.cs:            // Optional: trigger ambient music or visual filter
./Narrative/EmotionPrompt.cs:        }
./Narrative/EmotionPrompt.cs:    }
./Narrative/EmotionPrompt.cs:}
--
./Narrative/EmotionPrompt.cs.meta:fileFormatVersion: 2
./Narrative/EmotionPrompt.cs.meta:guid: 6f037171933b28c4eacc26d2f1c2ae03
--
./Narrative/Narrative.asmdef:{
./Narrative/Narrative.asmdef:  "name": "Narrative",
./Narrative/Narrative.asmdef:  "references": [
./Narrative/Narrative.asmdef:    "DialogueSystem",
./Narrative/Narrative.asmdef:    "Flags",
./Narrative/Narrative.asmdef:    "Core"
./Narrative/Narrative.asmdef:  ],
./Narrative/Narrative.asmdef:  "includePlatforms": [],
./Narrative/Narrative.asmdef:  "excludePlatforms": [],
./Narrative/Narrative.asmdef:  "allowUnsafeCode": false,
./Narrative/Narrative.asmdef:  "overrideReferences": false,
./Narrative/Narrative.asmdef:  "precompiledReferences": [],
./Narrative/Narrative.asmdef:  "autoReferenced": true,
./Narrative/Narrative.asmdef:  "defineConstraints": [],
./Narrative/Narrative.asmdef:  "versionDefines": [],
./Narrative/Narrative.asmdef:  "noEngineReferences": false
./Narrative/Narrative.asmdef:}
--
./Narrative/Narrative.asmdef.meta:fileFormatVersion: 2
./Narrative/Narrative.asmdef.meta:guid: 30605c3f2c293554396b7f82b6045a6e
./Narrative/Narrative.asmdef.meta:AssemblyDefinitionImporter:
./Narrative/Narrative.asmdef.meta:  externalObjects: {}
./Narrative/Narrative.asmdef.meta:  userData: 
./Narrative/Narrative.asmdef.meta:  assetBundleName: 
./Narrative/Narrative.asmdef.meta:  assetBundleVariant: 
--
./Narrative/NarrativeCoordinator.cs:using UnityEngine;
./Narrative/NarrativeCoordinator.cs:using Survival.Narrative.Parsing;
./Narrative/NarrativeCoordinator.cs:using Survival.Narrative.Logic;
./Narrative/NarrativeCoordinator.cs:using Survival.Narrative.Triggers;
./Narrative/NarrativeCoordinator.cs:using Survival.UI.Narrative;
./Narrative/NarrativeCoordinator.cs:
./Narrative/NarrativeCoordinator.cs:namespace Survival.Narrative.Core
./Narrative/NarrativeCoordinator.cs:{
./Narrative/NarrativeCoordinator.cs:    public class NarrativeCoordinator : MonoBehaviour
./Narrative/NarrativeCoordinator.cs:    {
./Narrative/NarrativeCoordinator.cs:        [Header("Dependencies")]
./Narrative/NarrativeCoordinator.cs:        [SerializeField] private NarrativeNodeParser parser;
./Narrative/NarrativeCoordinator.cs:        [SerializeField] private ChoiceResolver choiceResolver;
./Narrative/NarrativeCoordinator.cs:        [SerializeField] private TriggerEvaluator triggerEvaluator;
./Narrative/NarrativeCoordinator.cs:        [SerializeField] private DialogueUIController uiController;
./Narrative/NarrativeCoordinator.cs:
./Narrative/NarrativeCoordinator.cs:        public void LoadNode(string nodeId)
./Narrative/NarrativeCoordinator.cs:        {
./Narrative/NarrativeCoordinator.cs:            var node = parser.Parse(nodeId);
./Narrative/NarrativeCoordinator.cs:            if (node == null)
./Narrative/NarrativeCoordinator.cs:            {
./Narrative/NarrativeCoordinator.cs:                Debug.LogWarning($"[NarrativeCoordinator] Node '{nodeId}' not found.");
./Narrative/NarrativeCoordinator.cs:                return;
./Narrative/NarrativeCoordinator.cs:            }
./Narrative/NarrativeCoordinator.cs:
./Narrative/NarrativeCoordinator.cs:            if (!triggerEvaluator.Evaluate(node.triggers))
./Narrative/NarrativeCoordinator.cs:            {
./Narrative/NarrativeCoordinator.cs:                Debug.Log($"[NarrativeCoordinator] Node '{nodeId}' blocked by triggers.");
./Narrative/NarrativeCoordinator.cs:                return;
./Narrative/NarrativeCoordinator.cs:            }
./Narrative/NarrativeCoordinator.cs:
./Narrative/NarrativeCoordinator.cs:            uiController.RenderNode(node);
./Narrative/NarrativeCoordinator.cs:        }
./Narrative/NarrativeCoordinator.cs:
./Narrative/NarrativeCoordinator.cs:        public void SelectChoice(int index)
./Narrative/NarrativeCoordinator.cs:        {
./Narrative/NarrativeCoordinator.cs:            var outcome = choiceResolver.Resolve(index);
./Narrative/NarrativeCoordinator.cs:            if (outcome != null)
./Narrative/NarrativeCoordinator.cs:            {
./Narrative/NarrativeCoordinator.cs:                LoadNode(outcome.nextNodeId);
./Narrative/NarrativeCoordinator.cs:            }
./Narrative/NarrativeCoordinator.cs:        }
./Narrative/NarrativeCoordinator.cs:    }
./Narrative/NarrativeCoordinator.cs:}
--
./Narrative/NarrativeCoordinator.cs.meta:fileFormatVersion: 2
./Narrative/NarrativeCoordinator.cs.meta:guid: ab1d059f0810d524ea48db65104c6514
--
./Narrative/NarrativeNode.cs:using System.Collections.Generic;
./Narrative/NarrativeNode.cs:using UnityEngine;
./Narrative/NarrativeNode.cs:using Survival.Narrative.Triggers;
./Narrative/NarrativeNode.cs:using Survival.Narrative.Logic;
./Narrative/NarrativeNode.cs:
./Narrative/NarrativeNode.cs:namespace Survival.Narrative.Core
./Narrative/NarrativeNode.cs:{
./Narrative/NarrativeNode.cs:    [System.Serializable]
./Narrative/NarrativeNode.cs:    public class NarrativeNode
./Narrative/NarrativeNode.cs:    {
./Narrative/NarrativeNode.cs:        [Header("Node Identity")]
./Narrative/NarrativeNode.cs:        public string id;
./Narrative/NarrativeNode.cs:        [TextArea(3, 10)]
./Narrative/NarrativeNode.cs:        public string bodyText;
./Narrative/NarrativeNode.cs:
./Narrative/NarrativeNode.cs:        [Header("Choices")]
./Narrative/NarrativeNode.cs:        public List<ChoiceData> choices;
./Narrative/NarrativeNode.cs:
./Narrative/NarrativeNode.cs:        [Header("Triggers")]
./Narrative/NarrativeNode.cs:        public TriggerSet triggers;
./Narrative/NarrativeNode.cs:    }
./Narrative/NarrativeNode.cs:}
--
./Narrative/NarrativeNode.cs.meta:fileFormatVersion: 2
./Narrative/NarrativeNode.cs.meta:guid: 558363076f0b69f4c83fc1f882f4f2fc
--
./Narrative/NarrativeNodeParser.cs:using UnityEngine;
./Narrative/NarrativeNodeParser.cs:using System.Collections.Generic;
./Narrative/NarrativeNodeParser.cs:using Survival.Narrative.Core;
./Narrative/NarrativeNodeParser.cs:
./Narrative/NarrativeNodeParser.cs:namespace Survival.Narrative.Parsing
./Narrative/NarrativeNodeParser.cs:{
./Narrative/NarrativeNodeParser.cs:    [CreateAssetMenu(fileName = "NarrativeNodeParser", menuName = "Narrative/Node Parser")]
./Narrative/NarrativeNodeParser.cs:    public class NarrativeNodeParser : ScriptableObject
./Narrative/NarrativeNodeParser.cs:    {
./Narrative/NarrativeNodeParser.cs:        [Header("Node Definitions")]
./Narrative/NarrativeNodeParser.cs:        [SerializeField] private List<NarrativeNode> allNodes;
./Narrative/NarrativeNodeParser.cs:
./Narrative/NarrativeNodeParser.cs:        public NarrativeNode Parse(string nodeId)
./Narrative/NarrativeNodeParser.cs:        {
./Narrative/NarrativeNodeParser.cs:            var node = allNodes.Find(n => n.id == nodeId);
./Narrative/NarrativeNodeParser.cs:            if (node == null)
./Narrative/NarrativeNodeParser.cs:                Debug.LogWarning($"[NodeParser] Node ID '{nodeId}' not found.");
./Narrative/NarrativeNodeParser.cs:            return node;
./Narrative/NarrativeNodeParser.cs:        }
./Narrative/NarrativeNodeParser.cs:    }
./Narrative/NarrativeNodeParser.cs:}
--
./Narrative/NarrativeNodeParser.cs.meta:fileFormatVersion: 2
./Narrative/NarrativeNodeParser.cs.meta:guid: e063566a9a2906b47bf1876be0729a4a
--
./Narrative/StoryFlags.cs:namespace Narrative.Flags {
./Narrative/StoryFlags.cs:    public static class StoryFlags {
./Narrative/StoryFlags.cs:        public static bool HasMetNPC => true;
./Narrative/StoryFlags.cs:    }
./Narrative/StoryFlags.cs:}
--
./Narrative/StoryFlags.cs.meta:fileFormatVersion: 2
./Narrative/StoryFlags.cs.meta:guid: 29a43db1e5f46bb4f8ab9bc1f147971d
--
./Narrative/TriggerSet.cs:using UnityEngine;
./Narrative/TriggerSet.cs:
./Narrative/TriggerSet.cs:namespace Survival.Narrative.Triggers
./Narrative/TriggerSet.cs:{
./Narrative/TriggerSet.cs:    [System.Serializable]
./Narrative/TriggerSet.cs:    public class TriggerSet
./Narrative/TriggerSet.cs:    {
./Narrative/TriggerSet.cs:        public bool requiresItem;
./Narrative/TriggerSet.cs:        public string requiredItemId;
./Narrative/TriggerSet.cs:        public bool requiresStat;
./Narrative/TriggerSet.cs:        public string statName;
./Narrative/TriggerSet.cs:        public float minValue;
./Narrative/TriggerSet.cs:    }
./Narrative/TriggerSet.cs:}
--
./Narrative/TriggerSet.cs.meta:fileFormatVersion: 2
./Narrative/TriggerSet.cs.meta:guid: 568e6a12e6f89394da224bffc0b0fea3
--
./Narrative.meta:fileFormatVersion: 2
./Narrative.meta:guid: 677162169b01ccf42afdf353f1b96710
./Narrative.meta:folderAsset: yes
./Narrative.meta:DefaultImporter:
./Narrative.meta:  externalObjects: {}
./Narrative.meta:  userData: 
./Narrative.meta:  assetBundleName: 
./Narrative.meta:  assetBundleVariant: 
--
./Player/ExposureManager.cs:using System.Collections.Generic;
./Player/ExposureManager.cs:using UnityEngine;
./Player/ExposureManager.cs:
./Player/ExposureManager.cs:public class ExposureManager : MonoBehaviour
./Player/ExposureManager.cs:{
./Player/ExposureManager.cs:    public HashSet<ExposureFlags> activeExposureStates = new();
./Player/ExposureManager.cs:
./Player/ExposureManager.cs:    public void AddExposure(ExposureFlags flag)
./Player/ExposureManager.cs:    {
./Player/ExposureManager.cs:        activeExposureStates.Add(flag);
./Player/ExposureManager.cs:        Debug.Log("Exposure added: " + flag);
./Player/ExposureManager.cs:    }
./Player/ExposureManager.cs:
./Player/ExposureManager.cs:    public void RemoveExposure(ExposureFlags flag)
./Player/ExposureManager.cs:    {
./Player/ExposureManager.cs:        if (activeExposureStates.Contains(flag))
./Player/ExposureManager.cs:        {
./Player/ExposureManager.cs:            activeExposureStates.Remove(flag);
./Player/ExposureManager.cs:            Debug.Log("Exposure removed: " + flag);
./Player/ExposureManager.cs:        }
./Player/ExposureManager.cs:    }
./Player/ExposureManager.cs:
./Player/ExposureManager.cs:    public bool HasExposure(ExposureFlags flag) => activeExposureStates.Contains(flag);
./Player/ExposureManager.cs:}
--
./Player/ExposureManager.cs.meta:fileFormatVersion: 2
./Player/ExposureManager.cs.meta:guid: 32f8af0efc84ae6419f9df98a22ae858
--
./Player/InfectionManager.cs:using System.Collections.Generic;
./Player/InfectionManager.cs:using UnityEngine;
./Player/InfectionManager.cs:
./Player/InfectionManager.cs:public class InfectionManager : MonoBehaviour
./Player/InfectionManager.cs:{
./Player/InfectionManager.cs:    public HashSet<InfectionFlags> activeInfections = new();
./Player/InfectionManager.cs:
./Player/InfectionManager.cs:    public void AddInfection(InfectionFlags flag)
./Player/InfectionManager.cs:    {
./Player/InfectionManager.cs:        activeInfections.Add(flag);
./Player/InfectionManager.cs:        Debug.Log("Infection added: " + flag);
./Player/InfectionManager.cs:    }
./Player/InfectionManager.cs:
./Player/InfectionManager.cs:    public void RemoveInfection(InfectionFlags flag)
./Player/InfectionManager.cs:    {
./Player/InfectionManager.cs:        if (activeInfections.Contains(flag))
./Player/InfectionManager.cs:        {
./Player/InfectionManager.cs:            activeInfections.Remove(flag);
./Player/InfectionManager.cs:            Debug.Log("Infection removed: " + flag);
./Player/InfectionManager.cs:        }
./Player/InfectionManager.cs:    }
./Player/InfectionManager.cs:
./Player/InfectionManager.cs:    public bool HasInfection(InfectionFlags flag) => activeInfections.Contains(flag);
./Player/InfectionManager.cs:}
--
./Player/InfectionManager.cs.meta:fileFormatVersion: 2
./Player/InfectionManager.cs.meta:guid: 8ec0928fae795c040aa1a9909f24a6d0
--
./Player/MentalStateManager.cs:using System.Collections.Generic;
./Player/MentalStateManager.cs:using UnityEngine;
./Player/MentalStateManager.cs:
./Player/MentalStateManager.cs:public class MentalStateManager : MonoBehaviour
./Player/MentalStateManager.cs:{
./Player/MentalStateManager.cs:    public HashSet<MentalStateFlags> activeStates = new();
./Player/MentalStateManager.cs:
./Player/MentalStateManager.cs:    public void AddState(MentalStateFlags state)
./Player/MentalStateManager.cs:    {
./Player/MentalStateManager.cs:        activeStates.Add(state);
./Player/MentalStateManager.cs:        Debug.Log("Mental state added: " + state);
./Player/MentalStateManager.cs:    }
./Player/MentalStateManager.cs:
./Player/MentalStateManager.cs:    public void RemoveState(MentalStateFlags state)
./Player/MentalStateManager.cs:    {
./Player/MentalStateManager.cs:        if (activeStates.Contains(state))
./Player/MentalStateManager.cs:        {
./Player/MentalStateManager.cs:            activeStates.Remove(state);
./Player/MentalStateManager.cs:            Debug.Log("Mental state removed: " + state);
./Player/MentalStateManager.cs:        }
./Player/MentalStateManager.cs:    }
./Player/MentalStateManager.cs:
./Player/MentalStateManager.cs:    public bool HasState(MentalStateFlags state) => activeStates.Contains(state);
./Player/MentalStateManager.cs:}
--
./Player/MentalStateManager.cs.meta:fileFormatVersion: 2
./Player/MentalStateManager.cs.meta:guid: fabcd2447637824488c2ec34f55c85e6
--
./Player/Player.asmdef:{
./Player/Player.asmdef:  "name": "Player",
./Player/Player.asmdef:  "references": [
./Player/Player.asmdef:    "Core",
./Player/Player.asmdef:    "Flags",
./Player/Player.asmdef:    "Systems"
./Player/Player.asmdef:  ],
./Player/Player.asmdef:  "includePlatforms": [],
./Player/Player.asmdef:  "excludePlatforms": [],
./Player/Player.asmdef:  "allowUnsafeCode": false,
./Player/Player.asmdef:  "overrideReferences": false,
./Player/Player.asmdef:  "precompiledReferences": [],
./Player/Player.asmdef:  "autoReferenced": true,
./Player/Player.asmdef:  "defineConstraints": [],
./Player/Player.asmdef:  "versionDefines": [],
./Player/Player.asmdef:  "noEngineReferences": false
./Player/Player.asmdef:}
--
./Player/Player.asmdef.meta:fileFormatVersion: 2
./Player/Player.asmdef.meta:guid: b09fc4d9bfe917e4ca97acd78bc6e6b5
./Player/Player.asmdef.meta:AssemblyDefinitionImporter:
./Player/Player.asmdef.meta:  externalObjects: {}
./Player/Player.asmdef.meta:  userData: 
./Player/Player.asmdef.meta:  assetBundleName: 
./Player/Player.asmdef.meta:  assetBundleVariant: 
--
./Player/Player.cs:namespace Project.Player
./Player/Player.cs:{
./Player/Player.cs:    using Game.Inventory;
./Player/Player.cs:    using UnityEngine;
./Player/Player.cs:
./Player/Player.cs:    public class Player : MonoBehaviour
./Player/Player.cs:    {
./Player/Player.cs:        public UIController UIController;
./Player/Player.cs:        public GameObject DeadScreen;
./Player/Player.cs:
./Player/Player.cs:        void Update()
./Player/Player.cs:        {
./Player/Player.cs:            if (Input.GetKeyDown(KeyCode.Tab))
./Player/Player.cs:            {
./Player/Player.cs:                UIController.ToggleInventory(); // Optional shortcut
./Player/Player.cs:            }
./Player/Player.cs:        }
./Player/Player.cs:
./Player/Player.cs:        public void OnPlayerDeath()
./Player/Player.cs:        {
./Player/Player.cs:            DeadScreen.SetActive(true);
./Player/Player.cs:            UIController.InventoryPanel.SetActive(false); // Hide inventory on death
./Player/Player.cs:        }
./Player/Player.cs:
./Player/Player.cs:        public void OnItemPickup(InventoryItem item)
./Player/Player.cs:        {
./Player/Player.cs:            InventoryManager.Instance.AddItem(item);
./Player/Player.cs:            UIController.ToggleInventory(); // Optional: auto-show inventory
./Player/Player.cs:        }
./Player/Player.cs:    }
./Player/Player.cs:}
--
./Player/Player.cs.meta:fileFormatVersion: 2
./Player/Player.cs.meta:guid: cdcd9c435c0cc9a4a8c3dc5b60172dbf
--
./Player/PlayerConditionManager.cs:using System.Collections.Generic;
./Player/PlayerConditionManager.cs:using UnityEngine;
./Player/PlayerConditionManager.cs:
./Player/PlayerConditionManager.cs:public class PlayerConditionManager : MonoBehaviour
./Player/PlayerConditionManager.cs:{
./Player/PlayerConditionManager.cs:    public HashSet<PlayerConditionFlags> activeConditions = new();
./Player/PlayerConditionManager.cs:
./Player/PlayerConditionManager.cs:    public void AddCondition(PlayerConditionFlags condition)
./Player/PlayerConditionManager.cs:    {
./Player/PlayerConditionManager.cs:        activeConditions.Add(condition);
./Player/PlayerConditionManager.cs:        Debug.Log("Condition added: " + condition);
./Player/PlayerConditionManager.cs:    }
./Player/PlayerConditionManager.cs:
./Player/PlayerConditionManager.cs:    public void RemoveCondition(PlayerConditionFlags condition)
./Player/PlayerConditionManager.cs:    {
./Player/PlayerConditionManager.cs:        if (activeConditions.Contains(condition))
./Player/PlayerConditionManager.cs:        {
./Player/PlayerConditionManager.cs:            activeConditions.Remove(condition);
./Player/PlayerConditionManager.cs:            Debug.Log("Condition removed: " + condition);
./Player/PlayerConditionManager.cs:        }
./Player/PlayerConditionManager.cs:    }
./Player/PlayerConditionManager.cs:
./Player/PlayerConditionManager.cs:    public bool HasCondition(PlayerConditionFlags condition) => activeConditions.Contains(condition);
./Player/PlayerConditionManager.cs:}
--
./Player/PlayerConditionManager.cs.meta:fileFormatVersion: 2
./Player/PlayerConditionManager.cs.meta:guid: a82d150ed2178714ab7e737e4d4d4b12
--
./Player/Playerstats.cs:﻿// File: Assets/Scripts/Player/PlayerStats.cs
./Player/Playerstats.cs:using UnityEngine;
./Player/Playerstats.cs:using Game.Inventory;
./Player/Playerstats.cs:
./Player/Playerstats.cs:namespace Player
./Player/Playerstats.cs:{
./Player/Playerstats.cs:    public class PlayerStats : MonoBehaviour
./Player/Playerstats.cs:    {
./Player/Playerstats.cs:        [Header("Core Stats")]
./Player/Playerstats.cs:        public int health;
./Player/Playerstats.cs:        public int stamina;
./Player/Playerstats.cs:        public int strength;
./Player/Playerstats.cs:
./Player/Playerstats.cs:        private EquipmentManager equipmentManager;
./Player/Playerstats.cs:
./Player/Playerstats.cs:        void Awake()
./Player/Playerstats.cs:        {
./Player/Playerstats.cs:#if UNITY_2023_1_OR_NEWER
./Player/Playerstats.cs:            equipmentManager = Object.FindFirstObjectByType<EquipmentManager>();
./Player/Playerstats.cs:#else
./Player/Playerstats.cs:            equipmentManager = FindObjectOfType<EquipmentManager>();
./Player/Playerstats.cs:#endif
./Player/Playerstats.cs:        }
./Player/Playerstats.cs:
./Player/Playerstats.cs:        public InventoryItem GetEquippedItem(string slotName)
./Player/Playerstats.cs:        {
./Player/Playerstats.cs:            if (equipmentManager == null || string.IsNullOrEmpty(slotName))
./Player/Playerstats.cs:                return null;
./Player/Playerstats.cs:
./Player/Playerstats.cs:            return equipmentManager.GetEquippedItem(slotName);
./Player/Playerstats.cs:        }
./Player/Playerstats.cs:
./Player/Playerstats.cs:        public bool HasEquippedWeapon()
./Player/Playerstats.cs:        {
./Player/Playerstats.cs:            var weapon = GetEquippedItem("Weapon");
./Player/Playerstats.cs:            return weapon != null;
./Player/Playerstats.cs:        }
./Player/Playerstats.cs:
./Player/Playerstats.cs:        // Other stat-related methods...
./Player/Playerstats.cs:    }
./Player/Playerstats.cs:}
--
./Player/Playerstats.cs.meta:fileFormatVersion: 2
./Player/Playerstats.cs.meta:guid: b1cb2525b702c9a46a178cd01e2c8e04
--
./Player/PlayerVitalsFacade.cs:using UnityEngine;
./Player/PlayerVitalsFacade.cs:
./Player/PlayerVitalsFacade.cs:public class PlayerVitalsFacade : MonoBehaviour
./Player/PlayerVitalsFacade.cs:{
./Player/PlayerVitalsFacade.cs:    public VitalsManager vitalsManager;
./Player/PlayerVitalsFacade.cs:    public StaminaSystem staminaSystem;
./Player/PlayerVitalsFacade.cs:    public SurvivalStats survivalStats;
./Player/PlayerVitalsFacade.cs:
./Player/PlayerVitalsFacade.cs:    public float CurrentHealth => vitalsManager?.CurrentHealth ?? 0f;
./Player/PlayerVitalsFacade.cs:    public bool IsAlive => vitalsManager?.IsAlive ?? false;
./Player/PlayerVitalsFacade.cs:
./Player/PlayerVitalsFacade.cs:    public float CurrentStamina => staminaSystem?.CurrentStamina ?? 0f;
./Player/PlayerVitalsFacade.cs:    public bool CanSprint => staminaSystem?.CanSprint ?? false;
./Player/PlayerVitalsFacade.cs:
./Player/PlayerVitalsFacade.cs:    public float Hunger => survivalStats?.Hunger ?? 0f;
./Player/PlayerVitalsFacade.cs:    public float Thirst => survivalStats?.Thirst ?? 0f;
./Player/PlayerVitalsFacade.cs:    public float Fatigue => survivalStats?.Fatigue ?? 0f;
./Player/PlayerVitalsFacade.cs:
./Player/PlayerVitalsFacade.cs:    public void ApplyDamage(float amount) => vitalsManager?.ApplyDamage(amount);
./Player/PlayerVitalsFacade.cs:    public void Consume(Item item)
./Player/PlayerVitalsFacade.cs:    {
./Player/PlayerVitalsFacade.cs:        vitalsManager?.ApplyItemEffects(item);
./Player/PlayerVitalsFacade.cs:        survivalStats?.ApplyItemEffects(item);
./Player/PlayerVitalsFacade.cs:        staminaSystem?.Consume(item);
./Player/PlayerVitalsFacade.cs:    }
./Player/PlayerVitalsFacade.cs:}
--
./Player/PlayerVitalsFacade.cs.meta:fileFormatVersion: 2
./Player/PlayerVitalsFacade.cs.meta:guid: 082c5466696058749bbf8cd148837112
--
./Player/SanityManager.cs:using System.Collections.Generic;
./Player/SanityManager.cs:using UnityEngine;
./Player/SanityManager.cs:
./Player/SanityManager.cs:public class SanityManager : MonoBehaviour
./Player/SanityManager.cs:{
./Player/SanityManager.cs:    public HashSet<SanityFlags> activeSanityEvents = new();
./Player/SanityManager.cs:
./Player/SanityManager.cs:    public void AddEvent(SanityFlags flag)
./Player/SanityManager.cs:    {
./Player/SanityManager.cs:        activeSanityEvents.Add(flag);
./Player/SanityManager.cs:        Debug.Log("Sanity event triggered: " + flag);
./Player/SanityManager.cs:    }
./Player/SanityManager.cs:
./Player/SanityManager.cs:    public void RemoveEvent(SanityFlags flag)
./Player/SanityManager.cs:    {
./Player/SanityManager.cs:        if (activeSanityEvents.Contains(flag))
./Player/SanityManager.cs:        {
./Player/SanityManager.cs:            activeSanityEvents.Remove(flag);
./Player/SanityManager.cs:            Debug.Log("Sanity event resolved: " + flag);
./Player/SanityManager.cs:        }
./Player/SanityManager.cs:    }
./Player/SanityManager.cs:
./Player/SanityManager.cs:    public bool HasEvent(SanityFlags flag) => activeSanityEvents.Contains(flag);
./Player/SanityManager.cs:}
--
./Player/SanityManager.cs.meta:fileFormatVersion: 2
./Player/SanityManager.cs.meta:guid: 9ffa74d184a2cb24cb78b56d0a7875d8
--
./Player.meta:fileFormatVersion: 2
./Player.meta:guid: 5601ee2c4523b0c4095feb5ac608adca
./Player.meta:folderAsset: yes
./Player.meta:DefaultImporter:
./Player.meta:  externalObjects: {}
./Player.meta:  userData: 
./Player.meta:  assetBundleName: 
./Player.meta:  assetBundleVariant: 
--
./Quests/QuestLog.cs:// File: Assets/Scripts/Quests/QuestLog.cs
./Quests/QuestLog.cs:using UnityEngine;
./Quests/QuestLog.cs:using System.Collections.Generic;
./Quests/QuestLog.cs:
./Quests/QuestLog.cs:namespace Game.Quests
./Quests/QuestLog.cs:{
./Quests/QuestLog.cs:    [System.Serializable]
./Quests/QuestLog.cs:    public class Quest
./Quests/QuestLog.cs:    {
./Quests/QuestLog.cs:        public string id;
./Quests/QuestLog.cs:        public string description;
./Quests/QuestLog.cs:        public bool completed;
./Quests/QuestLog.cs:    }
./Quests/QuestLog.cs:
./Quests/QuestLog.cs:    public class QuestLog : MonoBehaviour
./Quests/QuestLog.cs:    {
./Quests/QuestLog.cs:        [SerializeField] private List<Quest> activeQuests = new();
./Quests/QuestLog.cs:
./Quests/QuestLog.cs:        public void AddQuest(string id, string description)
./Quests/QuestLog.cs:        {
./Quests/QuestLog.cs:            activeQuests.Add(new Quest { id = id, description = description, completed = false });
./Quests/QuestLog.cs:            Debug.Log($"[QuestLog] Added quest: {description}");
./Quests/QuestLog.cs:        }
./Quests/QuestLog.cs:
./Quests/QuestLog.cs:        public void CompleteQuest(string id)
./Quests/QuestLog.cs:        {
./Quests/QuestLog.cs:            foreach (var quest in activeQuests)
./Quests/QuestLog.cs:            {
./Quests/QuestLog.cs:                if (quest.id == id)
./Quests/QuestLog.cs:                {
./Quests/QuestLog.cs:                    quest.completed = true;
./Quests/QuestLog.cs:                    Debug.Log($"[QuestLog] Completed quest: {quest.description}");
./Quests/QuestLog.cs:                }
./Quests/QuestLog.cs:            }
./Quests/QuestLog.cs:        }
./Quests/QuestLog.cs:    }
./Quests/QuestLog.cs:}
--
./Quests/QuestLog.cs.meta:fileFormatVersion: 2
./Quests/QuestLog.cs.meta:guid: 697a90a4a3c4993428218829ed0b613c
--
./Quests/Quests.asmdef:{
./Quests/Quests.asmdef:  "name": "Quests",
./Quests/Quests.asmdef:  "references": [],
./Quests/Quests.asmdef:  "autoReferenced": true
./Quests/Quests.asmdef:}
--
./Quests/Quests.asmdef.meta:fileFormatVersion: 2
./Quests/Quests.asmdef.meta:guid: 56632d44e296d2141a67c853fb3374cd
./Quests/Quests.asmdef.meta:AssemblyDefinitionImporter:
./Quests/Quests.asmdef.meta:  externalObjects: {}
./Quests/Quests.asmdef.meta:  userData: 
./Quests/Quests.asmdef.meta:  assetBundleName: 
./Quests/Quests.asmdef.meta:  assetBundleVariant: 
--
./Quests.meta:fileFormatVersion: 2
./Quests.meta:guid: 968f34d4072f6014e9d8014a1affe0de
./Quests.meta:folderAsset: yes
./Quests.meta:DefaultImporter:
./Quests.meta:  externalObjects: {}
./Quests.meta:  userData: 
./Quests.meta:  assetBundleName: 
./Quests.meta:  assetBundleVariant: 
--
./Scene/NarrativeSceneBinder.cs:// File: Assets/Scripts/Scene/NarrativeSceneBinder.cs
./Scene/NarrativeSceneBinder.cs:using UnityEngine;
./Scene/NarrativeSceneBinder.cs:
./Scene/NarrativeSceneBinder.cs:namespace Game.DialogueSystem
./Scene/NarrativeSceneBinder.cs:{
./Scene/NarrativeSceneBinder.cs:    public class NarrativeSceneBinder : MonoBehaviour
./Scene/NarrativeSceneBinder.cs:    {
./Scene/NarrativeSceneBinder.cs:        [SerializeField] private StoryFlags flagSystem;
./Scene/NarrativeSceneBinder.cs:        [SerializeField] private string sceneTriggerFlag;
./Scene/NarrativeSceneBinder.cs:
./Scene/NarrativeSceneBinder.cs:        public void MarkSceneEntered() => flagSystem.SetFlag(sceneTriggerFlag, true);
./Scene/NarrativeSceneBinder.cs:    }
./Scene/NarrativeSceneBinder.cs:}
--
./Scene/NarrativeSceneBinder.cs.meta:fileFormatVersion: 2
./Scene/NarrativeSceneBinder.cs.meta:guid: efda4cd3bb3c5a1498e98925cb60687b
--
./Scene/PreFabStoryBinder.cs:// File: Assets/Scripts/Scene/PrefabStoryBinder.cs
./Scene/PreFabStoryBinder.cs:using UnityEngine;
./Scene/PreFabStoryBinder.cs:
./Scene/PreFabStoryBinder.cs:namespace Game.DialogueSystem
./Scene/PreFabStoryBinder.cs:{
./Scene/PreFabStoryBinder.cs:    public class PrefabStoryBinder : MonoBehaviour
./Scene/PreFabStoryBinder.cs:    {
./Scene/PreFabStoryBinder.cs:        [SerializeField] private StoryFlags flagSystem;
./Scene/PreFabStoryBinder.cs:        [SerializeField] private string[] flagsToCheck;
./Scene/PreFabStoryBinder.cs:        [SerializeField] private GameObject[] activateIfTrue;
./Scene/PreFabStoryBinder.cs:
./Scene/PreFabStoryBinder.cs:        private void Start()
./Scene/PreFabStoryBinder.cs:        {
./Scene/PreFabStoryBinder.cs:            for (int i = 0; i < flagsToCheck.Length; i++)
./Scene/PreFabStoryBinder.cs:            {
./Scene/PreFabStoryBinder.cs:                bool active = flagSystem.GetFlag(flagsToCheck[i]);
./Scene/PreFabStoryBinder.cs:                activateIfTrue[i].SetActive(active);
./Scene/PreFabStoryBinder.cs:            }
./Scene/PreFabStoryBinder.cs:        }
./Scene/PreFabStoryBinder.cs:    }
./Scene/PreFabStoryBinder.cs:}
--
./Scene/PreFabStoryBinder.cs.meta:fileFormatVersion: 2
./Scene/PreFabStoryBinder.cs.meta:guid: c6acdfa921f4f57488dd3dcf201f4d1a
--
./Scene/Scene.asmdef:{
./Scene/Scene.asmdef:  "name": "Scene",
./Scene/Scene.asmdef:  "references": [
./Scene/Scene.asmdef:    "Core",
./Scene/Scene.asmdef:    "Systems"
./Scene/Scene.asmdef:  ],
./Scene/Scene.asmdef:  "includePlatforms": [],
./Scene/Scene.asmdef:  "excludePlatforms": [],
./Scene/Scene.asmdef:  "allowUnsafeCode": false,
./Scene/Scene.asmdef:  "overrideReferences": false,
./Scene/Scene.asmdef:  "precompiledReferences": [],
./Scene/Scene.asmdef:  "autoReferenced": true,
./Scene/Scene.asmdef:  "defineConstraints": [],
./Scene/Scene.asmdef:  "versionDefines": [],
./Scene/Scene.asmdef:  "noEngineReferences": false
./Scene/Scene.asmdef:}
--
./Scene/Scene.asmdef.meta:fileFormatVersion: 2
./Scene/Scene.asmdef.meta:guid: 638bae554d376a940bb7b53b744e483f
./Scene/Scene.asmdef.meta:AssemblyDefinitionImporter:
./Scene/Scene.asmdef.meta:  externalObjects: {}
./Scene/Scene.asmdef.meta:  userData: 
./Scene/Scene.asmdef.meta:  assetBundleName: 
./Scene/Scene.asmdef.meta:  assetBundleVariant: 
--
./Scene/SceneTransitionService.cs:using UnityEngine;
./Scene/SceneTransitionService.cs:using UnityEngine.SceneManagement;
./Scene/SceneTransitionService.cs:using System.Threading.Tasks;
./Scene/SceneTransitionService.cs:
./Scene/SceneTransitionService.cs:public interface IFadeOverlay
./Scene/SceneTransitionService.cs:{
./Scene/SceneTransitionService.cs:    void SetAlpha(float alpha);
./Scene/SceneTransitionService.cs:    Color CurrentColor { get; }
./Scene/SceneTransitionService.cs:}
./Scene/SceneTransitionService.cs:
./Scene/SceneTransitionService.cs:[RuntimeService]
./Scene/SceneTransitionService.cs:public class SceneTransitionService : ISceneTransitionResponder
./Scene/SceneTransitionService.cs:{
./Scene/SceneTransitionService.cs:    private readonly IFadeOverlay fadeOverlay;
./Scene/SceneTransitionService.cs:    private readonly float fadeDuration;
./Scene/SceneTransitionService.cs:
./Scene/SceneTransitionService.cs:    public SceneTransitionService(IFadeOverlay overlay, float duration = 1f)
./Scene/SceneTransitionService.cs:    {
./Scene/SceneTransitionService.cs:        fadeOverlay = overlay;
./Scene/SceneTransitionService.cs:        fadeDuration = duration;
./Scene/SceneTransitionService.cs:    }
./Scene/SceneTransitionService.cs:
./Scene/SceneTransitionService.cs:    public async Task FadeInAsync()
./Scene/SceneTransitionService.cs:    {
./Scene/SceneTransitionService.cs:        Debug.Log("[SceneTransitionService] Begin fade-in.");
./Scene/SceneTransitionService.cs:        float timer = fadeDuration;
./Scene/SceneTransitionService.cs:
./Scene/SceneTransitionService.cs:        while (timer > 0f)
./Scene/SceneTransitionService.cs:        {
./Scene/SceneTransitionService.cs:            timer -= Time.deltaTime;
./Scene/SceneTransitionService.cs:            float alpha = Mathf.Lerp(1f, 0f, 1f - (timer / fadeDuration));
./Scene/SceneTransitionService.cs:            fadeOverlay.SetAlpha(alpha);
./Scene/SceneTransitionService.cs:            await Task.Yield();
./Scene/SceneTransitionService.cs:        }
./Scene/SceneTransitionService.cs:
./Scene/SceneTransitionService.cs:        fadeOverlay.SetAlpha(0f);
./Scene/SceneTransitionService.cs:        Debug.Log("[SceneTransitionService] Fade-in complete.");
./Scene/SceneTransitionService.cs:    }
./Scene/SceneTransitionService.cs:
./Scene/SceneTransitionService.cs:    public async Task FadeOutAndLoadAsync(string sceneName)
./Scene/SceneTransitionService.cs:    {
./Scene/SceneTransitionService.cs:        Debug.Log($"[SceneTransitionService] Begin fade-out to scene: {sceneName}");
./Scene/SceneTransitionService.cs:        float timer = 0f;
./Scene/SceneTransitionService.cs:
./Scene/SceneTransitionService.cs:        while (timer < fadeDuration)
./Scene/SceneTransitionService.cs:        {
./Scene/SceneTransitionService.cs:            timer += Time.deltaTime;
./Scene/SceneTransitionService.cs:            float alpha = Mathf.Lerp(0f, 1f, timer / fadeDuration);
./Scene/SceneTransitionService.cs:            fadeOverlay.SetAlpha(alpha);
./Scene/SceneTransitionService.cs:            await Task.Yield();
./Scene/SceneTransitionService.cs:        }
./Scene/SceneTransitionService.cs:
./Scene/SceneTransitionService.cs:        fadeOverlay.SetAlpha(1f);
./Scene/SceneTransitionService.cs:        Debug.Log("[SceneTransitionService] Fade-out complete. Loading scene...");
./Scene/SceneTransitionService.cs:        SceneManager.LoadScene(sceneName);
./Scene/SceneTransitionService.cs:    }
./Scene/SceneTransitionService.cs:
./Scene/SceneTransitionService.cs:    public async void OnSceneLoaded(string sceneName)
./Scene/SceneTransitionService.cs:    {
./Scene/SceneTransitionService.cs:        Debug.Log($"[SceneTransitionService] Scene loaded: {sceneName}. Triggering auto fade-in.");
./Scene/SceneTransitionService.cs:        await FadeInAsync();
./Scene/SceneTransitionService.cs:    }
./Scene/SceneTransitionService.cs:}
--
./Scene/SceneTransitionService.cs.meta:fileFormatVersion: 2
./Scene/SceneTransitionService.cs.meta:guid: 131a3f6ca0d98554fb4ab9e6a67ba267
--
./Scene.meta:fileFormatVersion: 2
./Scene.meta:guid: 96742327365f9b245a5edeb57e411765
./Scene.meta:folderAsset: yes
./Scene.meta:DefaultImporter:
./Scene.meta:  externalObjects: {}
./Scene.meta:  userData: 
./Scene.meta:  assetBundleName: 
./Scene.meta:  assetBundleVariant: 
--
./Systems/DiseaseData.cs:using DiseaseSystem;
./Systems/DiseaseData.cs:using Game.Inventory;
./Systems/DiseaseData.cs:using UnityEngine;
./Systems/DiseaseData.cs:
./Systems/DiseaseData.cs:namespace Game.Status.Models
./Systems/DiseaseData.cs:{
./Systems/DiseaseData.cs:    [System.Serializable]
./Systems/DiseaseData.cs:    public class DiseaseData
./Systems/DiseaseData.cs:    {
./Systems/DiseaseData.cs:        public DiseaseType Type;
./Systems/DiseaseData.cs:        public string Name;
./Systems/DiseaseData.cs:        public float Severity;
./Systems/DiseaseData.cs:        public float RemainingTime;
./Systems/DiseaseData.cs:        public bool IsCured;
./Systems/DiseaseData.cs:
./Systems/DiseaseData.cs:        public DiseaseData(DiseaseType type, string name, float severity, float duration)
./Systems/DiseaseData.cs:        {
./Systems/DiseaseData.cs:            Type = type;
./Systems/DiseaseData.cs:            Name = name;
./Systems/DiseaseData.cs:            Severity = severity;
./Systems/DiseaseData.cs:            RemainingTime = duration;
./Systems/DiseaseData.cs:            IsCured = false;
./Systems/DiseaseData.cs:        }
./Systems/DiseaseData.cs:
./Systems/DiseaseData.cs:        public void Tick(float deltaTime, float rate)
./Systems/DiseaseData.cs:        {
./Systems/DiseaseData.cs:            if (IsCured) return;
./Systems/DiseaseData.cs:            RemainingTime -= deltaTime;
./Systems/DiseaseData.cs:            Severity = Mathf.Clamp01(Severity + rate * deltaTime);
./Systems/DiseaseData.cs:        }
./Systems/DiseaseData.cs:
./Systems/DiseaseData.cs:        public bool TryCure(string itemId, DiseaseConfig config)
./Systems/DiseaseData.cs:        {
./Systems/DiseaseData.cs:            if (IsCured) return false;
./Systems/DiseaseData.cs:            if (config.cureItemIds.Contains(itemId))
./Systems/DiseaseData.cs:            {
./Systems/DiseaseData.cs:                IsCured = true;
./Systems/DiseaseData.cs:                Severity = 0f;
./Systems/DiseaseData.cs:                return true;
./Systems/DiseaseData.cs:            }
./Systems/DiseaseData.cs:            return false;
./Systems/DiseaseData.cs:        }
./Systems/DiseaseData.cs:    }
./Systems/DiseaseData.cs:}
--
./Systems/DiseaseData.cs.meta:fileFormatVersion: 2
./Systems/DiseaseData.cs.meta:guid: ac5fb4f1238540f43b5d5b5ab9da5a18
--
./Systems/DiseaseDefinition.cs:using UnityEngine;
./Systems/DiseaseDefinition.cs:
./Systems/DiseaseDefinition.cs:namespace Gameplay.Disease
./Systems/DiseaseDefinition.cs:{
./Systems/DiseaseDefinition.cs:    [CreateAssetMenu(fileName = "NewDisease", menuName = "Disease System/Disease Definition")]
./Systems/DiseaseDefinition.cs:    public class DiseaseDefinition : ScriptableObject
./Systems/DiseaseDefinition.cs:    {
./Systems/DiseaseDefinition.cs:        public string DiseaseName;
./Systems/DiseaseDefinition.cs:        public string Description;
./Systems/DiseaseDefinition.cs:        public Sprite Icon;
./Systems/DiseaseDefinition.cs:        public float Duration;
./Systems/DiseaseDefinition.cs:        public string[] Symptoms;
./Systems/DiseaseDefinition.cs:        public AudioClip[] SymptomSounds;
./Systems/DiseaseDefinition.cs:    }
./Systems/DiseaseDefinition.cs:}
--
./Systems/DiseaseDefinition.cs.meta:fileFormatVersion: 2
./Systems/DiseaseDefinition.cs.meta:guid: 7d2d374846183794eae873cbe45c33d2
--
./Systems/DiseaseInstance.cs:using System.Collections.Generic;
./Systems/DiseaseInstance.cs:using UnityEngine;
./Systems/DiseaseInstance.cs:
./Systems/DiseaseInstance.cs:namespace Systems.Disease.Runtime
./Systems/DiseaseInstance.cs:{
./Systems/DiseaseInstance.cs:    public class DiseaseInstance
./Systems/DiseaseInstance.cs:    {
./Systems/DiseaseInstance.cs:        public string DiseaseName { get; private set; }
./Systems/DiseaseInstance.cs:        public float Duration { get; private set; }
./Systems/DiseaseInstance.cs:        public float TimeRemaining { get; private set; }
./Systems/DiseaseInstance.cs:
./Systems/DiseaseInstance.cs:        private List<string> symptoms;
./Systems/DiseaseInstance.cs:        private int symptomIndex;
./Systems/DiseaseInstance.cs:
./Systems/DiseaseInstance.cs:        public DiseaseInstance(string name, float duration, List<string> symptomList)
./Systems/DiseaseInstance.cs:        {
./Systems/DiseaseInstance.cs:            DiseaseName = name;
./Systems/DiseaseInstance.cs:            Duration = duration;
./Systems/DiseaseInstance.cs:            TimeRemaining = duration;
./Systems/DiseaseInstance.cs:            symptoms = symptomList;
./Systems/DiseaseInstance.cs:            symptomIndex = 0;
./Systems/DiseaseInstance.cs:        }
./Systems/DiseaseInstance.cs:
./Systems/DiseaseInstance.cs:        public void Tick(float deltaTime)
./Systems/DiseaseInstance.cs:        {
./Systems/DiseaseInstance.cs:            TimeRemaining -= deltaTime;
./Systems/DiseaseInstance.cs:            if (TimeRemaining <= 0f)
./Systems/DiseaseInstance.cs:            {
./Systems/DiseaseInstance.cs:                OnExpired?.Invoke(this);
./Systems/DiseaseInstance.cs:            }
./Systems/DiseaseInstance.cs:        }
./Systems/DiseaseInstance.cs:
./Systems/DiseaseInstance.cs:        public string TriggerNextSymptom()
./Systems/DiseaseInstance.cs:        {
./Systems/DiseaseInstance.cs:            if (symptomIndex >= symptoms.Count) return null;
./Systems/DiseaseInstance.cs:            var symptom = symptoms[symptomIndex];
./Systems/DiseaseInstance.cs:            symptomIndex++;
./Systems/DiseaseInstance.cs:            OnSymptomTriggered?.Invoke(symptom);
./Systems/DiseaseInstance.cs:            return symptom;
./Systems/DiseaseInstance.cs:        }
./Systems/DiseaseInstance.cs:
./Systems/DiseaseInstance.cs:        public bool IsExpired() => TimeRemaining <= 0f;
./Systems/DiseaseInstance.cs:
./Systems/DiseaseInstance.cs:        public event System.Action<string> OnSymptomTriggered;
./Systems/DiseaseInstance.cs:        public event System.Action<DiseaseInstance> OnExpired;
./Systems/DiseaseInstance.cs:    }
./Systems/DiseaseInstance.cs:}
--
./Systems/DiseaseInstance.cs.meta:fileFormatVersion: 2
./Systems/DiseaseInstance.cs.meta:guid: 191798136606bbc42b1d3245aafaff41
--
./Systems/DiseaseManager.cs:﻿using DiseaseSystem;
./Systems/DiseaseManager.cs:using Game.Inventory;
./Systems/DiseaseManager.cs:using System.Collections.Generic;
./Systems/DiseaseManager.cs:using System.Linq;
./Systems/DiseaseManager.cs:using UnityEngine;
./Systems/DiseaseManager.cs:using UI.HUD;
./Systems/DiseaseManager.cs:using Audio.Effects;
./Systems/DiseaseManager.cs:using Game.Status.Models;
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:namespace Game.Status
./Systems/DiseaseManager.cs:{
./Systems/DiseaseManager.cs:    [AddComponentMenu("Status/Disease Manager")]
./Systems/DiseaseManager.cs:    public class DiseaseManager : MonoBehaviour
./Systems/DiseaseManager.cs:    {
./Systems/DiseaseManager.cs:        [Header("Disease Settings")]
./Systems/DiseaseManager.cs:        [Tooltip("Database holding all disease configurations")]
./Systems/DiseaseManager.cs:        [SerializeField] private DiseaseDatabase diseaseDatabase;
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:        [Tooltip("Current active disease instances")]
./Systems/DiseaseManager.cs:        [SerializeField] private List<DiseaseData> activeDiseases = new();
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:        // 📣 Events
./Systems/DiseaseManager.cs:        public static event System.Action<DiseaseType> OnDiseaseContracted;
./Systems/DiseaseManager.cs:        public static event System.Action<DiseaseType> OnDiseaseCured;
./Systems/DiseaseManager.cs:        public static event System.Action<DiseaseType, float> OnDiseaseProgressed;
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:        // 🧪 Attempt infection
./Systems/DiseaseManager.cs:        public void TryContractDisease(DiseaseType type, float resistance)
./Systems/DiseaseManager.cs:        {
./Systems/DiseaseManager.cs:            if (HasDisease(type)) return;
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:            var config = diseaseDatabase?.GetConfig(type);
./Systems/DiseaseManager.cs:            if (config == null)
./Systems/DiseaseManager.cs:            {
./Systems/DiseaseManager.cs:                Debug.LogWarning($"[DiseaseManager] No config found for disease: {type}");
./Systems/DiseaseManager.cs:                return;
./Systems/DiseaseManager.cs:            }
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:            float finalChance = config.infectionChance * (1f - GetImmunityChance(resistance));
./Systems/DiseaseManager.cs:            if (Random.value < finalChance)
./Systems/DiseaseManager.cs:                ApplyDisease(type);
./Systems/DiseaseManager.cs:        }
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:        // 🩺 Infection status check
./Systems/DiseaseManager.cs:        private bool HasDisease(DiseaseType type) =>
./Systems/DiseaseManager.cs:            activeDiseases.Any(d => d.Type == type && !d.IsCured);
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:        // 🛡️ Immunity calculation
./Systems/DiseaseManager.cs:        private float GetImmunityChance(float resistance)
./Systems/DiseaseManager.cs:        {
./Systems/DiseaseManager.cs:            float normalized = Mathf.Clamp01(resistance / 100f);
./Systems/DiseaseManager.cs:            return Mathf.Lerp(0.75f, 0f, normalized);
./Systems/DiseaseManager.cs:        }
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:        // 💉 Disease application
./Systems/DiseaseManager.cs:        private void ApplyDisease(DiseaseType type)
./Systems/DiseaseManager.cs:        {
./Systems/DiseaseManager.cs:            var name = diseaseDatabase?.GetName(type);
./Systems/DiseaseManager.cs:            var disease = new DiseaseData(type, name, 0.25f, 60f);
./Systems/DiseaseManager.cs:            activeDiseases.Add(disease);
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:            DiseaseHUD.ShowSymptoms(type);
./Systems/DiseaseManager.cs:            DiseaseAudioController.PlaySymptoms(type);
./Systems/DiseaseManager.cs:            VitalsManager.ApplyDiseaseEffect(type, disease.Severity);
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:            OnDiseaseContracted?.Invoke(type);
./Systems/DiseaseManager.cs:            Debug.Log($"[DiseaseManager] Contracted disease: {type}");
./Systems/DiseaseManager.cs:        }
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:        // ⏳ Progress update
./Systems/DiseaseManager.cs:        public void UpdateDiseases(float deltaTime, float progressionRate = 0.01f)
./Systems/DiseaseManager.cs:        {
./Systems/DiseaseManager.cs:            foreach (var disease in activeDiseases.Where(d => !d.IsCured))
./Systems/DiseaseManager.cs:            {
./Systems/DiseaseManager.cs:                disease.Tick(deltaTime, progressionRate);
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:                VitalsManager.ApplyDiseaseEffect(disease.Type, disease.Severity);
./Systems/DiseaseManager.cs:                OnDiseaseProgressed?.Invoke(disease.Type, disease.Severity);
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:                if (disease.Severity >= 1f)
./Systems/DiseaseManager.cs:                {
./Systems/DiseaseManager.cs:                    DiseaseHUD.ShowCriticalSymptoms(disease.Type);
./Systems/DiseaseManager.cs:                    DiseaseAudioController.PlayCriticalSymptoms(disease.Type);
./Systems/DiseaseManager.cs:                    DeathHandler.TriggerDeath("Disease: " + disease.Name);
./Systems/DiseaseManager.cs:                }
./Systems/DiseaseManager.cs:            }
./Systems/DiseaseManager.cs:        }
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:        // 🧪 Attempt cure
./Systems/DiseaseManager.cs:        public bool TryCureDisease(DiseaseType type, string itemId)
./Systems/DiseaseManager.cs:        {
./Systems/DiseaseManager.cs:            var instance = activeDiseases.FirstOrDefault(d => d.Type == type && !d.IsCured);
./Systems/DiseaseManager.cs:            if (instance == null) return false;
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:            var config = diseaseDatabase?.GetConfig(type);
./Systems/DiseaseManager.cs:            if (config == null) return false;
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:            if (instance.TryCure(itemId, config))
./Systems/DiseaseManager.cs:            {
./Systems/DiseaseManager.cs:                VitalsManager.RemoveDiseaseEffect(type);
./Systems/DiseaseManager.cs:                DiseaseHUD.HideSymptoms(type);
./Systems/DiseaseManager.cs:                DiseaseAudioController.StopSymptoms(type);
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:                OnDiseaseCured?.Invoke(type);
./Systems/DiseaseManager.cs:                Debug.Log($"[DiseaseManager] Cured disease: {type} using item: {itemId}");
./Systems/DiseaseManager.cs:                return true;
./Systems/DiseaseManager.cs:            }
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:            return false;
./Systems/DiseaseManager.cs:        }
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:        // 📋 Get status summary
./Systems/DiseaseManager.cs:        public List<string> GetDiseaseStatusSummaries() =>
./Systems/DiseaseManager.cs:            activeDiseases.Select(d => $"{d.Type} — Severity: {d.Severity:F2}, Duration: {d.RemainingTime:F0}s").ToList();
./Systems/DiseaseManager.cs:
./Systems/DiseaseManager.cs:        // 🦠 Get all active types
./Systems/DiseaseManager.cs:        public List<DiseaseType> GetActiveDiseaseTypes() =>
./Systems/DiseaseManager.cs:            activeDiseases.Where(d => !d.IsCured).Select(d => d.Type).ToList();
./Systems/DiseaseManager.cs:    }
./Systems/DiseaseManager.cs:}
--
./Systems/DiseaseManager.cs.meta:fileFormatVersion: 2
./Systems/DiseaseManager.cs.meta:guid: 6ea0c7e37a9d40d4db479f5b496b10e3
--
./Systems/DiseaseRegistry.cs:using System.Collections.Generic;
./Systems/DiseaseRegistry.cs:using UnityEngine;
./Systems/DiseaseRegistry.cs:
./Systems/DiseaseRegistry.cs:namespace Gameplay.Disease
./Systems/DiseaseRegistry.cs:{
./Systems/DiseaseRegistry.cs:    public static class DiseaseRegistry
./Systems/DiseaseRegistry.cs:    {
./Systems/DiseaseRegistry.cs:        private static Dictionary<string, DiseaseDefinition> _diseaseMap;
./Systems/DiseaseRegistry.cs:
./Systems/DiseaseRegistry.cs:        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
./Systems/DiseaseRegistry.cs:        public static void Initialize()
./Systems/DiseaseRegistry.cs:        {
./Systems/DiseaseRegistry.cs:            _diseaseMap = new Dictionary<string, DiseaseDefinition>();
./Systems/DiseaseRegistry.cs:            var allDefinitions = Resources.LoadAll<DiseaseDefinition>("DiseaseDefinitions");
./Systems/DiseaseRegistry.cs:
./Systems/DiseaseRegistry.cs:            foreach (var def in allDefinitions)
./Systems/DiseaseRegistry.cs:            {
./Systems/DiseaseRegistry.cs:                if (!_diseaseMap.ContainsKey(def.DiseaseName))
./Systems/DiseaseRegistry.cs:                    _diseaseMap.Add(def.DiseaseName, def);
./Systems/DiseaseRegistry.cs:            }
./Systems/DiseaseRegistry.cs:        }
./Systems/DiseaseRegistry.cs:
./Systems/DiseaseRegistry.cs:        public static DiseaseDefinition Get(string name)
./Systems/DiseaseRegistry.cs:        {
./Systems/DiseaseRegistry.cs:            if (_diseaseMap == null)
./Systems/DiseaseRegistry.cs:                Initialize();
./Systems/DiseaseRegistry.cs:
./Systems/DiseaseRegistry.cs:            _diseaseMap.TryGetValue(name, out var result);
./Systems/DiseaseRegistry.cs:            return result;
./Systems/DiseaseRegistry.cs:        }
./Systems/DiseaseRegistry.cs:
./Systems/DiseaseRegistry.cs:        public static IEnumerable<DiseaseDefinition> GetAll()
./Systems/DiseaseRegistry.cs:        {
./Systems/DiseaseRegistry.cs:            if (_diseaseMap == null)
./Systems/DiseaseRegistry.cs:                Initialize();
./Systems/DiseaseRegistry.cs:
./Systems/DiseaseRegistry.cs:            return _diseaseMap.Values;
./Systems/DiseaseRegistry.cs:        }
./Systems/DiseaseRegistry.cs:    }
./Systems/DiseaseRegistry.cs:}
--
./Systems/DiseaseRegistry.cs.meta:fileFormatVersion: 2
./Systems/DiseaseRegistry.cs.meta:guid: 61d6759a415ea404bb5994647b2c1b89
--
./Systems/DiseaseSettings.cs:using UnityEngine;
./Systems/DiseaseSettings.cs:
./Systems/DiseaseSettings.cs:namespace Systems.Disease.Config
./Systems/DiseaseSettings.cs:{
./Systems/DiseaseSettings.cs:    [CreateAssetMenu(fileName = "DiseaseSettings", menuName = "Disease System/Settings")]
./Systems/DiseaseSettings.cs:    public class DiseaseSettings : ScriptableObject
./Systems/DiseaseSettings.cs:    {
./Systems/DiseaseSettings.cs:        public float symptomDelay = 5f;
./Systems/DiseaseSettings.cs:        public int maxActiveDiseases = 3;
./Systems/DiseaseSettings.cs:        public bool enableDebugLogs = false;
./Systems/DiseaseSettings.cs:    }
./Systems/DiseaseSettings.cs:}
--
./Systems/DiseaseSettings.cs.meta:fileFormatVersion: 2
./Systems/DiseaseSettings.cs.meta:guid: 7d845893c4d1b7a42b851c520f3cdc10
--
./Systems/FoodStateTracker.cs:using UnityEngine;
./Systems/FoodStateTracker.cs:
./Systems/FoodStateTracker.cs:namespace Survival.Inventory.Food
./Systems/FoodStateTracker.cs:{
./Systems/FoodStateTracker.cs:    public class FoodStateTracker : MonoBehaviour
./Systems/FoodStateTracker.cs:    {
./Systems/FoodStateTracker.cs:        [Header("Temperature Settings")]
./Systems/FoodStateTracker.cs:        [SerializeField] private float currentTemperature = 100f;
./Systems/FoodStateTracker.cs:        [SerializeField] private float hotThreshold = 60f;
./Systems/FoodStateTracker.cs:
./Systems/FoodStateTracker.cs:        public bool IsHot => currentTemperature >= hotThreshold;
./Systems/FoodStateTracker.cs:
./Systems/FoodStateTracker.cs:        public void SetTemperature(float value)
./Systems/FoodStateTracker.cs:        {
./Systems/FoodStateTracker.cs:            currentTemperature = value;
./Systems/FoodStateTracker.cs:        }
./Systems/FoodStateTracker.cs:
./Systems/FoodStateTracker.cs:        public void AdjustTemperature(float delta)
./Systems/FoodStateTracker.cs:        {
./Systems/FoodStateTracker.cs:            currentTemperature += delta;
./Systems/FoodStateTracker.cs:        }
./Systems/FoodStateTracker.cs:
./Systems/FoodStateTracker.cs:        public void ResetTemperature()
./Systems/FoodStateTracker.cs:        {
./Systems/FoodStateTracker.cs:            currentTemperature = 100f;
./Systems/FoodStateTracker.cs:        }
./Systems/FoodStateTracker.cs:    }
./Systems/FoodStateTracker.cs:}
--
./Systems/FoodStateTracker.cs.meta:fileFormatVersion: 2
./Systems/FoodStateTracker.cs.meta:guid: 28f18314b50642943b0348c5aa168f0a
--
./Systems/FoodTemperatureManager.cs:using UnityEngine;
./Systems/FoodTemperatureManager.cs:using Survival.Inventory.Food;
./Systems/FoodTemperatureManager.cs:using Survival.Environment.Temperature;
./Systems/FoodTemperatureManager.cs:using Survival.Stats.Modifiers;
./Systems/FoodTemperatureManager.cs:
./Systems/FoodTemperatureManager.cs:namespace Survival.Inventory.Food.Controllers
./Systems/FoodTemperatureManager.cs:{
./Systems/FoodTemperatureManager.cs:    public class FoodTemperatureManager : MonoBehaviour
./Systems/FoodTemperatureManager.cs:    {
./Systems/FoodTemperatureManager.cs:        private FoodStateTracker foodState;
./Systems/FoodTemperatureManager.cs:        private TemperatureDecay decay;
./Systems/FoodTemperatureManager.cs:        private HeatBonusApplier bonus;
./Systems/FoodTemperatureManager.cs:
./Systems/FoodTemperatureManager.cs:        [Header("Debug Settings")]
./Systems/FoodTemperatureManager.cs:        [SerializeField] private bool applyBonusOnStart;
./Systems/FoodTemperatureManager.cs:        [SerializeField] private bool logStateOnStart;
./Systems/FoodTemperatureManager.cs:
./Systems/FoodTemperatureManager.cs:        private void Awake()
./Systems/FoodTemperatureManager.cs:        {
./Systems/FoodTemperatureManager.cs:            foodState = GetComponent<FoodStateTracker>();
./Systems/FoodTemperatureManager.cs:            decay = GetComponent<TemperatureDecay>();
./Systems/FoodTemperatureManager.cs:            bonus = GetComponent<HeatBonusApplier>();
./Systems/FoodTemperatureManager.cs:        }
./Systems/FoodTemperatureManager.cs:
./Systems/FoodTemperatureManager.cs:        private void Start()
./Systems/FoodTemperatureManager.cs:        {
./Systems/FoodTemperatureManager.cs:            if (logStateOnStart)
./Systems/FoodTemperatureManager.cs:            {
./Systems/FoodTemperatureManager.cs:                Debug.Log($"[FoodTemperatureManager] IsHot: {foodState?.IsHot}");
./Systems/FoodTemperatureManager.cs:            }
./Systems/FoodTemperatureManager.cs:
./Systems/FoodTemperatureManager.cs:            if (applyBonusOnStart && foodState?.IsHot == true)
./Systems/FoodTemperatureManager.cs:            {
./Systems/FoodTemperatureManager.cs:                bonus?.ApplyBonus();
./Systems/FoodTemperatureManager.cs:            }
./Systems/FoodTemperatureManager.cs:        }
./Systems/FoodTemperatureManager.cs:
./Systems/FoodTemperatureManager.cs:        public void Consume()
./Systems/FoodTemperatureManager.cs:        {
./Systems/FoodTemperatureManager.cs:            if (foodState != null && foodState.IsHot)
./Systems/FoodTemperatureManager.cs:            {
--
./Systems/FoodTemperatureManager.cs:                bonus?.ApplyBonus();
./Systems/FoodTemperatureManager.cs:            }
./Systems/FoodTemperatureManager.cs:            else
./Systems/FoodTemperatureManager.cs:            {
--
./Systems/FoodTemperatureManager.cs:            }
./Systems/FoodTemperatureManager.cs:        }
./Systems/FoodTemperatureManager.cs:    }
./Systems/FoodTemperatureManager.cs:}
Binary file ./Systems/FoodTemperatureManager.cs matches
--
./Systems/FoodTemperatureManager.cs.meta:fileFormatVersion: 2
./Systems/FoodTemperatureManager.cs.meta:guid: 6872b35e45624464e82ad02a0ab7ffaa
--
./Systems/GameCoordinator.cs:using Survival.Audio;
./Systems/GameCoordinator.cs:using Survival.Audio.Playback;
./Systems/GameCoordinator.cs:using Survival.Core.Scene;
./Systems/GameCoordinator.cs:using Survival.Core.State;
./Systems/GameCoordinator.cs:using Survival.Core.Time;
./Systems/GameCoordinator.cs:using Survival.UI.Pause;
./Systems/GameCoordinator.cs:using UnityEngine;
./Systems/GameCoordinator.cs:using UnityEngine.SceneManagement;
./Systems/GameCoordinator.cs:
./Systems/GameCoordinator.cs:namespace Survival.Core.Game
./Systems/GameCoordinator.cs:{
./Systems/GameCoordinator.cs:    public class GameCoordinator : MonoBehaviour
./Systems/GameCoordinator.cs:    {
./Systems/GameCoordinator.cs:        [Header("State")]
./Systems/GameCoordinator.cs:        [SerializeField] private GameStateTracker stateTracker;
./Systems/GameCoordinator.cs:        [SerializeField] private TimeManager timeManager;
./Systems/GameCoordinator.cs:
./Systems/GameCoordinator.cs:        [Header("Scene")]
./Systems/GameCoordinator.cs:        [SerializeField] private SceneLoader sceneLoader;
./Systems/GameCoordinator.cs:
./Systems/GameCoordinator.cs:        [Header("Audio")]
./Systems/GameCoordinator.cs:        [SerializeField] private AudioCuePlayer audioPlayer;
./Systems/GameCoordinator.cs:        [SerializeField] private AudioCue pauseCue;
./Systems/GameCoordinator.cs:        [SerializeField] private AudioCue resumeCue;
./Systems/GameCoordinator.cs:
./Systems/GameCoordinator.cs:        [Header("UI")]
./Systems/GameCoordinator.cs:        [SerializeField] private PauseController pauseController;
./Systems/GameCoordinator.cs:
./Systems/GameCoordinator.cs:        private bool isPaused;
./Systems/GameCoordinator.cs:
./Systems/GameCoordinator.cs:        private void Awake()
./Systems/GameCoordinator.cs:        {
./Systems/GameCoordinator.cs:            if (stateTracker == null) stateTracker = FindObjectOfType<GameStateTracker>();
./Systems/GameCoordinator.cs:            if (timeManager == null) timeManager = FindObjectOfType<TimeManager>();
./Systems/GameCoordinator.cs:            if (sceneLoader == null) sceneLoader = FindObjectOfType<SceneLoader>();
./Systems/GameCoordinator.cs:            if (pauseController == null) pauseController = FindObjectOfType<PauseController>();
./Systems/GameCoordinator.cs:            if (audioPlayer == null) audioPlayer = FindObjectOfType<AudioCuePlayer>();
./Systems/GameCoordinator.cs:        }
./Systems/GameCoordinator.cs:
./Systems/GameCoordinator.cs:        private void Update()
./Systems/GameCoordinator.cs:        {
./Systems/GameCoordinator.cs:            if (Input.GetKeyDown(KeyCode.Escape))
./Systems/GameCoordinator.cs:            {
./Systems/GameCoordinator.cs:                TogglePause();
./Systems/GameCoordinator.cs:            }
./Systems/GameCoordinator.cs:        }
./Systems/GameCoordinator.cs:
./Systems/GameCoordinator.cs:        public void TogglePause()
./Systems/GameCoordinator.cs:        {
./Systems/GameCoordinator.cs:            isPaused = !isPaused;
./Systems/GameCoordinator.cs:            timeManager.SetPaused(isPaused);
./Systems/GameCoordinator.cs:            pauseController.SetVisible(isPaused);
./Systems/GameCoordinator.cs:
./Systems/GameCoordinator.cs:            var cue = isPaused ? pauseCue : resumeCue;
./Systems/GameCoordinator.cs:            audioPlayer.PlayCue(cue);
./Systems/GameCoordinator.cs:
./Systems/GameCoordinator.cs:            stateTracker.SetState(isPaused ? GameState.Paused : GameState.Playing);
./Systems/GameCoordinator.cs:        }
./Systems/GameCoordinator.cs:
./Systems/GameCoordinator.cs:        public void TriggerGameOver()
./Systems/GameCoordinator.cs:        {
./Systems/GameCoordinator.cs:            stateTracker.SetState(GameState.GameOver);
./Systems/GameCoordinator.cs:            timeManager.SetPaused(true);
./Systems/GameCoordinator.cs:            pauseController.ShowGameOverUI();
./Systems/GameCoordinator.cs:            audioPlayer.PlayCue(AudioCue.GameOver);
./Systems/GameCoordinator.cs:        }
./Systems/GameCoordinator.cs:
./Systems/GameCoordinator.cs:        public void LoadScene(string sceneName)
./Systems/GameCoordinator.cs:        {
./Systems/GameCoordinator.cs:            sceneLoader.LoadSceneAsync(sceneName);
./Systems/GameCoordinator.cs:        }
./Systems/GameCoordinator.cs:    }
./Systems/GameCoordinator.cs:}
--
./Systems/GameCoordinator.cs.meta:fileFormatVersion: 2
./Systems/GameCoordinator.cs.meta:guid: fdecdde9c6125394fb224f166a209eda
--
./Systems/GameStateService.cs:using UnityEngine;
./Systems/GameStateService.cs:
./Systems/GameStateService.cs:namespace Survival.Core.State
./Systems/GameStateService.cs:{
./Systems/GameStateService.cs:    public class GameStateService : MonoBehaviour
./Systems/GameStateService.cs:    {
./Systems/GameStateService.cs:        public static GameStateService Instance;
./Systems/GameStateService.cs:
./Systems/GameStateService.cs:        public GameStateFlags Flags { get; private set; }
./Systems/GameStateService.cs:
./Systems/GameStateService.cs:        private void Awake()
./Systems/GameStateService.cs:        {
./Systems/GameStateService.cs:            Instance = this;
./Systems/GameStateService.cs:            Flags = new GameStateFlags();
./Systems/GameStateService.cs:        }
./Systems/GameStateService.cs:
./Systems/GameStateService.cs:        public void SetPaused(bool value) => Flags.isPaused = value;
./Systems/GameStateService.cs:        public void SetCombat(bool value) => Flags.isInCombat = value;
./Systems/GameStateService.cs:        public void SetGameOver(bool value) => Flags.isGameOver = value;
./Systems/GameStateService.cs:    }
./Systems/GameStateService.cs:}
--
./Systems/GameStateService.cs.meta:fileFormatVersion: 2
./Systems/GameStateService.cs.meta:guid: 90301cd75e6d8e4428de5d6ad166a3bf
--
./Systems/GearSlotRegistry.cs:using UnityEngine;
./Systems/GearSlotRegistry.cs:using System.Collections.Generic;
./Systems/GearSlotRegistry.cs:using Inventory.DataModels;
./Systems/GearSlotRegistry.cs:using UI.Inventory;
./Systems/GearSlotRegistry.cs:
./Systems/GearSlotRegistry.cs:namespace Systems.Equipment
./Systems/GearSlotRegistry.cs:{
./Systems/GearSlotRegistry.cs:    public class GearSlotRegistry : MonoBehaviour
./Systems/GearSlotRegistry.cs:    {
./Systems/GearSlotRegistry.cs:        private Dictionary<GearType, GearSlotUI> slotMap = new();
./Systems/GearSlotRegistry.cs:
./Systems/GearSlotRegistry.cs:        void Awake()
./Systems/GearSlotRegistry.cs:        {
./Systems/GearSlotRegistry.cs:            foreach (var slot in FindObjectsByType<GearSlotUI>(FindObjectsSortMode.None))
./Systems/GearSlotRegistry.cs:            {
./Systems/GearSlotRegistry.cs:                if (!slotMap.ContainsKey(slot.type))
./Systems/GearSlotRegistry.cs:                    slotMap.Add(slot.type, slot);
./Systems/GearSlotRegistry.cs:            }
./Systems/GearSlotRegistry.cs:        }
./Systems/GearSlotRegistry.cs:
./Systems/GearSlotRegistry.cs:        public void AssignGear(GearData gear)
./Systems/GearSlotRegistry.cs:        {
./Systems/GearSlotRegistry.cs:            if (slotMap.TryGetValue(gear.type, out var slot))
./Systems/GearSlotRegistry.cs:                slot.SetGear(gear);
./Systems/GearSlotRegistry.cs:        }
./Systems/GearSlotRegistry.cs:
./Systems/GearSlotRegistry.cs:        public void ClearAll()
./Systems/GearSlotRegistry.cs:        {
./Systems/GearSlotRegistry.cs:            foreach (var slot in slotMap.Values)
./Systems/GearSlotRegistry.cs:                slot.ClearSlot();
./Systems/GearSlotRegistry.cs:        }
./Systems/GearSlotRegistry.cs:
./Systems/GearSlotRegistry.cs:        public Dictionary<GearType, GearData> GetEquippedGear()
./Systems/GearSlotRegistry.cs:        {
./Systems/GearSlotRegistry.cs:            var result = new Dictionary<GearType, GearData>();
./Systems/GearSlotRegistry.cs:            foreach (var kvp in slotMap)
./Systems/GearSlotRegistry.cs:            {
./Systems/GearSlotRegistry.cs:                if (kvp.Value.HasGear())
./Systems/GearSlotRegistry.cs:                    result.Add(kvp.Key, kvp.Value.GetGear());
./Systems/GearSlotRegistry.cs:            }
./Systems/GearSlotRegistry.cs:            return result;
./Systems/GearSlotRegistry.cs:        }
./Systems/GearSlotRegistry.cs:    }
./Systems/GearSlotRegistry.cs:}
--
./Systems/GearSlotRegistry.cs.meta:fileFormatVersion: 2
./Systems/GearSlotRegistry.cs.meta:guid: 1536927f291fb0641b7b055dfed18b9d
--
./Systems/GearTransferService.cs:using UnityEngine;
./Systems/GearTransferService.cs:using Inventory.DataModels;
./Systems/GearTransferService.cs:using Systems.Equipment;
./Systems/GearTransferService.cs:using Tools.Events;
./Systems/GearTransferService.cs:
./Systems/GearTransferService.cs:public class GearTransferService : MonoBehaviour
./Systems/GearTransferService.cs:{
./Systems/GearTransferService.cs:    public enum TransferType { Equip, Drop, Give, Store }
./Systems/GearTransferService.cs:
./Systems/GearTransferService.cs:    public float transferCooldown = 0.5f;
./Systems/GearTransferService.cs:    private float lastTransferTime;
./Systems/GearTransferService.cs:
./Systems/GearTransferService.cs:    public GearEvents gearEvents;
./Systems/GearTransferService.cs:
./Systems/GearTransferService.cs:    public bool CanTransfer(GearData gear)
./Systems/GearTransferService.cs:    {
./Systems/GearTransferService.cs:        return gear != null && Time.time > lastTransferTime + transferCooldown;
./Systems/GearTransferService.cs:    }
./Systems/GearTransferService.cs:
./Systems/GearTransferService.cs:    public bool TransferGear(GearData gear, TransferType type)
./Systems/GearTransferService.cs:    {
./Systems/GearTransferService.cs:        if (!CanTransfer(gear)) return false;
./Systems/GearTransferService.cs:
./Systems/GearTransferService.cs:        GearSlotUI targetSlot = GetTransferTarget(gear, type);
./Systems/GearTransferService.cs:        if (targetSlot == null) return false;
./Systems/GearTransferService.cs:
./Systems/GearTransferService.cs:        targetSlot.SetGear(gear);
./Systems/GearTransferService.cs:        lastTransferTime = Time.time;
./Systems/GearTransferService.cs:
./Systems/GearTransferService.cs:        gearEvents?.OnTransferComplete?.Invoke(gear, type);
./Systems/GearTransferService.cs:        return true;
./Systems/GearTransferService.cs:    }
./Systems/GearTransferService.cs:
./Systems/GearTransferService.cs:    private GearSlotUI GetTransferTarget(GearData gear, TransferType type)
./Systems/GearTransferService.cs:    {
--
./Systems/GearTransferService.cs:        switch (type)
./Systems/GearTransferService.cs:        {
./Systems/GearTransferService.cs:            case TransferType.Equip: return GearSlotRegistry.Instance.GetSlot(gear.type);
./Systems/GearTransferService.cs:            case TransferType.Drop: return null; // Drop to world
./Systems/GearTransferService.cs:            case TransferType.Give: return GearSlotRegistry.Instance.GetAllySlot(gear.type);
./Systems/GearTransferService.cs:            case TransferType.Store: return GearSlotRegistry.Instance.GetStorageSlot(gear.type);
./Systems/GearTransferService.cs:            default: return null;
./Systems/GearTransferService.cs:        }
./Systems/GearTransferService.cs:    }
./Systems/GearTransferService.cs:}
Binary file ./Systems/GearTransferService.cs matches
--
./Systems/GearTransferService.cs.meta:fileFormatVersion: 2
./Systems/GearTransferService.cs.meta:guid: db5517a9b03502f469346406b5cba61a
--
./Systems/HeatBonusApplier.cs:using UnityEngine;
./Systems/HeatBonusApplier.cs:
./Systems/HeatBonusApplier.cs:namespace Survival.Stats.Modifiers
./Systems/HeatBonusApplier.cs:{
./Systems/HeatBonusApplier.cs:    public class HeatBonusApplier : MonoBehaviour
./Systems/HeatBonusApplier.cs:    {
./Systems/HeatBonusApplier.cs:        [Header("Buff Settings")]
./Systems/HeatBonusApplier.cs:        [SerializeField] private float staminaBoost = 10f;
./Systems/HeatBonusApplier.cs:        [SerializeField] private float duration = 30f;
./Systems/HeatBonusApplier.cs:
./Systems/HeatBonusApplier.cs:        public void ApplyBonus()
./Systems/HeatBonusApplier.cs:        {
./Systems/HeatBonusApplier.cs:            // TODO: Replace with actual stat system integration
./Systems/HeatBonusApplier.cs:            Debug.Log($"Applied hot food bonus: +{staminaBoost} stamina for {duration} seconds.");
./Systems/HeatBonusApplier.cs:        }
./Systems/HeatBonusApplier.cs:    }
./Systems/HeatBonusApplier.cs:}
--
./Systems/HeatBonusApplier.cs.meta:fileFormatVersion: 2
./Systems/HeatBonusApplier.cs.meta:guid: 803989af95d0ff74e964280b0d9ce8ca
--
./Systems/IntroFlowController.cs:// File: Assets/Scripts/Systems/IntroFlowController.cs
./Systems/IntroFlowController.cs:using UnityEngine;
./Systems/IntroFlowController.cs:using UnityEngine.Events;
./Systems/IntroFlowController.cs:
./Systems/IntroFlowController.cs:namespace Game.Systems
./Systems/IntroFlowController.cs:{
./Systems/IntroFlowController.cs:    public class IntroFlowController : MonoBehaviour
./Systems/IntroFlowController.cs:    {
./Systems/IntroFlowController.cs:        [SerializeField] private UnityEvent onIntroComplete;
./Systems/IntroFlowController.cs:
./Systems/IntroFlowController.cs:        public void BeginIntroSequence()
./Systems/IntroFlowController.cs:        {
./Systems/IntroFlowController.cs:            // Play splash, load scene, run Yarn dialogue, etc.
./Systems/IntroFlowController.cs:            Debug.Log("[IntroFlowController] Intro started.");
./Systems/IntroFlowController.cs:            Invoke(nameof(EndIntroSequence), 5f); // placeholder timing
./Systems/IntroFlowController.cs:        }
./Systems/IntroFlowController.cs:
./Systems/IntroFlowController.cs:        private void EndIntroSequence()
./Systems/IntroFlowController.cs:        {
./Systems/IntroFlowController.cs:            onIntroComplete.Invoke();
./Systems/IntroFlowController.cs:            Debug.Log("[IntroFlowController] Intro complete.");
./Systems/IntroFlowController.cs:        }
./Systems/IntroFlowController.cs:    }
./Systems/IntroFlowController.cs:}
--
./Systems/IntroFlowController.cs.meta:fileFormatVersion: 2
./Systems/IntroFlowController.cs.meta:guid: 6e4c4158c03ba7d4383d7e5934bc81d4
--
./Systems/InventoryEnums.cs:namespace Survival.Inventory
./Systems/InventoryEnums.cs:{
./Systems/InventoryEnums.cs:    public enum ItemType { Food, Tool, Weapon, Medical, Clothing, Misc }
./Systems/InventoryEnums.cs:    public enum ItemRarity { Common, Uncommon, Rare, Epic, Legendary }
./Systems/InventoryEnums.cs:    public enum ItemSlot { Head, Body, Legs, Feet, Hands, Back, Pocket }
./Systems/InventoryEnums.cs:}
--
./Systems/InventoryEnums.cs.meta:fileFormatVersion: 2
./Systems/InventoryEnums.cs.meta:guid: 4c3b1e6fff8ac0e4da104c818136ba1b
--
./Systems/InventoryUIUpdater.cs:using UnityEngine;
./Systems/InventoryUIUpdater.cs:// Stubs added to avoid missing references during compile
./Systems/InventoryUIUpdater.cs:namespace Inventory { public static class Manager { } }
./Systems/InventoryUIUpdater.cs:namespace CampData { public class CampState { } }
./Systems/InventoryUIUpdater.cs:
./Systems/InventoryUIUpdater.cs:namespace Systems
./Systems/InventoryUIUpdater.cs:{
./Systems/InventoryUIUpdater.cs:    public static class InventoryUIUpdater
./Systems/InventoryUIUpdater.cs:    {
./Systems/InventoryUIUpdater.cs:        // Removed unused parameters 'panels' and 'containers'
./Systems/InventoryUIUpdater.cs:        public static void RefreshAll()
./Systems/InventoryUIUpdater.cs:        {
./Systems/InventoryUIUpdater.cs:            // TODO: Hook into Inventory.Manager when implemented
./Systems/InventoryUIUpdater.cs:            // TODO: Use CampData.CampState for inventory context once available
./Systems/InventoryUIUpdater.cs:
./Systems/InventoryUIUpdater.cs:            // Example placeholder logic
./Systems/InventoryUIUpdater.cs:            Debug.Log("Inventory UI refresh triggered.");
./Systems/InventoryUIUpdater.cs:        }
./Systems/InventoryUIUpdater.cs:    }
./Systems/InventoryUIUpdater.cs:}
--
./Systems/InventoryUIUpdater.cs.meta:fileFormatVersion: 2
./Systems/InventoryUIUpdater.cs.meta:guid: f4a532265a7930642b6dd2702e32aab4
--
./Systems/JsonTestLoader.cs:﻿using UnityEngine;
./Systems/JsonTestLoader.cs:using Systems.Serialization;
./Systems/JsonTestLoader.cs:using Tools.Paths;
./Systems/JsonTestLoader.cs:using Tools.Diagnostics;
./Systems/JsonTestLoader.cs:using DataModels;
./Systems/JsonTestLoader.cs:
./Systems/JsonTestLoader.cs:public class JsonTestLoader : MonoBehaviour
./Systems/JsonTestLoader.cs:{
./Systems/JsonTestLoader.cs:    void Start()
./Systems/JsonTestLoader.cs:    {
./Systems/JsonTestLoader.cs:        string path = PathResolver.StreamingAssets("test.json");
./Systems/JsonTestLoader.cs:        string json = JsonLoader.Load(path);
./Systems/JsonTestLoader.cs:
./Systems/JsonTestLoader.cs:        if (string.IsNullOrEmpty(json))
./Systems/JsonTestLoader.cs:        {
./Systems/JsonTestLoader.cs:            DebugLogger.Warn("Test JSON is empty or missing.");
./Systems/JsonTestLoader.cs:            return;
./Systems/JsonTestLoader.cs:        }
./Systems/JsonTestLoader.cs:
./Systems/JsonTestLoader.cs:        TestData data = JsonDeserializer.FromJson<TestData>(json);
./Systems/JsonTestLoader.cs:        DebugLogger.Info($"Loaded TestData: {data.name}, {data.description}, {data.value}");
./Systems/JsonTestLoader.cs:    }
./Systems/JsonTestLoader.cs:}
--
./Systems/JsonTestLoader.cs.meta:fileFormatVersion: 2
./Systems/JsonTestLoader.cs.meta:guid: 2b2e7b39f2f95a54fa1c43beb856b9da
--
./Systems/PlayerStartupCoordinator.cs:using UnityEngine;
./Systems/PlayerStartupCoordinator.cs:using Survival.Inventory;
./Systems/PlayerStartupCoordinator.cs:using Survival.Stats;
./Systems/PlayerStartupCoordinator.cs:using Survival.UI;
./Systems/PlayerStartupCoordinator.cs:using Survival.Persistence;
./Systems/PlayerStartupCoordinator.cs:
./Systems/PlayerStartupCoordinator.cs:namespace Survival.Player
./Systems/PlayerStartupCoordinator.cs:{
./Systems/PlayerStartupCoordinator.cs:    public class PlayerStartupCoordinator : MonoBehaviour
./Systems/PlayerStartupCoordinator.cs:    {
./Systems/PlayerStartupCoordinator.cs:        private void Start()
./Systems/PlayerStartupCoordinator.cs:        {
./Systems/PlayerStartupCoordinator.cs:            PlayerSpawnManager.SpawnPlayerAtStart();
./Systems/PlayerStartupCoordinator.cs:            InventoryInitializer.LoadDefaultInventory();
./Systems/PlayerStartupCoordinator.cs:            StatInitializer.InitializeStats();
./Systems/PlayerStartupCoordinator.cs:            UIBootstrap.BindPlayerUI();
./Systems/PlayerStartupCoordinator.cs:            // Optional: SaveManager.LoadLastSave(); // only if tightly integrated
./Systems/PlayerStartupCoordinator.cs:        }
./Systems/PlayerStartupCoordinator.cs:    }
./Systems/PlayerStartupCoordinator.cs:}
--
./Systems/PlayerStartupCoordinator.cs.meta:fileFormatVersion: 2
./Systems/PlayerStartupCoordinator.cs.meta:guid: dc96da9cbc5c8ea428a7a605b00f9723
--
./Systems/SaveManager.cs:// File: Assets/Scripts/Systems/SaveManager.cs
./Systems/SaveManager.cs:using UnityEngine;
./Systems/SaveManager.cs:using System.IO;
./Systems/SaveManager.cs:
./Systems/SaveManager.cs:namespace Game.Systems
./Systems/SaveManager.cs:{
./Systems/SaveManager.cs:    public class SaveManager : MonoBehaviour
./Systems/SaveManager.cs:    {
./Systems/SaveManager.cs:        [SerializeField] private Player.PlayerStats playerStats;
./Systems/SaveManager.cs:
./Systems/SaveManager.cs:        private string SavePath => $"{Application.persistentDataPath}/save.json";
./Systems/SaveManager.cs:
./Systems/SaveManager.cs:        public void Save()
./Systems/SaveManager.cs:        {
./Systems/SaveManager.cs:            var json = JsonUtility.ToJson(playerStats);
./Systems/SaveManager.cs:            File.WriteAllText(SavePath, json);
./Systems/SaveManager.cs:            Debug.Log("[SaveManager] Game saved.");
./Systems/SaveManager.cs:        }
./Systems/SaveManager.cs:
./Systems/SaveManager.cs:        public void Load()
./Systems/SaveManager.cs:        {
./Systems/SaveManager.cs:            if (File.Exists(SavePath))
./Systems/SaveManager.cs:            {
./Systems/SaveManager.cs:                var json = File.ReadAllText(SavePath);
./Systems/SaveManager.cs:                JsonUtility.FromJsonOverwrite(json, playerStats);
./Systems/SaveManager.cs:                Debug.Log("[SaveManager] Game loaded.");
./Systems/SaveManager.cs:            }
./Systems/SaveManager.cs:        }
./Systems/SaveManager.cs:    }
./Systems/SaveManager.cs:}
--
./Systems/SaveManager.cs.meta:fileFormatVersion: 2
./Systems/SaveManager.cs.meta:guid: c7b7bc78bac78774b9c4451b87b3c9e6
--
./Systems/StatusEnums.cs:namespace Survival.Status
./Systems/StatusEnums.cs:{
./Systems/StatusEnums.cs:    public enum StatusEffect { Hungry, Thirsty, Sick, Injured, Tired }
./Systems/StatusEnums.cs:    public enum VitalsState { Stable, Declining, Critical, Flatlined }
./Systems/StatusEnums.cs:    public enum ConditionFlag { None, Bleeding, Dehydrated, Infected, Poisoned }
./Systems/StatusEnums.cs:}
--
./Systems/StatusEnums.cs.meta:fileFormatVersion: 2
./Systems/StatusEnums.cs.meta:guid: 03172b9f4ccb6144195a85fdad356907
--
./Systems/StoryPanelBinder.cs:using UnityEngine;
./Systems/StoryPanelBinder.cs:
./Systems/StoryPanelBinder.cs:namespace Systems
./Systems/StoryPanelBinder.cs:{
./Systems/StoryPanelBinder.cs:    public static class StoragePanelBinder
./Systems/StoryPanelBinder.cs:    {
./Systems/StoryPanelBinder.cs:        public static void BindPanelsToContainers(GameObject[] panels, GameObject[] containers)
./Systems/StoryPanelBinder.cs:        {
./Systems/StoryPanelBinder.cs:            // TODO: Link panels with containers
./Systems/StoryPanelBinder.cs:        }
./Systems/StoryPanelBinder.cs:    }
./Systems/StoryPanelBinder.cs:}
--
./Systems/StoryPanelBinder.cs.meta:fileFormatVersion: 2
./Systems/StoryPanelBinder.cs.meta:guid: be406baa5c98e624ca9300800374c767
--
./Systems/Systems.asmdef:{
./Systems/Systems.asmdef:  "name": "Systems",
./Systems/Systems.asmdef:  "references": [
./Systems/Systems.asmdef:    "Player",
./Systems/Systems.asmdef:    "Audio",
./Systems/Systems.asmdef:    "Flags",
./Systems/Systems.asmdef:    "Scene",
./Systems/Systems.asmdef:    "DialogueSystem",
./Systems/Systems.asmdef:    "Core"
./Systems/Systems.asmdef:  ],
./Systems/Systems.asmdef:  "includePlatforms": [],
./Systems/Systems.asmdef:  "excludePlatforms": [],
./Systems/Systems.asmdef:  "allowUnsafeCode": false,
./Systems/Systems.asmdef:  "overrideReferences": false,
./Systems/Systems.asmdef:  "precompiledReferences": [],
./Systems/Systems.asmdef:  "autoReferenced": true,
./Systems/Systems.asmdef:  "defineConstraints": [],
./Systems/Systems.asmdef:  "versionDefines": [],
./Systems/Systems.asmdef:  "noEngineReferences": false
./Systems/Systems.asmdef:}
--
./Systems/Systems.asmdef.meta:fileFormatVersion: 2
./Systems/Systems.asmdef.meta:guid: 01ae4bc5a5437e84ba3650e6bbc5ab7d
./Systems/Systems.asmdef.meta:AssemblyDefinitionImporter:
./Systems/Systems.asmdef.meta:  externalObjects: {}
./Systems/Systems.asmdef.meta:  userData: 
./Systems/Systems.asmdef.meta:  assetBundleName: 
./Systems/Systems.asmdef.meta:  assetBundleVariant: 
--
./Systems/TemperatureDecay.cs:using UnityEngine;
./Systems/TemperatureDecay.cs:
./Systems/TemperatureDecay.cs:namespace Survival.Environment.Temperature
./Systems/TemperatureDecay.cs:{
./Systems/TemperatureDecay.cs:    public class TemperatureDecay : MonoBehaviour
./Systems/TemperatureDecay.cs:    {
./Systems/TemperatureDecay.cs:        [Header("Decay Settings")]
./Systems/TemperatureDecay.cs:        [SerializeField] private float decayRate = 5f;
./Systems/TemperatureDecay.cs:        [SerializeField] private float updateInterval = 1f;
./Systems/TemperatureDecay.cs:
./Systems/TemperatureDecay.cs:        private Survival.Inventory.Food.FoodStateTracker tracker;
./Systems/TemperatureDecay.cs:
./Systems/TemperatureDecay.cs:        private void Awake()
./Systems/TemperatureDecay.cs:        {
./Systems/TemperatureDecay.cs:            tracker = GetComponent<Survival.Inventory.Food.FoodStateTracker>();
./Systems/TemperatureDecay.cs:        }
./Systems/TemperatureDecay.cs:
./Systems/TemperatureDecay.cs:        private void Start()
./Systems/TemperatureDecay.cs:        {
./Systems/TemperatureDecay.cs:            InvokeRepeating(nameof(DecayTemperature), updateInterval, updateInterval);
./Systems/TemperatureDecay.cs:        }
./Systems/TemperatureDecay.cs:
./Systems/TemperatureDecay.cs:        private void DecayTemperature()
./Systems/TemperatureDecay.cs:        {
./Systems/TemperatureDecay.cs:            if (tracker != null)
./Systems/TemperatureDecay.cs:            {
./Systems/TemperatureDecay.cs:                tracker.AdjustTemperature(-decayRate * updateInterval);
./Systems/TemperatureDecay.cs:            }
./Systems/TemperatureDecay.cs:        }
./Systems/TemperatureDecay.cs:    }
./Systems/TemperatureDecay.cs:}
--
./Systems/TemperatureDecay.cs.meta:fileFormatVersion: 2
./Systems/TemperatureDecay.cs.meta:guid: edbf6bb8d447a20418ac8c4f09cc5a4c
--
./Systems.meta:fileFormatVersion: 2
./Systems.meta:guid: d3842ca3e2b4fdb479d5d92e4d13995e
./Systems.meta:folderAsset: yes
./Systems.meta:DefaultImporter:
./Systems.meta:  externalObjects: {}
./Systems.meta:  userData: 
./Systems.meta:  assetBundleName: 
./Systems.meta:  assetBundleVariant: 
--
./UI/CreditsScreenUI.cs:using UnityEngine;
./UI/CreditsScreenUI.cs:using UnityEngine.UI;
./UI/CreditsScreenUI.cs:using TMPro;
./UI/CreditsScreenUI.cs:
./UI/CreditsScreenUI.cs:namespace Survival.UI.TitleScreen
./UI/CreditsScreenUI.cs:{
./UI/CreditsScreenUI.cs:    public class CreditsScreenUI : MonoBehaviour
./UI/CreditsScreenUI.cs:    {
./UI/CreditsScreenUI.cs:        [Header("UI Containers")]
./UI/CreditsScreenUI.cs:        [SerializeField] private GameObject creditsPanel;
./UI/CreditsScreenUI.cs:        [SerializeField] private ScrollRect creditsScroll;
./UI/CreditsScreenUI.cs:
./UI/CreditsScreenUI.cs:        [Header("Content Elements")]
./UI/CreditsScreenUI.cs:        [SerializeField] private TMP_Text projectNameText;
./UI/CreditsScreenUI.cs:        [SerializeField] private TMP_Text contributorsText;
./UI/CreditsScreenUI.cs:        [SerializeField] private TMP_Text toolsUsedText;
./UI/CreditsScreenUI.cs:        [SerializeField] private TMP_Text thanksText;
./UI/CreditsScreenUI.cs:
./UI/CreditsScreenUI.cs:        [Header("Buttons")]
./UI/CreditsScreenUI.cs:        [SerializeField] private Button backButton;
./UI/CreditsScreenUI.cs:
./UI/CreditsScreenUI.cs:        private void Awake()
./UI/CreditsScreenUI.cs:        {
./UI/CreditsScreenUI.cs:            backButton.onClick.AddListener(HideCredits);
./UI/CreditsScreenUI.cs:            PopulateCredits();
./UI/CreditsScreenUI.cs:        }
./UI/CreditsScreenUI.cs:
./UI/CreditsScreenUI.cs:        public void ShowCredits()
./UI/CreditsScreenUI.cs:        {
./UI/CreditsScreenUI.cs:            creditsPanel.SetActive(true);
./UI/CreditsScreenUI.cs:            creditsScroll.verticalNormalizedPosition = 1f; // Start at top
./UI/CreditsScreenUI.cs:        }
./UI/CreditsScreenUI.cs:
./UI/CreditsScreenUI.cs:        private void HideCredits()
./UI/CreditsScreenUI.cs:        {
./UI/CreditsScreenUI.cs:            creditsPanel.SetActive(false);
./UI/CreditsScreenUI.cs:        }
./UI/CreditsScreenUI.cs:
./UI/CreditsScreenUI.cs:        private void PopulateCredits()
./UI/CreditsScreenUI.cs:        {
./UI/CreditsScreenUI.cs:            projectNameText.text = "Wasteland Threads: A Survival Narrative";
./UI/CreditsScreenUI.cs:
./UI/CreditsScreenUI.cs:            contributorsText.text =
./UI/CreditsScreenUI.cs:                "Developer: John (Solo Systems Architect)\n" +
./UI/CreditsScreenUI.cs:                "AI Companion: Microsoft Copilot\n" +
./UI/CreditsScreenUI.cs:                "Special Thanks: The Unity Dev Community\n";
./UI/CreditsScreenUI.cs:
./UI/CreditsScreenUI.cs:            toolsUsedText.text =
./UI/CreditsScreenUI.cs:                "Engine: Unity\n" +
./UI/CreditsScreenUI.cs:                "Editor Tooling: Custom Validators & Migrators\n" +
./UI/CreditsScreenUI.cs:                "DevOps: Gitleaks, Shell Scripts\n";
./UI/CreditsScreenUI.cs:
./UI/CreditsScreenUI.cs:            thanksText.text =
./UI/CreditsScreenUI.cs:                "Thanks for playing! This project was built with care, curiosity, and a love for modular systems.\n\n" +
./UI/CreditsScreenUI.cs:                "Want to contribute or follow progress?\nCheck the README or community links in the game folder.";
./UI/CreditsScreenUI.cs:        }
./UI/CreditsScreenUI.cs:    }
./UI/CreditsScreenUI.cs:}
--
./UI/CreditsScreenUI.cs.meta:fileFormatVersion: 2
./UI/CreditsScreenUI.cs.meta:guid: d84730804994c74428438d56a67f134a
--
./UI/DiseaseHUDController.cs:using UnityEngine;
./UI/DiseaseHUDController.cs:using UnityEngine.UI;
./UI/DiseaseHUDController.cs:using Systems.Disease.Runtime;
./UI/DiseaseHUDController.cs:
./UI/DiseaseHUDController.cs:namespace UI.HUD.Disease
./UI/DiseaseHUDController.cs:{
./UI/DiseaseHUDController.cs:    public class DiseaseHUDController : MonoBehaviour
./UI/DiseaseHUDController.cs:    {
./UI/DiseaseHUDController.cs:        [SerializeField] private Text diseaseText;
./UI/DiseaseHUDController.cs:        [SerializeField] private SymptomPlayer symptomPlayer;
./UI/DiseaseHUDController.cs:
./UI/DiseaseHUDController.cs:        public void OnDiseaseApplied(DiseaseInstance instance)
./UI/DiseaseHUDController.cs:        {
./UI/DiseaseHUDController.cs:            diseaseText.text = $"{instance.DiseaseName} ({instance.TimeRemaining:F0}s)";
./UI/DiseaseHUDController.cs:        }
./UI/DiseaseHUDController.cs:
./UI/DiseaseHUDController.cs:        public void OnSymptomTriggered(string symptom, AudioClip clip)
./UI/DiseaseHUDController.cs:        {
./UI/DiseaseHUDController.cs:            symptomPlayer.PlaySymptom(symptom, clip);
./UI/DiseaseHUDController.cs:        }
./UI/DiseaseHUDController.cs:
./UI/DiseaseHUDController.cs:        public void OnDiseaseExpired(DiseaseInstance instance)
./UI/DiseaseHUDController.cs:        {
./UI/DiseaseHUDController.cs:            diseaseText.text = "";
./UI/DiseaseHUDController.cs:            symptomPlayer.Clear();
./UI/DiseaseHUDController.cs:        }
./UI/DiseaseHUDController.cs:    }
./UI/DiseaseHUDController.cs:}
--
./UI/DiseaseHUDController.cs.meta:fileFormatVersion: 2
./UI/DiseaseHUDController.cs.meta:guid: 5834b78fd339842418ae61eb4c14623b
--
./UI/GearSlotUI.cs:using UnityEngine;
./UI/GearSlotUI.cs:using UnityEngine.UI;
./UI/GearSlotUI.cs:using UnityEngine.EventSystems;
./UI/GearSlotUI.cs:using Inventory.DataModels;
./UI/GearSlotUI.cs:using Systems.Equipment;
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:#if UNITY_EDITOR
./UI/GearSlotUI.cs:using UnityEditor;
./UI/GearSlotUI.cs:#endif
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:public class GearSlotUI : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IDropHandler
./UI/GearSlotUI.cs:{
./UI/GearSlotUI.cs:    [Header("Slot Settings")]
./UI/GearSlotUI.cs:    public GearType type;
./UI/GearSlotUI.cs:    public Image icon;
./UI/GearSlotUI.cs:    public Button button;
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:    private GearData currentGear;
./UI/GearSlotUI.cs:    private IGearManager gearManager;
./UI/GearSlotUI.cs:    private bool isHovered;
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:    void Awake()
./UI/GearSlotUI.cs:    {
./UI/GearSlotUI.cs:        gearManager = Object.FindFirstObjectByType<GearManager>();
./UI/GearSlotUI.cs:        if (gearManager == null)
./UI/GearSlotUI.cs:            Debug.LogError("GearManager not found. GearSlotUI will not function correctly.");
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:        if (button != null)
./UI/GearSlotUI.cs:            button.onClick.AddListener(OnClick);
./UI/GearSlotUI.cs:        else
./UI/GearSlotUI.cs:            Debug.LogWarning($"GearSlotUI on {gameObject.name} has no Button assigned.");
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:        ClearSlot();
./UI/GearSlotUI.cs:    }
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:    public void SetGear(GearData gear)
./UI/GearSlotUI.cs:    {
./UI/GearSlotUI.cs:        currentGear = gear;
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:        if (icon != null)
./UI/GearSlotUI.cs:        {
./UI/GearSlotUI.cs:            icon.sprite = gear.icon;
./UI/GearSlotUI.cs:            icon.enabled = true;
./UI/GearSlotUI.cs:        }
./UI/GearSlotUI.cs:    }
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:    public void ClearSlot()
./UI/GearSlotUI.cs:    {
./UI/GearSlotUI.cs:        currentGear = null;
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:        if (icon != null)
./UI/GearSlotUI.cs:        {
./UI/GearSlotUI.cs:            icon.sprite = null;
./UI/GearSlotUI.cs:            icon.enabled = false;
./UI/GearSlotUI.cs:        }
./UI/GearSlotUI.cs:    }
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:    private void OnClick()
./UI/GearSlotUI.cs:    {
./UI/GearSlotUI.cs:        if (gearManager == null) return;
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:        if (currentGear != null)
./UI/GearSlotUI.cs:        {
./UI/GearSlotUI.cs:            gearManager.Unequip(type);
./UI/GearSlotUI.cs:        }
./UI/GearSlotUI.cs:        else
./UI/GearSlotUI.cs:        {
./UI/GearSlotUI.cs:            gearManager.OpenEquipMenu(type);
./UI/GearSlotUI.cs:        }
./UI/GearSlotUI.cs:    }
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:    public void OnPointerEnter(PointerEventData eventData)
./UI/GearSlotUI.cs:    {
./UI/GearSlotUI.cs:        isHovered = true;
./UI/GearSlotUI.cs:        // Optional: Show tooltip or highlight
./UI/GearSlotUI.cs:    }
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:    public void OnPointerExit(PointerEventData eventData)
./UI/GearSlotUI.cs:    {
./UI/GearSlotUI.cs:        isHovered = false;
./UI/GearSlotUI.cs:        // Optional: Hide tooltip or highlight
./UI/GearSlotUI.cs:    }
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:    public void OnDrop(PointerEventData eventData)
./UI/GearSlotUI.cs:    {
./UI/GearSlotUI.cs:        var dragged = eventData.pointerDrag?.GetComponent<DraggableGearIcon>();
./UI/GearSlotUI.cs:        if (dragged != null && dragged.Gear != null && gearManager != null)
./UI/GearSlotUI.cs:        {
./UI/GearSlotUI.cs:            gearManager.Equip(type, dragged.Gear);
./UI/GearSlotUI.cs:        }
./UI/GearSlotUI.cs:    }
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:#if UNITY_EDITOR
./UI/GearSlotUI.cs:    void OnDrawGizmos()
./UI/GearSlotUI.cs:    {
./UI/GearSlotUI.cs:        if (!isHovered) return;
./UI/GearSlotUI.cs:
./UI/GearSlotUI.cs:        Gizmos.color = Color.cyan;
./UI/GearSlotUI.cs:        Gizmos.DrawWireCube(transform.position, new Vector3(100, 100, 0));
./UI/GearSlotUI.cs:        Handles.Label(transform.position + Vector3.up * 60, $"GearSlot: {type}", EditorStyles.boldLabel);
./UI/GearSlotUI.cs:    }
./UI/GearSlotUI.cs:#endif
./UI/GearSlotUI.cs:}
--
./UI/GearSlotUI.cs.meta:fileFormatVersion: 2
./UI/GearSlotUI.cs.meta:guid: 39df298e9c8613543ae22793daa27dea
--
./UI/HUDContainerSpawner.cs:using UnityEngine;
./UI/HUDContainerSpawner.cs:using Game.Inventory;
./UI/HUDContainerSpawner.cs:
./UI/HUDContainerSpawner.cs:public class HUDContainerSpawner : MonoBehaviour
./UI/HUDContainerSpawner.cs:{
./UI/HUDContainerSpawner.cs:    private Inventory inventory;
./UI/HUDContainerSpawner.cs:
./UI/HUDContainerSpawner.cs:    void Start()
./UI/HUDContainerSpawner.cs:    {
./UI/HUDContainerSpawner.cs:        inventory = Object.FindFirstObjectByType<Inventory>();
./UI/HUDContainerSpawner.cs:        if (inventory == null)
./UI/HUDContainerSpawner.cs:        {
./UI/HUDContainerSpawner.cs:            Debug.LogError("[HUDContainerSpawner] Inventory not found.");
./UI/HUDContainerSpawner.cs:            return;
./UI/HUDContainerSpawner.cs:        }
./UI/HUDContainerSpawner.cs:
./UI/HUDContainerSpawner.cs:        InitializeStoragePanels();
./UI/HUDContainerSpawner.cs:    }
./UI/HUDContainerSpawner.cs:
./UI/HUDContainerSpawner.cs:    void InitializeStoragePanels()
./UI/HUDContainerSpawner.cs:    {
./UI/HUDContainerSpawner.cs:        foreach (var gear in inventory.GetEquippedGear())
./UI/HUDContainerSpawner.cs:        {
./UI/HUDContainerSpawner.cs:            if (gear == null || !gear.isContainer || gear.storageCapacity <= 0) continue;
./UI/HUDContainerSpawner.cs:
./UI/HUDContainerSpawner.cs:            Debug.Log($"[HUDContainerSpawner] Initializing storage for '{gear.itemName}' with {gear.storageCapacity} slots.");
./UI/HUDContainerSpawner.cs:            // TODO: Instantiate HUD container prefab via manager or panel spawner
./UI/HUDContainerSpawner.cs:        }
./UI/HUDContainerSpawner.cs:    }
./UI/HUDContainerSpawner.cs:
./UI/HUDContainerSpawner.cs:    public int GetTotalStorageCapacity()
./UI/HUDContainerSpawner.cs:    {
./UI/HUDContainerSpawner.cs:        int total = 0;
./UI/HUDContainerSpawner.cs:        foreach (var gear in inventory.GetEquippedGear())
./UI/HUDContainerSpawner.cs:        {
./UI/HUDContainerSpawner.cs:            if (gear != null)
./UI/HUDContainerSpawner.cs:                total += gear.storageCapacity;
./UI/HUDContainerSpawner.cs:        }
./UI/HUDContainerSpawner.cs:        return total;
./UI/HUDContainerSpawner.cs:    }
./UI/HUDContainerSpawner.cs:}
--
./UI/HUDContainerSpawner.cs.meta:fileFormatVersion: 2
./UI/HUDContainerSpawner.cs.meta:guid: 5d4409d61faa1db498d7a1ea1e2f18f0
--
./UI/InventoryUI.cs:using Game.UI;
./UI/InventoryUI.cs:using System.Collections.Generic;
./UI/InventoryUI.cs:using UnityEngine;
./UI/InventoryUI.cs:using UnityEngine.UI;
./UI/InventoryUI.cs:
./UI/InventoryUI.cs:public class InventoryUI : MonoBehaviour
./UI/InventoryUI.cs:{
./UI/InventoryUI.cs:    public Transform SlotContainer;
./UI/InventoryUI.cs:    public GameObject SlotPrefab;
./UI/InventoryUI.cs:    public GameObject SelectionFrame;
./UI/InventoryUI.cs:
./UI/InventoryUI.cs:    private List<InventoryUISlot> activeSlots = new List<InventoryUISlot>();
./UI/InventoryUI.cs:    private int selectedIndex = 0;
./UI/InventoryUI.cs:
./UI/InventoryUI.cs:    void Start()
./UI/InventoryUI.cs:    {
./UI/InventoryUI.cs:        RefreshUI();
./UI/InventoryUI.cs:    }
./UI/InventoryUI.cs:
./UI/InventoryUI.cs:    void Update()
./UI/InventoryUI.cs:    {
./UI/InventoryUI.cs:        if (Input.GetKeyDown(KeyCode.RightArrow)) MoveSelection(1);
./UI/InventoryUI.cs:        if (Input.GetKeyDown(KeyCode.LeftArrow)) MoveSelection(-1);
./UI/InventoryUI.cs:    }
./UI/InventoryUI.cs:
./UI/InventoryUI.cs:    public void RefreshUI()
./UI/InventoryUI.cs:    {
./UI/InventoryUI.cs:        ClearSlots();
./UI/InventoryUI.cs:
./UI/InventoryUI.cs:        var items = InventoryManager.Instance.GetAllItems();
./UI/InventoryUI.cs:        foreach (var item in items)
./UI/InventoryUI.cs:        {
./UI/InventoryUI.cs:            GameObject slotGO = Instantiate(SlotPrefab, SlotContainer);
./UI/InventoryUI.cs:            InventoryUISlot slot = slotGO.GetComponent<InventoryUISlot>();
./UI/InventoryUI.cs:            slot.Setup(item, () => UseItem(item), () => DropItem(item));
./UI/InventoryUI.cs:            activeSlots.Add(slot);
./UI/InventoryUI.cs:        }
./UI/InventoryUI.cs:
./UI/InventoryUI.cs:        UpdateSelectionFrame();
./UI/InventoryUI.cs:    }
./UI/InventoryUI.cs:
./UI/InventoryUI.cs:    private void ClearSlots()
./UI/InventoryUI.cs:    {
./UI/InventoryUI.cs:        foreach (Transform child in SlotContainer)
./UI/InventoryUI.cs:        {
./UI/InventoryUI.cs:            Destroy(child.gameObject);
./UI/InventoryUI.cs:        }
./UI/InventoryUI.cs:        activeSlots.Clear();
./UI/InventoryUI.cs:    }
./UI/InventoryUI.cs:
./UI/InventoryUI.cs:    private void MoveSelection(int direction)
./UI/InventoryUI.cs:    {
./UI/InventoryUI.cs:        selectedIndex = Mathf.Clamp(selectedIndex + direction, 0, activeSlots.Count - 1);
./UI/InventoryUI.cs:        UpdateSelectionFrame();
./UI/InventoryUI.cs:    }
./UI/InventoryUI.cs:
./UI/InventoryUI.cs:    private void UpdateSelectionFrame()
./UI/InventoryUI.cs:    {
./UI/InventoryUI.cs:        if (activeSlots.Count == 0) return;
./UI/InventoryUI.cs:        SelectionFrame.transform.position = activeSlots[selectedIndex].transform.position;
./UI/InventoryUI.cs:    }
./UI/InventoryUI.cs:
./UI/InventoryUI.cs:    private void UseItem(InventoryItem item)
./UI/InventoryUI.cs:    {
./UI/InventoryUI.cs:        if (item.IsConsumable)
./UI/InventoryUI.cs:        {
./UI/InventoryUI.cs:            InventoryManager.Instance.RemoveItem(item.ItemName);
./UI/InventoryUI.cs:            RefreshUI();
./UI/InventoryUI.cs:        }
./UI/InventoryUI.cs:    }
./UI/InventoryUI.cs:
./UI/InventoryUI.cs:    private void DropItem(InventoryItem item)
./UI/InventoryUI.cs:    {
./UI/InventoryUI.cs:        InventoryManager.Instance.RemoveItem(item.ItemName);
./UI/InventoryUI.cs:        RefreshUI();
./UI/InventoryUI.cs:    }
./UI/InventoryUI.cs:}
--
./UI/InventoryUI.cs.meta:fileFormatVersion: 2
./UI/InventoryUI.cs.meta:guid: d05f659c43ce12144915197dbae1cffc
--
./UI/InventoryUISlot.cs:using Game.Inventory;
./UI/InventoryUISlot.cs:using UnityEngine;
./UI/InventoryUISlot.cs:using UnityEngine.EventSystems;
./UI/InventoryUISlot.cs:using UnityEngine.UI;
./UI/InventoryUISlot.cs:
./UI/InventoryUISlot.cs:namespace Game.UI
./UI/InventoryUISlot.cs:{
./UI/InventoryUISlot.cs:	/// <summary>
./UI/InventoryUISlot.cs:	/// UI slot for drag-drop behavior, item assignment, and lock state.
./UI/InventoryUISlot.cs:	/// </summary>
./UI/InventoryUISlot.cs:	public class InventoryUISlot : MonoBehaviour, IDropHandler, IPointerEnterHandler, IPointerExitHandler
./UI/InventoryUISlot.cs:	{
./UI/InventoryUISlot.cs:		[Header("Slot References")]
./UI/InventoryUISlot.cs:		[SerializeField] private Transform itemAnchor;
./UI/InventoryUISlot.cs:		[SerializeField] private Image highlight;
./UI/InventoryUISlot.cs:
./UI/InventoryUISlot.cs:		[Header("Slot State")]
./UI/InventoryUISlot.cs:		[SerializeField] private InventoryItem assignedItem;
./UI/InventoryUISlot.cs:		[SerializeField] private bool isLocked;
./UI/InventoryUISlot.cs:
./UI/InventoryUISlot.cs:		public InventoryItem AssignedItem => assignedItem;
./UI/InventoryUISlot.cs:
./UI/InventoryUISlot.cs:		private Color defaultHighlightColor;
./UI/InventoryUISlot.cs:		private readonly Color hoverColor = new(0.9f, 0.9f, 1f, 1f);
./UI/InventoryUISlot.cs:
./UI/InventoryUISlot.cs:		private void Awake()
./UI/InventoryUISlot.cs:		{
./UI/InventoryUISlot.cs:			if (highlight != null)
./UI/InventoryUISlot.cs:				defaultHighlightColor = highlight.color;
./UI/InventoryUISlot.cs:		}
./UI/InventoryUISlot.cs:
./UI/InventoryUISlot.cs:		public void OnDrop(PointerEventData eventData)
./UI/InventoryUISlot.cs:		{
./UI/InventoryUISlot.cs:			if (isLocked || eventData.pointerDrag == null)
./UI/InventoryUISlot.cs:			{
./UI/InventoryUISlot.cs:				Debug.Log($"[InventoryUISlot] Drop rejected: Locked={isLocked} or no item.");
./UI/InventoryUISlot.cs:				return;
./UI/InventoryUISlot.cs:			}
./UI/InventoryUISlot.cs:
./UI/InventoryUISlot.cs:			var draggable = eventData.pointerDrag.GetComponent<DraggableItem>();
./UI/InventoryUISlot.cs:			if (draggable?.Item == null)
./UI/InventoryUISlot.cs:			{
./UI/InventoryUISlot.cs:				Debug.LogWarning("[InventoryUISlot] Invalid drop: missing DraggableItem or item reference.");
./UI/InventoryUISlot.cs:				return;
./UI/InventoryUISlot.cs:			}
./UI/InventoryUISlot.cs:
./UI/InventoryUISlot.cs:			if (ValidateItem(draggable.Item))
./UI/InventoryUISlot.cs:			{
./UI/InventoryUISlot.cs:				AssignItem(draggable.Item);
./UI/InventoryUISlot.cs:				draggable.OnSlotAssigned(this);
./UI/InventoryUISlot.cs:			}
./UI/InventoryUISlot.cs:			else
./UI/InventoryUISlot.cs:			{
./UI/InventoryUISlot.cs:				Debug.Log($"[InventoryUISlot] Item rejected: {draggable.Item.name}");
./UI/InventoryUISlot.cs:			}
./UI/InventoryUISlot.cs:		}
./UI/InventoryUISlot.cs:
./UI/InventoryUISlot.cs:		public void AssignItem(InventoryItem item)
./UI/InventoryUISlot.cs:		{
./UI/InventoryUISlot.cs:			assignedItem = item;
./UI/InventoryUISlot.cs:			item.transform.SetParent(itemAnchor, false);
./UI/InventoryUISlot.cs:			item.transform.localPosition = Vector3.zero;
./UI/InventoryUISlot.cs:			Debug.Log($"[InventoryUISlot] Assigned: {item.name}");
./UI/InventoryUISlot.cs:		}
./UI/InventoryUISlot.cs:
./UI/InventoryUISlot.cs:		public bool ValidateItem(InventoryItem item) => item != null;
./UI/InventoryUISlot.cs:
./UI/InventoryUISlot.cs:		public void ClearSlot()
./UI/InventoryUISlot.cs:		{
./UI/InventoryUISlot.cs:			if (assignedItem != null)
./UI/InventoryUISlot.cs:			{
./UI/InventoryUISlot.cs:				Destroy(assignedItem.gameObject);
./UI/InventoryUISlot.cs:				assignedItem = null;
./UI/InventoryUISlot.cs:				Debug.Log("[InventoryUISlot] Slot cleared.");
./UI/InventoryUISlot.cs:			}
./UI/InventoryUISlot.cs:		}
./UI/InventoryUISlot.cs:
./UI/InventoryUISlot.cs:		public void LockSlot(bool locked)
./UI/InventoryUISlot.cs:		{
./UI/InventoryUISlot.cs:			isLocked = locked;
./UI/InventoryUISlot.cs:			Debug.Log($"[InventoryUISlot] Lock state changed: {locked}");
./UI/InventoryUISlot.cs:		}
./UI/InventoryUISlot.cs:
./UI/InventoryUISlot.cs:		public void OnPointerEnter(PointerEventData eventData)
./UI/InventoryUISlot.cs:		{
./UI/InventoryUISlot.cs:			if (highlight != null)
./UI/InventoryUISlot.cs:				highlight.color = hoverColor;
./UI/InventoryUISlot.cs:		}
./UI/InventoryUISlot.cs:
./UI/InventoryUISlot.cs:		public void OnPointerExit(PointerEventData eventData)
./UI/InventoryUISlot.cs:		{
./UI/InventoryUISlot.cs:			if (highlight != null)
./UI/InventoryUISlot.cs:				highlight.color = defaultHighlightColor;
./UI/InventoryUISlot.cs:		}
./UI/InventoryUISlot.cs:	}
./UI/InventoryUISlot.cs:}
--
./UI/InventoryUISlot.cs.meta:fileFormatVersion: 2
./UI/InventoryUISlot.cs.meta:guid: effd966c26cc4674c918d0bed9b43098
--
./UI/ItemSlotUI.cs:﻿using Game.Inventory;
./UI/ItemSlotUI.cs:using UnityEngine;
./UI/ItemSlotUI.cs:using UnityEngine.UI;
./UI/ItemSlotUI.cs:using static UnityEditor.Progress;
./UI/ItemSlotUI.cs:
./UI/ItemSlotUI.cs:namespace Game.UI
./UI/ItemSlotUI.cs:{
./UI/ItemSlotUI.cs:    /// <summary>
./UI/ItemSlotUI.cs:    /// Visual slot for displaying either InventoryItem or ItemData info in the UI.
./UI/ItemSlotUI.cs:    /// Robust against nulls, missing fields, and namespace collisions.
./UI/ItemSlotUI.cs:    /// </summary>
./UI/ItemSlotUI.cs:    public class ItemSlotUI : MonoBehaviour
./UI/ItemSlotUI.cs:    {
./UI/ItemSlotUI.cs:        [Header("UI References")]
./UI/ItemSlotUI.cs:        [SerializeField] private Image icon;
./UI/ItemSlotUI.cs:        [SerializeField] private Image background;
./UI/ItemSlotUI.cs:
./UI/ItemSlotUI.cs:        [Header("Color Settings")]
./UI/ItemSlotUI.cs:        [SerializeField] private Color activeColor = Color.white;
./UI/ItemSlotUI.cs:        [SerializeField] private Color emptyColor = new Color(0.3f, 0.3f, 0.3f);
./UI/ItemSlotUI.cs:
./UI/ItemSlotUI.cs:        private Sprite sourceIcon;
./UI/ItemSlotUI.cs:
./UI/ItemSlotUI.cs:        /// <summary>
./UI/ItemSlotUI.cs:        /// Assigns data using InventoryItem component.
./UI/ItemSlotUI.cs:        /// </summary>
./UI/ItemSlotUI.cs:        public void Initialize(InventoryItem item)
./UI/ItemSlotUI.cs:        {
./UI/ItemSlotUI.cs:            if (item != null && item.icon != null)
./UI/ItemSlotUI.cs:            {
./UI/ItemSlotUI.cs:                sourceIcon = item.icon;
./UI/ItemSlotUI.cs:            }
./UI/ItemSlotUI.cs:            else
./UI/ItemSlotUI.cs:            {
./UI/ItemSlotUI.cs:                sourceIcon = null;
./UI/ItemSlotUI.cs:            }
./UI/ItemSlotUI.cs:
./UI/ItemSlotUI.cs:            UpdateVisuals();
./UI/ItemSlotUI.cs:        }
./UI/ItemSlotUI.cs:
./UI/ItemSlotUI.cs:        /// <summary>
./UI/ItemSlotUI.cs:        /// Assigns data using base Item (non-MonoBehaviour fallback).
./UI/ItemSlotUI.cs:        /// </summary>
./UI/ItemSlotUI.cs:        public void Initialize(Item item)
./UI/ItemSlotUI.cs:        {
./UI/ItemSlotUI.cs:            if (item != null && item.icon != null)
./UI/ItemSlotUI.cs:            {
./UI/ItemSlotUI.cs:                sourceIcon = item.icon;
./UI/ItemSlotUI.cs:            }
./UI/ItemSlotUI.cs:            else
./UI/ItemSlotUI.cs:            {
./UI/ItemSlotUI.cs:                sourceIcon = null;
./UI/ItemSlotUI.cs:            }
./UI/ItemSlotUI.cs:
./UI/ItemSlotUI.cs:            UpdateVisuals();
./UI/ItemSlotUI.cs:        }
./UI/ItemSlotUI.cs:
./UI/ItemSlotUI.cs:        /// <summary>
./UI/ItemSlotUI.cs:        /// Assigns data using raw Sprite if available.
./UI/ItemSlotUI.cs:        /// </summary>
./UI/ItemSlotUI.cs:        public void Initialize(Sprite itemSprite)
./UI/ItemSlotUI.cs:        {
./UI/ItemSlotUI.cs:            sourceIcon = itemSprite;
./UI/ItemSlotUI.cs:            UpdateVisuals();
./UI/ItemSlotUI.cs:        }
./UI/ItemSlotUI.cs:
./UI/ItemSlotUI.cs:        /// <summary>
./UI/ItemSlotUI.cs:        /// Updates the visuals based on current icon state.
./UI/ItemSlotUI.cs:        /// </summary>
./UI/ItemSlotUI.cs:        private void UpdateVisuals()
./UI/ItemSlotUI.cs:        {
./UI/ItemSlotUI.cs:            if (icon == null || background == null)
./UI/ItemSlotUI.cs:                return;
./UI/ItemSlotUI.cs:
./UI/ItemSlotUI.cs:            bool hasIcon = sourceIcon != null;
./UI/ItemSlotUI.cs:            icon.enabled = hasIcon;
./UI/ItemSlotUI.cs:            icon.sprite = hasIcon ? sourceIcon : null;
./UI/ItemSlotUI.cs:            background.color = hasIcon ? activeColor : emptyColor;
./UI/ItemSlotUI.cs:        }
./UI/ItemSlotUI.cs:
./UI/ItemSlotUI.cs:        /// <summary>
./UI/ItemSlotUI.cs:        /// Clears the slot to its empty visual state.
./UI/ItemSlotUI.cs:        /// </summary>
./UI/ItemSlotUI.cs:        public void ClearSlot()
./UI/ItemSlotUI.cs:        {
./UI/ItemSlotUI.cs:            sourceIcon = null;
./UI/ItemSlotUI.cs:            UpdateVisuals();
./UI/ItemSlotUI.cs:        }
./UI/ItemSlotUI.cs:
./UI/ItemSlotUI.cs:        /// <summary>
./UI/ItemSlotUI.cs:        /// Returns true if the slot currently displays an item.
./UI/ItemSlotUI.cs:        /// </summary>
./UI/ItemSlotUI.cs:        public bool HasItem() => sourceIcon != null;
./UI/ItemSlotUI.cs:    }
./UI/ItemSlotUI.cs:}
--
./UI/ItemSlotUI.cs.meta:fileFormatVersion: 2
./UI/ItemSlotUI.cs.meta:guid: 9167b276290152143af27088e23415d1
--
./UI/RarityColorMap.cs:using UnityEngine;
./UI/RarityColorMap.cs:using Inventory.DataModels;
./UI/RarityColorMap.cs:
./UI/RarityColorMap.cs:namespace UI.Styling
./UI/RarityColorMap.cs:{
./UI/RarityColorMap.cs:    public static class RarityColorMap
./UI/RarityColorMap.cs:    {
./UI/RarityColorMap.cs:        public static Color GetColor(RarityType rarity)
./UI/RarityColorMap.cs:        {
./UI/RarityColorMap.cs:            return rarity switch
./UI/RarityColorMap.cs:            {
./UI/RarityColorMap.cs:                RarityType.Common => new Color(0.6f, 0.6f, 0.6f),
./UI/RarityColorMap.cs:                RarityType.Uncommon => new Color(0.3f, 0.8f, 0.3f),
./UI/RarityColorMap.cs:                RarityType.Rare => new Color(0.2f, 0.4f, 0.9f),
./UI/RarityColorMap.cs:                RarityType.Epic => new Color(0.6f, 0.2f, 0.8f),
./UI/RarityColorMap.cs:                RarityType.Legendary => new Color(1.0f, 0.6f, 0.0f),
./UI/RarityColorMap.cs:                _ => Color.white
./UI/RarityColorMap.cs:            };
./UI/RarityColorMap.cs:        }
./UI/RarityColorMap.cs:    }
./UI/RarityColorMap.cs:}
--
./UI/RarityColorMap.cs.meta:fileFormatVersion: 2
./UI/RarityColorMap.cs.meta:guid: 8d5118c08bbe7fd428469264190d3791
--
./UI/SafeAreaHandler.cs:using UnityEngine;
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:[RequireComponent(typeof(RectTransform))]
./UI/SafeAreaHandler.cs:public class SafeAreaHandler : MonoBehaviour
./UI/SafeAreaHandler.cs:{
./UI/SafeAreaHandler.cs:    public enum SimDevice { None, GalaxyS7, iPhoneX }
./UI/SafeAreaHandler.cs:    public SimDevice simulationDevice = SimDevice.None;
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:    private RectTransform rectTransform;
./UI/SafeAreaHandler.cs:    private Rect lastSafeArea = new Rect(0, 0, 0, 0);
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:    private readonly Rect[] NSA_GalaxyS7 = new Rect[]
./UI/SafeAreaHandler.cs:    {
--
./UI/SafeAreaHandler.cs:        new Rect(0f, 0f, 1f, 1f)  // Landscape
./UI/SafeAreaHandler.cs:    };
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:    private readonly Rect[] NSA_iPhoneX = new Rect[]
./UI/SafeAreaHandler.cs:    {
./UI/SafeAreaHandler.cs:        new Rect(0f, 102f / 2436f, 1f, 2202f / 2436f), // Portrait
./UI/SafeAreaHandler.cs:        new Rect(132f / 2436f, 63f / 1125f, 2172f / 2436f, 1062f / 1125f) // Landscape
./UI/SafeAreaHandler.cs:    };
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:    void Awake()
./UI/SafeAreaHandler.cs:    {
./UI/SafeAreaHandler.cs:        rectTransform = GetComponent<RectTransform>();
./UI/SafeAreaHandler.cs:        ApplySafeArea(GetSafeArea());
./UI/SafeAreaHandler.cs:    }
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:    void Update()
./UI/SafeAreaHandler.cs:    {
./UI/SafeAreaHandler.cs:        Rect current = GetSafeArea();
./UI/SafeAreaHandler.cs:        if (current != lastSafeArea)
./UI/SafeAreaHandler.cs:            ApplySafeArea(current);
./UI/SafeAreaHandler.cs:    }
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:    Rect GetSafeArea()
./UI/SafeAreaHandler.cs:    {
./UI/SafeAreaHandler.cs:        Rect safeArea = Screen.safeArea;
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:#if UNITY_EDITOR
./UI/SafeAreaHandler.cs:        if (simulationDevice != SimDevice.None)
./UI/SafeAreaHandler.cs:        {
./UI/SafeAreaHandler.cs:            Rect[] NSA = simulationDevice switch
./UI/SafeAreaHandler.cs:            {
./UI/SafeAreaHandler.cs:                SimDevice.GalaxyS7 => NSA_GalaxyS7,
./UI/SafeAreaHandler.cs:                SimDevice.iPhoneX => NSA_iPhoneX,
./UI/SafeAreaHandler.cs:                _ => NSA_GalaxyS7
./UI/SafeAreaHandler.cs:            };
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:            bool isPortrait = Screen.height > Screen.width;
./UI/SafeAreaHandler.cs:            Rect simulated = NSA[isPortrait ? 0 : 1];
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:            safeArea = new Rect(
./UI/SafeAreaHandler.cs:                Screen.width * simulated.x,
./UI/SafeAreaHandler.cs:                Screen.height * simulated.y,
./UI/SafeAreaHandler.cs:                Screen.width * simulated.width,
./UI/SafeAreaHandler.cs:                Screen.height * simulated.height
./UI/SafeAreaHandler.cs:            );
./UI/SafeAreaHandler.cs:        }
./UI/SafeAreaHandler.cs:#endif
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:        return safeArea;
./UI/SafeAreaHandler.cs:    }
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:    void ApplySafeArea(Rect r)
./UI/SafeAreaHandler.cs:    {
./UI/SafeAreaHandler.cs:        lastSafeArea = r;
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:        Vector2 anchorMin = r.position;
./UI/SafeAreaHandler.cs:        Vector2 anchorMax = r.position + r.size;
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:        anchorMin.x /= Screen.width;
./UI/SafeAreaHandler.cs:        anchorMin.y /= Screen.height;
./UI/SafeAreaHandler.cs:        anchorMax.x /= Screen.width;
./UI/SafeAreaHandler.cs:        anchorMax.y /= Screen.height;
./UI/SafeAreaHandler.cs:
./UI/SafeAreaHandler.cs:        rectTransform.anchorMin = anchorMin;
./UI/SafeAreaHandler.cs:        rectTransform.anchorMax = anchorMax;
./UI/SafeAreaHandler.cs:    }
./UI/SafeAreaHandler.cs:}
Binary file ./UI/SafeAreaHandler.cs matches
--
./UI/SafeAreaHandler.cs.meta:fileFormatVersion: 2
./UI/SafeAreaHandler.cs.meta:guid: 1d7614d6fa3cd1d4a815dd3d61cd6d53
--
./UI/SlotPanelManager.cs:using System.Collections.Generic;
./UI/SlotPanelManager.cs:using UnityEngine;
./UI/SlotPanelManager.cs:using UnityEngine.UI;
./UI/SlotPanelManager.cs:using Game.Inventory;
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:public class SlotPanelManager : MonoBehaviour
./UI/SlotPanelManager.cs:{
./UI/SlotPanelManager.cs:    [System.Serializable]
./UI/SlotPanelManager.cs:    public class SlotReference
./UI/SlotPanelManager.cs:    {
./UI/SlotPanelManager.cs:        public string slotName;
./UI/SlotPanelManager.cs:        public Button slotButton;
./UI/SlotPanelManager.cs:        public Image iconImage;
./UI/SlotPanelManager.cs:    }
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:    [Header("Equipment Slots")]
./UI/SlotPanelManager.cs:    public List<SlotReference> equipmentSlots = new();
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:    [Header("Default Icon")]
./UI/SlotPanelManager.cs:    public Sprite defaultIcon;
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:    private Inventory inventory;
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:    void Awake()
./UI/SlotPanelManager.cs:    {
./UI/SlotPanelManager.cs:        inventory = Object.FindFirstObjectByType<Inventory>();
./UI/SlotPanelManager.cs:        if (inventory == null)
./UI/SlotPanelManager.cs:        {
./UI/SlotPanelManager.cs:            Debug.LogError("[SlotPanelManager] Inventory not found.");
./UI/SlotPanelManager.cs:            return;
./UI/SlotPanelManager.cs:        }
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:        RegisterSlotButtons();
./UI/SlotPanelManager.cs:        SyncIconsFromEquippedItems();
./UI/SlotPanelManager.cs:    }
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:    void RegisterSlotButtons()
./UI/SlotPanelManager.cs:    {
./UI/SlotPanelManager.cs:        foreach (SlotReference slot in equipmentSlots)
./UI/SlotPanelManager.cs:        {
./UI/SlotPanelManager.cs:            GameObject found = GameObject.Find("Slot_" + slot.slotName);
./UI/SlotPanelManager.cs:            if (found == null) continue;
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:            slot.slotButton = found.GetComponent<Button>();
./UI/SlotPanelManager.cs:            slot.iconImage = found.GetComponentInChildren<Image>();
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:            if (slot.slotButton != null)
./UI/SlotPanelManager.cs:            {
./UI/SlotPanelManager.cs:                string capturedSlot = slot.slotName;
./UI/SlotPanelManager.cs:                slot.slotButton.onClick.AddListener(() => OnSlotClicked(capturedSlot));
./UI/SlotPanelManager.cs:            }
./UI/SlotPanelManager.cs:        }
./UI/SlotPanelManager.cs:    }
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:    void OnSlotClicked(string slotName)
./UI/SlotPanelManager.cs:    {
./UI/SlotPanelManager.cs:        Item heldItem = inventory.rightHand ?? inventory.leftHand;
./UI/SlotPanelManager.cs:        if (heldItem == null || !IsItemValidForSlot(heldItem, slotName)) return;
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:        if (inventory.EquipItem(heldItem))
./UI/SlotPanelManager.cs:            UpdateSlotIcon(slotName, heldItem);
./UI/SlotPanelManager.cs:    }
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:    bool IsItemValidForSlot(Item item, string slotName)
./UI/SlotPanelManager.cs:    {
./UI/SlotPanelManager.cs:        string lowerSlot = slotName.ToLower();
./UI/SlotPanelManager.cs:        return item.itemType switch
./UI/SlotPanelManager.cs:        {
./UI/SlotPanelManager.cs:            ItemTypeEnum.Clothing => item.clothingSlot.ToString().ToLower() == lowerSlot,
./UI/SlotPanelManager.cs:            ItemTypeEnum.Bag => lowerSlot == "backpack",
./UI/SlotPanelManager.cs:            ItemTypeEnum.Holster => lowerSlot == "holster",
./UI/SlotPanelManager.cs:            _ => false
./UI/SlotPanelManager.cs:        };
./UI/SlotPanelManager.cs:    }
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:    void UpdateSlotIcon(string slotName, Item item)
./UI/SlotPanelManager.cs:    {
./UI/SlotPanelManager.cs:        SlotReference slotRef = equipmentSlots.Find(s => s.slotName.Equals(slotName, System.StringComparison.OrdinalIgnoreCase));
./UI/SlotPanelManager.cs:        if (slotRef == null || slotRef.iconImage == null) return;
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:        Sprite iconToUse = item.EquippedSprite ?? item.icon ?? defaultIcon;
./UI/SlotPanelManager.cs:        slotRef.iconImage.sprite = iconToUse;
./UI/SlotPanelManager.cs:        slotRef.iconImage.enabled = true;
./UI/SlotPanelManager.cs:    }
./UI/SlotPanelManager.cs:
./UI/SlotPanelManager.cs:    void SyncIconsFromEquippedItems()
./UI/SlotPanelManager.cs:    {
./UI/SlotPanelManager.cs:        foreach (var gear in inventory.GetEquippedGear())
./UI/SlotPanelManager.cs:        {
./UI/SlotPanelManager.cs:            if (gear?.data == null) continue;
./UI/SlotPanelManager.cs:            string slot = gear.clothingSlot.ToString().ToLower();
./UI/SlotPanelManager.cs:            UpdateSlotIcon(slot, gear);
./UI/SlotPanelManager.cs:        }
./UI/SlotPanelManager.cs:    }
./UI/SlotPanelManager.cs:}
--
./UI/SlotPanelManager.cs.meta:fileFormatVersion: 2
./UI/SlotPanelManager.cs.meta:guid: fbcd96e6e385b2945b4a35742ebdbd57
--
./UI/SymptomPlayer.cs:using UnityEngine;
./UI/SymptomPlayer.cs:using UnityEngine.UI;
./UI/SymptomPlayer.cs:
./UI/SymptomPlayer.cs:namespace UI.HUD
./UI/SymptomPlayer.cs:{
./UI/SymptomPlayer.cs:    public class SymptomPlayer : MonoBehaviour
./UI/SymptomPlayer.cs:    {
./UI/SymptomPlayer.cs:        [SerializeField] private Text symptomText;
./UI/SymptomPlayer.cs:        [SerializeField] private AudioSource audioSource;
./UI/SymptomPlayer.cs:
./UI/SymptomPlayer.cs:        public void PlaySymptom(string symptom, AudioClip clip)
./UI/SymptomPlayer.cs:        {
./UI/SymptomPlayer.cs:            symptomText.text = symptom;
./UI/SymptomPlayer.cs:            if (clip != null)
./UI/SymptomPlayer.cs:                audioSource.PlayOneShot(clip);
./UI/SymptomPlayer.cs:        }
./UI/SymptomPlayer.cs:
./UI/SymptomPlayer.cs:        public void Clear()
./UI/SymptomPlayer.cs:        {
./UI/SymptomPlayer.cs:            symptomText.text = "";
./UI/SymptomPlayer.cs:        }
./UI/SymptomPlayer.cs:    }
./UI/SymptomPlayer.cs:}
--
./UI/SymptomPlayer.cs.meta:fileFormatVersion: 2
./UI/SymptomPlayer.cs.meta:guid: 2538c4b159cbe0447b56071f1bb1fc94
--
./UI/TitleScreenUI.cs:using Survival.Audio;
./UI/TitleScreenUI.cs:using Survival.UI;
./UI/TitleScreenUI.cs:using UnityEngine;
./UI/TitleScreenUI.cs:using UnityEngine.UI;
./UI/TitleScreenUI.cs:
./UI/TitleScreenUI.cs:namespace Survival.UI.TitleScreen
./UI/TitleScreenUI.cs:{
./UI/TitleScreenUI.cs:    public class TitleScreenUI : MonoBehaviour
./UI/TitleScreenUI.cs:    {
./UI/TitleScreenUI.cs:        [Header("UI Elements")]
./UI/TitleScreenUI.cs:        [SerializeField] private GameObject splashContainer;
./UI/TitleScreenUI.cs:        [SerializeField] private Button startButton;
./UI/TitleScreenUI.cs:        [SerializeField] private Button creditsButton;
./UI/TitleScreenUI.cs:        [SerializeField] private Button quitButton;
./UI/TitleScreenUI.cs:
./UI/TitleScreenUI.cs:        [Header("Audio")]
./UI/TitleScreenUI.cs:        [SerializeField] private AudioSource buttonAudio;
./UI/TitleScreenUI.cs:        [SerializeField] private AudioCue startCue;
./UI/TitleScreenUI.cs:        [SerializeField] private AudioCue quitCue;
./UI/TitleScreenUI.cs:
./UI/TitleScreenUI.cs:        [Header("Transitions")]
./UI/TitleScreenUI.cs:        [SerializeField] private CanvasGroup fader;
./UI/TitleScreenUI.cs:        [SerializeField] private float fadeDuration = 1f;
./UI/TitleScreenUI.cs:        [SerializeField] private string gameSceneName = "MainScene";
./UI/TitleScreenUI.cs:
./UI/TitleScreenUI.cs:        private void Awake()
./UI/TitleScreenUI.cs:        {
./UI/TitleScreenUI.cs:            startButton.onClick.AddListener(HandleStart);
./UI/TitleScreenUI.cs:            creditsButton.onClick.AddListener(HandleCredits);
./UI/TitleScreenUI.cs:            quitButton.onClick.AddListener(HandleQuit);
./UI/TitleScreenUI.cs:        }
./UI/TitleScreenUI.cs:
./UI/TitleScreenUI.cs:        private void HandleStart()
./UI/TitleScreenUI.cs:        {
./UI/TitleScreenUI.cs:            PlayAudio(startCue);
./UI/TitleScreenUI.cs:            StartCoroutine(FadeAndLoadScene(gameSceneName));
./UI/TitleScreenUI.cs:        }
./UI/TitleScreenUI.cs:
./UI/TitleScreenUI.cs:        private void HandleCredits()
./UI/TitleScreenUI.cs:        {
./UI/TitleScreenUI.cs:            // TODO: Implement credits screen logic
./UI/TitleScreenUI.cs:        }
./UI/TitleScreenUI.cs:
./UI/TitleScreenUI.cs:        private void HandleQuit()
./UI/TitleScreenUI.cs:        {
./UI/TitleScreenUI.cs:            PlayAudio(quitCue);
./UI/TitleScreenUI.cs:            Application.Quit();
./UI/TitleScreenUI.cs:        }
./UI/TitleScreenUI.cs:
./UI/TitleScreenUI.cs:        private void PlayAudio(AudioCue cue)
./UI/TitleScreenUI.cs:        {
./UI/TitleScreenUI.cs:            if (buttonAudio != null && cue != AudioCue.None)
./UI/TitleScreenUI.cs:            {
./UI/TitleScreenUI.cs:                buttonAudio.PlayOneShot(AudioManager.GetClip(cue));
./UI/TitleScreenUI.cs:            }
./UI/TitleScreenUI.cs:        }
./UI/TitleScreenUI.cs:
./UI/TitleScreenUI.cs:        private System.Collections.IEnumerator FadeAndLoadScene(string sceneName)
./UI/TitleScreenUI.cs:        {
./UI/TitleScreenUI.cs:            float timer = 0f;
./UI/TitleScreenUI.cs:            while (timer < fadeDuration)
./UI/TitleScreenUI.cs:            {
./UI/TitleScreenUI.cs:                fader.alpha = timer / fadeDuration;
./UI/TitleScreenUI.cs:                timer += Time.deltaTime;
./UI/TitleScreenUI.cs:                yield return null;
./UI/TitleScreenUI.cs:            }
./UI/TitleScreenUI.cs:            UnityEngine.SceneManagement.SceneManager.LoadScene(sceneName);
./UI/TitleScreenUI.cs:        }
./UI/TitleScreenUI.cs:    }
./UI/TitleScreenUI.cs:}
--
./UI/TitleScreenUI.cs.meta:fileFormatVersion: 2
./UI/TitleScreenUI.cs.meta:guid: 756bd3fb36b3da04b9b9b2cf50329b0f
--
./UI/TooltipData.cs:using UnityEngine;
./UI/TooltipData.cs:
./UI/TooltipData.cs:namespace Survival.UI.Tooltip
./UI/TooltipData.cs:{
./UI/TooltipData.cs:    [System.Serializable]
./UI/TooltipData.cs:    public class TooltipData
./UI/TooltipData.cs:    {
./UI/TooltipData.cs:        public string text;
./UI/TooltipData.cs:        public Sprite icon;
./UI/TooltipData.cs:        public Color backgroundColor = Color.black;
./UI/TooltipData.cs:    }
./UI/TooltipData.cs:}
--
./UI/TooltipData.cs.meta:fileFormatVersion: 2
./UI/TooltipData.cs.meta:guid: 7a5e9c7f4fc65004faecad33328bdb53
--
./UI/TooltipDisplay.cs:using UnityEngine;
./UI/TooltipDisplay.cs:using UnityEngine.UI;
./UI/TooltipDisplay.cs:using System.Collections;
./UI/TooltipDisplay.cs:
./UI/TooltipDisplay.cs:namespace Survival.UI.Tooltip
./UI/TooltipDisplay.cs:{
./UI/TooltipDisplay.cs:    public class TooltipDisplay : MonoBehaviour
./UI/TooltipDisplay.cs:    {
./UI/TooltipDisplay.cs:        public static TooltipDisplay Instance;
./UI/TooltipDisplay.cs:
./UI/TooltipDisplay.cs:        [SerializeField] private Text tooltipText;
./UI/TooltipDisplay.cs:        [SerializeField] private Image tooltipIcon;
./UI/TooltipDisplay.cs:        [SerializeField] private CanvasGroup canvasGroup;
./UI/TooltipDisplay.cs:
./UI/TooltipDisplay.cs:        private Coroutine showCoroutine;
./UI/TooltipDisplay.cs:
./UI/TooltipDisplay.cs:        private void Awake() => Instance = this;
./UI/TooltipDisplay.cs:
./UI/TooltipDisplay.cs:        public void Show(TooltipData data, float delay)
./UI/TooltipDisplay.cs:        {
./UI/TooltipDisplay.cs:            if (showCoroutine != null)
./UI/TooltipDisplay.cs:                StopCoroutine(showCoroutine);
./UI/TooltipDisplay.cs:
./UI/TooltipDisplay.cs:            showCoroutine = StartCoroutine(ShowDelayed(data, delay));
./UI/TooltipDisplay.cs:        }
./UI/TooltipDisplay.cs:
./UI/TooltipDisplay.cs:        public void Hide()
./UI/TooltipDisplay.cs:        {
./UI/TooltipDisplay.cs:            if (showCoroutine != null)
./UI/TooltipDisplay.cs:                StopCoroutine(showCoroutine);
./UI/TooltipDisplay.cs:
./UI/TooltipDisplay.cs:            canvasGroup.alpha = 0;
./UI/TooltipDisplay.cs:        }
./UI/TooltipDisplay.cs:
./UI/TooltipDisplay.cs:        private IEnumerator ShowDelayed(TooltipData data, float delay)
./UI/TooltipDisplay.cs:        {
./UI/TooltipDisplay.cs:            yield return new WaitForSeconds(delay);
./UI/TooltipDisplay.cs:
./UI/TooltipDisplay.cs:            tooltipText.text = data.text;
./UI/TooltipDisplay.cs:
./UI/TooltipDisplay.cs:            if (tooltipIcon != null && data.icon != null)
./UI/TooltipDisplay.cs:            {
./UI/TooltipDisplay.cs:                tooltipIcon.sprite = data.icon;
./UI/TooltipDisplay.cs:                tooltipIcon.enabled = true;
./UI/TooltipDisplay.cs:            }
./UI/TooltipDisplay.cs:            else if (tooltipIcon != null)
./UI/TooltipDisplay.cs:            {
./UI/TooltipDisplay.cs:                tooltipIcon.enabled = false;
./UI/TooltipDisplay.cs:            }
./UI/TooltipDisplay.cs:
./UI/TooltipDisplay.cs:            canvasGroup.alpha = 1;
./UI/TooltipDisplay.cs:        }
./UI/TooltipDisplay.cs:    }
./UI/TooltipDisplay.cs:}
--
./UI/TooltipDisplay.cs.meta:fileFormatVersion: 2
./UI/TooltipDisplay.cs.meta:guid: bb667edcb2cc25641b9d323b974c1832
--
./UI/TooltipTrigger.cs:﻿using UnityEngine;
./UI/TooltipTrigger.cs:using UnityEngine.EventSystems;
./UI/TooltipTrigger.cs:
./UI/TooltipTrigger.cs:namespace Survival.UI.Tooltip
./UI/TooltipTrigger.cs:{
./UI/TooltipTrigger.cs:    public class TooltipTrigger : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
./UI/TooltipTrigger.cs:    {
./UI/TooltipTrigger.cs:        public TooltipData tooltipData;
./UI/TooltipTrigger.cs:        public float delay = 0.5f;
./UI/TooltipTrigger.cs:
./UI/TooltipTrigger.cs:        public void OnPointerEnter(PointerEventData eventData)
./UI/TooltipTrigger.cs:        {
./UI/TooltipTrigger.cs:            TooltipDisplay.Instance.Show(tooltipData, delay);
./UI/TooltipTrigger.cs:        }
./UI/TooltipTrigger.cs:
./UI/TooltipTrigger.cs:        public void OnPointerExit(PointerEventData eventData)
./UI/TooltipTrigger.cs:        {
./UI/TooltipTrigger.cs:            TooltipDisplay.Instance.Hide();
./UI/TooltipTrigger.cs:        }
./UI/TooltipTrigger.cs:    }
./UI/TooltipTrigger.cs:}
--
./UI/TooltipTrigger.cs.meta:fileFormatVersion: 2
./UI/TooltipTrigger.cs.meta:guid: 8847721f2333e784184e77b5193cdfaa
--
./UI/TypewriterDisplay.cs:// File: Assets/Scripts/UI/TypewriterDisplay.cs
./UI/TypewriterDisplay.cs:using UnityEngine;
./UI/TypewriterDisplay.cs:using UnityEngine.UI;
./UI/TypewriterDisplay.cs:using System.Collections;
./UI/TypewriterDisplay.cs:
./UI/TypewriterDisplay.cs:namespace Game.UI
./UI/TypewriterDisplay.cs:{
./UI/TypewriterDisplay.cs:    public class TypewriterDisplay : MonoBehaviour
./UI/TypewriterDisplay.cs:    {
./UI/TypewriterDisplay.cs:        [SerializeField] private Text uiText;
./UI/TypewriterDisplay.cs:        [SerializeField] private float typingSpeed = 0.05f;
./UI/TypewriterDisplay.cs:
./UI/TypewriterDisplay.cs:        public void DisplayText(string fullText)
./UI/TypewriterDisplay.cs:        {
./UI/TypewriterDisplay.cs:            StartCoroutine(TypeText(fullText));
./UI/TypewriterDisplay.cs:        }
./UI/TypewriterDisplay.cs:
./UI/TypewriterDisplay.cs:        private IEnumerator TypeText(string text)
./UI/TypewriterDisplay.cs:        {
./UI/TypewriterDisplay.cs:            uiText.text = "";
./UI/TypewriterDisplay.cs:            foreach (char c in text)
./UI/TypewriterDisplay.cs:            {
./UI/TypewriterDisplay.cs:                uiText.text += c;
./UI/TypewriterDisplay.cs:                yield return new WaitForSeconds(typingSpeed);
./UI/TypewriterDisplay.cs:            }
./UI/TypewriterDisplay.cs:        }
./UI/TypewriterDisplay.cs:    }
./UI/TypewriterDisplay.cs:}
--
./UI/TypewriterDisplay.cs.meta:fileFormatVersion: 2
./UI/TypewriterDisplay.cs.meta:guid: ca78e6a859401b54aa2bee2da38cec6f
--
./UI/UI.asmdef:{
./UI/UI.asmdef:  "name": "UI",
./UI/UI.asmdef:  "references": [
./UI/UI.asmdef:    "Player",
./UI/UI.asmdef:    "Systems",
./UI/UI.asmdef:    "Audio",
./UI/UI.asmdef:    "Flags",
./UI/UI.asmdef:    "DialogueSystem",
./UI/UI.asmdef:    "Unity.TextMeshPro",
./UI/UI.asmdef:    "Core"
./UI/UI.asmdef:  ],
./UI/UI.asmdef:  "includePlatforms": [],
./UI/UI.asmdef:  "excludePlatforms": [],
./UI/UI.asmdef:  "allowUnsafeCode": false,
./UI/UI.asmdef:  "overrideReferences": false,
./UI/UI.asmdef:  "precompiledReferences": [],
./UI/UI.asmdef:  "autoReferenced": true,
./UI/UI.asmdef:  "defineConstraints": [],
./UI/UI.asmdef:  "versionDefines": [],
./UI/UI.asmdef:  "noEngineReferences": false
./UI/UI.asmdef:}
--
./UI/UI.asmdef.meta:fileFormatVersion: 2
./UI/UI.asmdef.meta:guid: d8d9275288a27e14d806d3921258254a
./UI/UI.asmdef.meta:AssemblyDefinitionImporter:
./UI/UI.asmdef.meta:  externalObjects: {}
./UI/UI.asmdef.meta:  userData: 
./UI/UI.asmdef.meta:  assetBundleName: 
./UI/UI.asmdef.meta:  assetBundleVariant: 
--
./UI/UIController.cs:using Game.UI;
./UI/UIController.cs:using UnityEngine;
./UI/UIController.cs:using UnityEngine.UI;
./UI/UIController.cs:
./UI/UIController.cs:public class UIController : MonoBehaviour
./UI/UIController.cs:{
./UI/UIController.cs:    [Header("Inventory UI")]
./UI/UIController.cs:    public GameObject InventoryPanel;
./UI/UIController.cs:    public Transform SlotContainer;
./UI/UIController.cs:    public GameObject SlotPrefab;
./UI/UIController.cs:
./UI/UIController.cs:    private bool isInventoryVisible = false;
./UI/UIController.cs:
./UI/UIController.cs:    void Update()
./UI/UIController.cs:    {
./UI/UIController.cs:        if (Input.GetKeyDown(KeyCode.I))
./UI/UIController.cs:        {
./UI/UIController.cs:            ToggleInventory();
./UI/UIController.cs:        }
./UI/UIController.cs:    }
./UI/UIController.cs:
./UI/UIController.cs:    public void ToggleInventory()
./UI/UIController.cs:    {
./UI/UIController.cs:        isInventoryVisible = !isInventoryVisible;
./UI/UIController.cs:        InventoryPanel.SetActive(isInventoryVisible);
./UI/UIController.cs:
./UI/UIController.cs:        if (isInventoryVisible)
./UI/UIController.cs:        {
./UI/UIController.cs:            UpdateInventoryUI();
./UI/UIController.cs:        }
./UI/UIController.cs:    }
./UI/UIController.cs:
./UI/UIController.cs:    public void UpdateInventoryUI()
./UI/UIController.cs:    {
./UI/UIController.cs:        foreach (Transform child in SlotContainer)
./UI/UIController.cs:        {
./UI/UIController.cs:            Destroy(child.gameObject);
./UI/UIController.cs:        }
./UI/UIController.cs:
./UI/UIController.cs:        var items = InventoryManager.Instance.GetAllItems();
./UI/UIController.cs:        foreach (var item in items)
./UI/UIController.cs:        {
./UI/UIController.cs:            GameObject slotGO = Instantiate(SlotPrefab, SlotContainer);
./UI/UIController.cs:            InventoryUISlot slot = slotGO.GetComponent<InventoryUISlot>();
./UI/UIController.cs:            slot.Setup(item, () => UseItem(item), () => DropItem(item));
./UI/UIController.cs:        }
./UI/UIController.cs:    }
./UI/UIController.cs:
./UI/UIController.cs:    private void UseItem(InventoryItem item)
./UI/UIController.cs:    {
./UI/UIController.cs:        if (item.IsConsumable)
./UI/UIController.cs:        {
./UI/UIController.cs:            InventoryManager.Instance.RemoveItem(item.ItemName);
./UI/UIController.cs:            UpdateInventoryUI();
./UI/UIController.cs:        }
./UI/UIController.cs:    }
./UI/UIController.cs:
./UI/UIController.cs:    private void DropItem(InventoryItem item)
./UI/UIController.cs:    {
./UI/UIController.cs:        InventoryManager.Instance.RemoveItem(item.ItemName);
./UI/UIController.cs:        UpdateInventoryUI();
./UI/UIController.cs:    }
./UI/UIController.cs:}
--
./UI/UIController.cs.meta:fileFormatVersion: 2
./UI/UIController.cs.meta:guid: b1be138204abf5f4783b3ee3b9834923
--
./UI/UIEnums.cs:namespace Survival.UI
./UI/UIEnums.cs:{
./UI/UIEnums.cs:    public enum HUDState { Default, InventoryOpen, MapView, DialogueMode }
./UI/UIEnums.cs:    public enum UIPage { MainMenu, PauseMenu, Inventory, Settings, Journal }
./UI/UIEnums.cs:    public enum NotificationType { Info, Warning, Error, Success }
./UI/UIEnums.cs:    public enum PopupMode { Modal, Tooltip, Banner, FadeIn }
./UI/UIEnums.cs:}
--
./UI/UIEnums.cs.meta:fileFormatVersion: 2
./UI/UIEnums.cs.meta:guid: d19bc04657714624b93177461e6a5887
--
./UI/UIManager.cs:// File: Assets/Scripts/UI/UIManager.cs
./UI/UIManager.cs:using UnityEngine;
./UI/UIManager.cs:
./UI/UIManager.cs:namespace Game.UI
./UI/UIManager.cs:{
./UI/UIManager.cs:    public class UIManager : MonoBehaviour
./UI/UIManager.cs:    {
./UI/UIManager.cs:        [SerializeField] private GameObject dialoguePanel;
./UI/UIManager.cs:        [SerializeField] private GameObject inventoryPanel;
./UI/UIManager.cs:        [SerializeField] private GameObject statusOverlay;
./UI/UIManager.cs:
./UI/UIManager.cs:        public void TogglePanel(string panelName, bool active)
./UI/UIManager.cs:        {
./UI/UIManager.cs:            switch (panelName)
./UI/UIManager.cs:            {
./UI/UIManager.cs:                case "Dialogue": dialoguePanel.SetActive(active); break;
./UI/UIManager.cs:                case "Inventory": inventoryPanel.SetActive(active); break;
./UI/UIManager.cs:                case "Status": statusOverlay.SetActive(active); break;
./UI/UIManager.cs:            }
./UI/UIManager.cs:        }
./UI/UIManager.cs:    }
./UI/UIManager.cs:}
--
./UI/UIManager.cs.meta:fileFormatVersion: 2
./UI/UIManager.cs.meta:guid: ad71fdb34aafbe54d8897885ce955509
--
./UI/WeaponHUDDisplay.cs:using UnityEngine;
./UI/WeaponHUDDisplay.cs:using UnityEngine.UI;
./UI/WeaponHUDDisplay.cs:using TMPro;
./UI/WeaponHUDDisplay.cs:
./UI/WeaponHUDDisplay.cs:public class WeaponHUDDisplay : MonoBehaviour
./UI/WeaponHUDDisplay.cs:{
./UI/WeaponHUDDisplay.cs:    [Header("Ammo")]
./UI/WeaponHUDDisplay.cs:    public TMP_Text magazineAmmoUI;
./UI/WeaponHUDDisplay.cs:    public TMP_Text totalAmmoUI;
./UI/WeaponHUDDisplay.cs:    public Image ammoTypeUI;
./UI/WeaponHUDDisplay.cs:
./UI/WeaponHUDDisplay.cs:    [Header("Weapons")]
./UI/WeaponHUDDisplay.cs:    public Image activeWeaponUI;
./UI/WeaponHUDDisplay.cs:    public Image secondaryWeaponUI;
./UI/WeaponHUDDisplay.cs:    public Sprite emptySlot;
./UI/WeaponHUDDisplay.cs:
./UI/WeaponHUDDisplay.cs:    private WeaponManager weaponManager;
./UI/WeaponHUDDisplay.cs:
./UI/WeaponHUDDisplay.cs:    void Start()
./UI/WeaponHUDDisplay.cs:    {
./UI/WeaponHUDDisplay.cs:        weaponManager = Object.FindFirstObjectByType<WeaponManager>();
./UI/WeaponHUDDisplay.cs:    }
./UI/WeaponHUDDisplay.cs:
./UI/WeaponHUDDisplay.cs:    void Update()
./UI/WeaponHUDDisplay.cs:    {
./UI/WeaponHUDDisplay.cs:        if (weaponManager == null) return;
./UI/WeaponHUDDisplay.cs:
./UI/WeaponHUDDisplay.cs:        Weapon active = weaponManager.GetActiveWeapon();
./UI/WeaponHUDDisplay.cs:        Weapon secondary = weaponManager.GetSecondaryWeapon();
./UI/WeaponHUDDisplay.cs:
./UI/WeaponHUDDisplay.cs:        if (active != null)
./UI/WeaponHUDDisplay.cs:        {
./UI/WeaponHUDDisplay.cs:            magazineAmmoUI.text = $"{active.GetMagazineCount()}";
./UI/WeaponHUDDisplay.cs:            totalAmmoUI.text = $"{weaponManager.GetTotalAmmo(active)}";
./UI/WeaponHUDDisplay.cs:            activeWeaponUI.sprite = GetWeaponSprite(active.Model);
./UI/WeaponHUDDisplay.cs:            ammoTypeUI.sprite = GetAmmoSprite(active.Model);
./UI/WeaponHUDDisplay.cs:        }
./UI/WeaponHUDDisplay.cs:        else
./UI/WeaponHUDDisplay.cs:        {
./UI/WeaponHUDDisplay.cs:            magazineAmmoUI.text = "";
./UI/WeaponHUDDisplay.cs:            totalAmmoUI.text = "";
./UI/WeaponHUDDisplay.cs:            activeWeaponUI.sprite = emptySlot;
./UI/WeaponHUDDisplay.cs:            ammoTypeUI.sprite = emptySlot;
./UI/WeaponHUDDisplay.cs:        }
./UI/WeaponHUDDisplay.cs:
./UI/WeaponHUDDisplay.cs:        secondaryWeaponUI.sprite = secondary != null
./UI/WeaponHUDDisplay.cs:            ? GetWeaponSprite(secondary.Model)
./UI/WeaponHUDDisplay.cs:            : emptySlot;
./UI/WeaponHUDDisplay.cs:    }
./UI/WeaponHUDDisplay.cs:
./UI/WeaponHUDDisplay.cs:    private Sprite GetWeaponSprite(WeaponModel model)
./UI/WeaponHUDDisplay.cs:    {
./UI/WeaponHUDDisplay.cs:        return Resources.Load<Sprite>($"{model}_Weapon") ?? emptySlot;
./UI/WeaponHUDDisplay.cs:    }
./UI/WeaponHUDDisplay.cs:
./UI/WeaponHUDDisplay.cs:    private Sprite GetAmmoSprite(WeaponModel model)
./UI/WeaponHUDDisplay.cs:    {
./UI/WeaponHUDDisplay.cs:        return Resources.Load<Sprite>($"{model}_Ammo") ?? emptySlot;
./UI/WeaponHUDDisplay.cs:    }
./UI/WeaponHUDDisplay.cs:}
--
./UI/WeaponHUDDisplay.cs.meta:fileFormatVersion: 2
./UI/WeaponHUDDisplay.cs.meta:guid: 8b46687651bb23443acb9203a8982a99
--
./UI.meta:fileFormatVersion: 2
./UI.meta:guid: fb7c8f4ff2ecae94485f02001bdf3df7
./UI.meta:folderAsset: yes
./UI.meta:DefaultImporter:
./UI.meta:  externalObjects: {}
./UI.meta:  userData: 
./UI.meta:  assetBundleName: 
./UI.meta:  assetBundleVariant: 
--
./Validation/DialogueScriptScanner.cs:// File: Assets/Scripts/Validation/DialogueScriptScanner.cs
./Validation/DialogueScriptScanner.cs:using UnityEngine;
./Validation/DialogueScriptScanner.cs:
./Validation/DialogueScriptScanner.cs:namespace Game.DialogueSystem
./Validation/DialogueScriptScanner.cs:{
./Validation/DialogueScriptScanner.cs:    public class DialogueScriptScanner : MonoBehaviour
./Validation/DialogueScriptScanner.cs:    {
./Validation/DialogueScriptScanner.cs:        [SerializeField] private TextAsset dialogueScript;
./Validation/DialogueScriptScanner.cs:        [SerializeField] private string[] requiredKeys;
./Validation/DialogueScriptScanner.cs:
./Validation/DialogueScriptScanner.cs:        private void Start()
./Validation/DialogueScriptScanner.cs:        {
./Validation/DialogueScriptScanner.cs:            foreach (string key in requiredKeys)
./Validation/DialogueScriptScanner.cs:            {
./Validation/DialogueScriptScanner.cs:                if (!dialogueScript.text.Contains(key))
./Validation/DialogueScriptScanner.cs:                    Debug.LogWarning($"[DialogueScriptScanner] Key '{key}' missing in {dialogueScript.name}");
./Validation/DialogueScriptScanner.cs:            }
./Validation/DialogueScriptScanner.cs:        }
./Validation/DialogueScriptScanner.cs:    }
./Validation/DialogueScriptScanner.cs:}
--
./Validation/DialogueScriptScanner.cs.meta:fileFormatVersion: 2
./Validation/DialogueScriptScanner.cs.meta:guid: 1887380e19f71694e8f5cebbdf3a86fe
--
./Validation/SceneFlagValidator.cs:// File: Assets/Scripts/Validation/SceneFlagValidator.cs
./Validation/SceneFlagValidator.cs:using UnityEngine;
./Validation/SceneFlagValidator.cs:
./Validation/SceneFlagValidator.cs:namespace Game.DialogueSystem
./Validation/SceneFlagValidator.cs:{
./Validation/SceneFlagValidator.cs:    public class SceneFlagValidator : MonoBehaviour
./Validation/SceneFlagValidator.cs:    {
./Validation/SceneFlagValidator.cs:        [SerializeField] private StoryFlags flagSystem;
./Validation/SceneFlagValidator.cs:        [SerializeField] private string[] expectedFlags;
./Validation/SceneFlagValidator.cs:
./Validation/SceneFlagValidator.cs:        private void Awake()
./Validation/SceneFlagValidator.cs:        {
./Validation/SceneFlagValidator.cs:            foreach (string key in expectedFlags)
./Validation/SceneFlagValidator.cs:            {
./Validation/SceneFlagValidator.cs:                if (!flagSystem.flags.ContainsKey(key))
./Validation/SceneFlagValidator.cs:                    Debug.LogWarning($"[SceneFlagValidator] Missing expected flag: {key}");
./Validation/SceneFlagValidator.cs:            }
./Validation/SceneFlagValidator.cs:        }
./Validation/SceneFlagValidator.cs:    }
./Validation/SceneFlagValidator.cs:}
--
./Validation/SceneFlagValidator.cs.meta:fileFormatVersion: 2
./Validation/SceneFlagValidator.cs.meta:guid: 013ec26014347c440844e1e32e79a053
--
./Validation/Validation.asmdef:{
./Validation/Validation.asmdef:  "name": "Validation",
./Validation/Validation.asmdef:  "references": [
./Validation/Validation.asmdef:    "Narrative",
./Validation/Validation.asmdef:    "Flags"
./Validation/Validation.asmdef:  ],
./Validation/Validation.asmdef:  "autoReferenced": true
./Validation/Validation.asmdef:}
--
./Validation/Validation.asmdef.meta:fileFormatVersion: 2
./Validation/Validation.asmdef.meta:guid: 5fb07b715d1113941925b8498a484afa
./Validation/Validation.asmdef.meta:AssemblyDefinitionImporter:
./Validation/Validation.asmdef.meta:  externalObjects: {}
./Validation/Validation.asmdef.meta:  userData: 
./Validation/Validation.asmdef.meta:  assetBundleName: 
./Validation/Validation.asmdef.meta:  assetBundleVariant: 
--
./Validation.meta:fileFormatVersion: 2
./Validation.meta:guid: 53dc913ff2bba0e4bad33a20faf62c27
./Validation.meta:folderAsset: yes
./Validation.meta:DefaultImporter:
./Validation.meta:  externalObjects: {}
./Validation.meta:  userData: 
./Validation.meta:  assetBundleName: 
./Validation.meta:  assetBundleVariant: 
--
./World/LootSpawner.cs:// File: Assets/Scripts/World/LootSpawner.cs
./World/LootSpawner.cs:using UnityEngine;
./World/LootSpawner.cs:
./World/LootSpawner.cs:namespace Game.World
./World/LootSpawner.cs:{
./World/LootSpawner.cs:    public class LootSpawner : MonoBehaviour
./World/LootSpawner.cs:    {
./World/LootSpawner.cs:        [SerializeField] private Inventory.InventoryItem[] lootPool;
./World/LootSpawner.cs:        [SerializeField] private Transform spawnLocation;
./World/LootSpawner.cs:
./World/LootSpawner.cs:        public void SpawnLoot()
./World/LootSpawner.cs:        {
./World/LootSpawner.cs:            if (lootPool.Length > 0)
./World/LootSpawner.cs:            {
./World/LootSpawner.cs:                var item = lootPool[Random.Range(0, lootPool.Length)];
./World/LootSpawner.cs:                Debug.Log($"[LootSpawner] Spawned loot: {item.itemName}");
./World/LootSpawner.cs:                // Extend: Instantiate loot prefab, or log in inventory
./World/LootSpawner.cs:            }
./World/LootSpawner.cs:        }
./World/LootSpawner.cs:    }
./World/LootSpawner.cs:}
--
./World/LootSpawner.cs.meta:fileFormatVersion: 2
./World/LootSpawner.cs.meta:guid: 039a0ae8575993340bb121ea62e2542a
--
./World/LoreNode.cs:// File: Assets/Scripts/Lore/LoreNode.cs
./World/LoreNode.cs:using UnityEngine;
./World/LoreNode.cs:
./World/LoreNode.cs:namespace Game.Lore
./World/LoreNode.cs:{
./World/LoreNode.cs:    public class LoreNode : MonoBehaviour
./World/LoreNode.cs:    {
./World/LoreNode.cs:        [TextArea] public string loreText;
./World/LoreNode.cs:        public bool discovered;
./World/LoreNode.cs:
./World/LoreNode.cs:        public void RevealLore()
./World/LoreNode.cs:        {
./World/LoreNode.cs:            if (!discovered)
./World/LoreNode.cs:            {
./World/LoreNode.cs:                discovered = true;
./World/LoreNode.cs:                Debug.Log($"[LoreNode] Discovered: {loreText}");
./World/LoreNode.cs:                // Extend: Display in LoreLog UI or write to journal file
./World/LoreNode.cs:            }
./World/LoreNode.cs:        }
./World/LoreNode.cs:    }
./World/LoreNode.cs:}
--
./World/LoreNode.cs.meta:fileFormatVersion: 2
./World/LoreNode.cs.meta:guid: 8e67d84bd22cc8b40b2c2b35b0094337
--
./World/NotePickup.cs:// File: Assets/Scripts/World/NotePickup.cs
./World/NotePickup.cs:using UnityEngine;
./World/NotePickup.cs:
./World/NotePickup.cs:namespace Game.World
./World/NotePickup.cs:{
./World/NotePickup.cs:    public class NotePickup : MonoBehaviour
./World/NotePickup.cs:    {
./World/NotePickup.cs:        [TextArea] public string noteContent;
./World/NotePickup.cs:        public string noteID;
./World/NotePickup.cs:
./World/NotePickup.cs:        public void Pickup()
./World/NotePickup.cs:        {
./World/NotePickup.cs:            Debug.Log($"[NotePickup] Note '{noteID}' collected: {noteContent}");
./World/NotePickup.cs:            // Extend: Store in journal or queue for TypewriterDisplay
./World/NotePickup.cs:        }
./World/NotePickup.cs:    }
./World/NotePickup.cs:}
--
./World/NotePickup.cs.meta:fileFormatVersion: 2
./World/NotePickup.cs.meta:guid: be20143140d8f904bbb24af7e07b0618
--
./World/ResourceNode.cs:// File: Assets/Scripts/World/ResourceNode.cs
./World/ResourceNode.cs:using Game.Inventory;
./World/ResourceNode.cs:using UnityEngine;
./World/ResourceNode.cs:
./World/ResourceNode.cs:namespace Game.World
./World/ResourceNode.cs:{
./World/ResourceNode.cs:    public class ResourceNode : MonoBehaviour
./World/ResourceNode.cs:    {
./World/ResourceNode.cs:        [SerializeField] private InventoryItem resourceType;
./World/ResourceNode.cs:        [SerializeField] private int yieldAmount = 1;
./World/ResourceNode.cs:
./World/ResourceNode.cs:        public InventoryItem Harvest() => resourceType;
./World/ResourceNode.cs:        public int Yield() => yieldAmount;
./World/ResourceNode.cs:    }
./World/ResourceNode.cs:}
--
./World/ResourceNode.cs.meta:fileFormatVersion: 2
./World/ResourceNode.cs.meta:guid: 79bd5bf3bb91f434fb004ca5b9cbad78
--
./World/SleepCycle.cs:// File: Assets/Scripts/World/SleepCycle.cs
./World/SleepCycle.cs:using UnityEngine;
./World/SleepCycle.cs:
./World/SleepCycle.cs:namespace Game.World
./World/SleepCycle.cs:{
./World/SleepCycle.cs:    public class SleepCycle : MonoBehaviour
./World/SleepCycle.cs:    {
./World/SleepCycle.cs:        public bool isResting;
./World/SleepCycle.cs:        public float restTime;
./World/SleepCycle.cs:
./World/SleepCycle.cs:        public void Sleep(float hours)
./World/SleepCycle.cs:        {
./World/SleepCycle.cs:            isResting = true;
./World/SleepCycle.cs:            restTime += hours;
./World/SleepCycle.cs:            Debug.Log($"[SleepCycle] Slept for {hours} hours.");
./World/SleepCycle.cs:            // Extend: reset fatigue stat, pass time in SurvivalClock
./World/SleepCycle.cs:        }
./World/SleepCycle.cs:
./World/SleepCycle.cs:        public void WakeUp()
./World/SleepCycle.cs:        {
./World/SleepCycle.cs:            isResting = false;
./World/SleepCycle.cs:            Debug.Log("[SleepCycle] Woke up.");
./World/SleepCycle.cs:        }
./World/SleepCycle.cs:    }
./World/SleepCycle.cs:}
--
./World/SleepCycle.cs.meta:fileFormatVersion: 2
./World/SleepCycle.cs.meta:guid: 652982feb608c1a4bb1873b08d205e19
--
./World/SpawnPointManager.cs:// File: Assets/Scripts/World/SpawnPointManager.cs
./World/SpawnPointManager.cs:using UnityEngine;
./World/SpawnPointManager.cs:
./World/SpawnPointManager.cs:namespace Game.World
./World/SpawnPointManager.cs:{
./World/SpawnPointManager.cs:    public class SpawnPointManager : MonoBehaviour
./World/SpawnPointManager.cs:    {
./World/SpawnPointManager.cs:        [SerializeField] private Transform[] spawnPoints;
./World/SpawnPointManager.cs:        [SerializeField] private GameObject playerPrefab;
./World/SpawnPointManager.cs:
./World/SpawnPointManager.cs:        public void SpawnPlayer(int index)
./World/SpawnPointManager.cs:        {
./World/SpawnPointManager.cs:            if (index < spawnPoints.Length)
./World/SpawnPointManager.cs:            {
./World/SpawnPointManager.cs:                Instantiate(playerPrefab, spawnPoints[index].position, Quaternion.identity);
./World/SpawnPointManager.cs:                Debug.Log($"[SpawnPointManager] Spawned player at index {index}");
./World/SpawnPointManager.cs:            }
./World/SpawnPointManager.cs:        }
./World/SpawnPointManager.cs:    }
./World/SpawnPointManager.cs:}
--
./World/SpawnPointManager.cs.meta:fileFormatVersion: 2
./World/SpawnPointManager.cs.meta:guid: d1a83e0fd01474d40831d862553c2a75
--
./World/SurvivalClock.cs:// File: Assets/Scripts/World/SurvivalClock.cs
./World/SurvivalClock.cs:using UnityEngine;
./World/SurvivalClock.cs:
./World/SurvivalClock.cs:namespace Game.World
./World/SurvivalClock.cs:{
./World/SurvivalClock.cs:    public class SurvivalClock : MonoBehaviour
./World/SurvivalClock.cs:    {
./World/SurvivalClock.cs:        public float timePassed; // in hours
./World/SurvivalClock.cs:        public float timeStep = 0.05f;
./World/SurvivalClock.cs:
./World/SurvivalClock.cs:        private void Update()
./World/SurvivalClock.cs:        {
./World/SurvivalClock.cs:            timePassed += Time.deltaTime * timeStep;
./World/SurvivalClock.cs:        }
./World/SurvivalClock.cs:
./World/SurvivalClock.cs:        public string GetTimeReport()
./World/SurvivalClock.cs:        {
./World/SurvivalClock.cs:            int hours = Mathf.FloorToInt(timePassed);
./World/SurvivalClock.cs:            return $"[SurvivalClock] Time elapsed: {hours}h";
./World/SurvivalClock.cs:        }
./World/SurvivalClock.cs:    }
./World/SurvivalClock.cs:}
--
./World/SurvivalClock.cs.meta:fileFormatVersion: 2
./World/SurvivalClock.cs.meta:guid: 6d048b473a7450940bcf17104284d3e7
--
./World/World.asmdef:{
./World/World.asmdef:  "name": "World",
./World/World.asmdef:  "references": [
./World/World.asmdef:    "Inventory",
./World/World.asmdef:    "Flags"
./World/World.asmdef:  ],
./World/World.asmdef:  "autoReferenced": true
./World/World.asmdef:}
--
./World/World.asmdef.meta:fileFormatVersion: 2
./World/World.asmdef.meta:guid: fc9728c9e7329b94fad2b8dbc9d3e2ad
./World/World.asmdef.meta:AssemblyDefinitionImporter:
./World/World.asmdef.meta:  externalObjects: {}
./World/World.asmdef.meta:  userData: 
./World/World.asmdef.meta:  assetBundleName: 
./World/World.asmdef.meta:  assetBundleVariant: 
--
./World.meta:fileFormatVersion: 2
./World.meta:guid: bf9f9fc85dab7704196cc9330b9bc831
./World.meta:folderAsset: yes
./World.meta:DefaultImporter:
./World.meta:  externalObjects: {}
./World.meta:  userData: 
./World.meta:  assetBundleName: 
./World.meta:  assetBundleVariant: 
